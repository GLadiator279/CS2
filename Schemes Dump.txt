Output format: [module: [class: module [field_name = field_offset // field_type]]]

schemasystem.dll:
 CSchemaSystemInternalRegistration: [schemasystem.dll]
    m_Vector2D = 0X000000 // Vector2D
    m_Vector = 0X000008 // Vector
    m_VectorAligned = 0X000020 // VectorAligned
    m_Quaternion = 0X000030 // Quaternion
    m_QAngle = 0X000040 // QAngle
    m_RotationVector = 0X00004C // RotationVector
    m_RadianEuler = 0X000058 // RadianEuler
    m_DegreeEuler = 0X000064 // DegreeEuler
    m_QuaternionStorage = 0X000070 // QuaternionStorage
    m_matrix3x4_t = 0X000080 // matrix3x4_t
    m_matrix3x4a_t = 0X0000B0 // matrix3x4a_t
    m_Color = 0X0000E0 // Color
    m_Vector4D = 0X0000E4 // Vector4D
    m_CTransform = 0X000100 // CTransform
    m_pKeyValues = 0X000120 // KeyValues*
    m_CUtlBinaryBlock = 0X000128 // CUtlBinaryBlock
    m_CUtlString = 0X000140 // CUtlString
    m_CUtlSymbol = 0X000148 // CUtlSymbol
    m_stringToken = 0X00014C // CUtlStringToken
    m_stringTokenWithStorage = 0X000150 // CUtlStringTokenWithStorage
    m_ResourceTypes = 0X000168 // CResourceArray< CResourcePointer< CResourceString > >
    m_KV3 = 0X000170 // KeyValues3

 InfoForResourceTypeCResourceManifestInternal: [schemasystem.dll]
    No schemes available

 ResourceId_t: [schemasystem.dll]
    m_Value = 0X000000 // uint64

 CExampleSchemaVData_Monomorphic: [schemasystem.dll]
    m_nExample1 = 0X000000 // int32
    m_nExample2 = 0X000004 // int32

 CExampleSchemaVData_PolymorphicBase: [schemasystem.dll]
    m_nBase = 0X000008 // int32

 CExampleSchemaVData_PolymorphicDerivedA: [schemasystem.dll]
    m_nDerivedA = 0X000010 // int32

 CExampleSchemaVData_PolymorphicDerivedB: [schemasystem.dll]
    m_nDerivedB = 0X000010 // int32


resourcesystem.dll:
 TestResource_t: [resourcesystem.dll]
    m_name = 0X000000 // CUtlString

 InfoForResourceTypeTestResource_t: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeProceduralTestResource_t: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeManifestTestResource_t: [resourcesystem.dll]
    No schemes available

 ManifestTestResource_t: [resourcesystem.dll]
    m_name = 0X000000 // CUtlString
    m_child = 0X000008 // CStrongHandle< InfoForResourceTypeManifestTestResource_t >

 InfoForResourceTypeCVDataResource: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeIPulseGraphDef: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeIParticleSystemDefinition: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeIParticleSnapshot: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCAnimData: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCAnimationGroup: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCSequenceGroupData: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeIMaterial2: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCMorphSetData: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCRenderMesh: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCModel: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCTextureBase: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeIVectorGraphic: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCVSoundEventScriptList: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCVSoundStackScriptList: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeVSound_t: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCVMixListResource: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCPhysAggregateData: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCVPhysXSurfacePropertiesList: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCEntityLump: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCWorldNode: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeWorld_t: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCVoxelVisibility: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCPostProcessingResource: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCPanoramaStyle: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCPanoramaLayout: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCPanoramaDynamicImages: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCDotaItemDefinitionResource: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCPanoramaScript: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCPanoramaTypeScript: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCDOTAPatchNotesList: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeIAnimGraphModelBinding: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCChoreoSceneFileData: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCDACGameDefsData: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCCompositeMaterialKit: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCSmartProp: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCCSGOEconItem: [resourcesystem.dll]
    No schemes available

 InfoForResourceTypeCResponseRulesList: [resourcesystem.dll]
    No schemes available

 FuseVariableIndex_t: [resourcesystem.dll]
    m_Value = 0X000000 // uint16

 FuseFunctionIndex_t: [resourcesystem.dll]
    m_Value = 0X000000 // uint16

 ConstantInfo_t: [resourcesystem.dll]
    m_name = 0X000000 // CUtlString
    m_nameToken = 0X000008 // CUtlStringToken
    m_flValue = 0X00000C // float32

 VariableInfo_t: [resourcesystem.dll]
    m_name = 0X000000 // CUtlString
    m_nameToken = 0X000008 // CUtlStringToken
    m_nIndex = 0X00000C // FuseVariableIndex_t
    m_nNumComponents = 0X00000E // uint8
    m_eVarType = 0X00000F // FuseVariableType_t
    m_eAccess = 0X000010 // FuseVariableAccess_t

 FunctionInfo_t: [resourcesystem.dll]
    m_name = 0X000008 // CUtlString
    m_nameToken = 0X000010 // CUtlStringToken
    m_nParamCount = 0X000014 // int32
    m_nIndex = 0X000018 // FuseFunctionIndex_t
    m_bIsPure = 0X00001A // bool

 CFuseProgram: [resourcesystem.dll]
    m_programBuffer = 0X000000 // CUtlVector< uint8 >
    m_variablesRead = 0X000018 // CUtlVector< FuseVariableIndex_t >
    m_variablesWritten = 0X000030 // CUtlVector< FuseVariableIndex_t >
    m_nMaxTempVarsUsed = 0X000048 // int32

 CFuseSymbolTable: [resourcesystem.dll]
    m_constants = 0X000008 // CUtlHashtable< CUtlStringToken, ConstantInfo_t >
    m_variables = 0X000028 // CUtlHashtable< CUtlStringToken, VariableInfo_t >
    m_functions = 0X000048 // CUtlHashtable< CUtlStringToken, FunctionInfo_t >

 AABB_t: [resourcesystem.dll]
    m_vMinBounds = 0X000000 // Vector
    m_vMaxBounds = 0X00000C // Vector

 PackedAABB_t: [resourcesystem.dll]
    m_nPackedMin = 0X000000 // uint32
    m_nPackedMax = 0X000004 // uint32

 FourQuaternions: [resourcesystem.dll]
    x = 0X000000 // fltx4
    y = 0X000010 // fltx4
    z = 0X000020 // fltx4
    w = 0X000030 // fltx4


rendersystemdx11.dll:
 RenderInputLayoutField_t: [rendersystemdx11.dll]
    m_pSemanticName = 0X000000 // uint8[32]
    m_nSemanticIndex = 0X000020 // int32
    m_Format = 0X000024 // uint32
    m_nOffset = 0X000028 // int32
    m_nSlot = 0X00002C // int32
    m_nSlotType = 0X000030 // RenderSlotType_t
    m_nInstanceStepRate = 0X000034 // int32

 VsInputSignatureElement_t: [rendersystemdx11.dll]
    m_pName = 0X000000 // char[64]
    m_pSemantic = 0X000040 // char[64]
    m_pD3DSemanticName = 0X000080 // char[64]
    m_nD3DSemanticIndex = 0X0000C0 // int32

 VsInputSignature_t: [rendersystemdx11.dll]
    m_elems = 0X000000 // CUtlVector< VsInputSignatureElement_t >


engine2.dll:
 EngineLoopState_t: [engine2.dll]
    m_nPlatWindowWidth = 0X000018 // int32
    m_nPlatWindowHeight = 0X00001C // int32
    m_nRenderWidth = 0X000020 // int32
    m_nRenderHeight = 0X000024 // int32

 EventModInitialized_t: [engine2.dll]
    No schemes available

 EventFrameBoundary_t: [engine2.dll]
    m_flFrameTime = 0X000000 // float32

 EventProfileStorageAvailable_t: [engine2.dll]
    m_nSplitScreenSlot = 0X000000 // CSplitScreenSlot

 EventSplitScreenStateChanged_t: [engine2.dll]
    No schemes available

 EventSetTime_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_nClientOutputFrames = 0X000028 // int32
    m_flRealTime = 0X000030 // float64
    m_flRenderTime = 0X000038 // float64
    m_flRenderFrameTime = 0X000040 // float64
    m_flRenderFrameTimeUnbounded = 0X000048 // float64
    m_flRenderFrameTimeUnscaled = 0X000050 // float64
    m_flTickRemainder = 0X000058 // float64

 EventClientPollInput_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_flRealTime = 0X000028 // float32

 EventClientProcessInput_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_flRealTime = 0X000028 // float32

 EventClientProcessGameInput_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_flRealTime = 0X000028 // float32
    m_flFrameTime = 0X00002C // float32

 EventClientPreOutput_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_flRenderTime = 0X000028 // float64
    m_flRenderFrameTime = 0X000030 // float64
    m_flRenderFrameTimeUnbounded = 0X000038 // float64
    m_flRealTime = 0X000040 // float32
    m_bRenderOnly = 0X000044 // bool

 EventClientSceneSystemThreadStateChange_t: [engine2.dll]
    m_bThreadsActive = 0X000000 // bool

 EventClientOutput_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_flRenderTime = 0X000028 // float32
    m_flRealTime = 0X00002C // float32
    m_flRenderFrameTimeUnbounded = 0X000030 // float32
    m_bRenderOnly = 0X000034 // bool

 EventClientPostOutput_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_flRenderTime = 0X000028 // float64
    m_flRenderFrameTime = 0X000030 // float32
    m_flRenderFrameTimeUnbounded = 0X000034 // float32
    m_bRenderOnly = 0X000038 // bool

 EventClientFrameSimulate_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_flRealTime = 0X000028 // float32
    m_flFrameTime = 0X00002C // float32

 EventSimpleLoopFrameUpdate_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_flRealTime = 0X000028 // float32
    m_flFrameTime = 0X00002C // float32

 EventSimulate_t: [engine2.dll]
    m_LoopState = 0X000000 // EngineLoopState_t
    m_bFirstTick = 0X000028 // bool
    m_bLastTick = 0X000029 // bool

 EventAdvanceTick_t: [engine2.dll]
    m_nCurrentTick = 0X000030 // int32
    m_nCurrentTickThisFrame = 0X000034 // int32
    m_nTotalTicksThisFrame = 0X000038 // int32
    m_nTotalTicks = 0X00003C // int32

 EventPostAdvanceTick_t: [engine2.dll]
    m_nCurrentTick = 0X000030 // int32
    m_nCurrentTickThisFrame = 0X000034 // int32
    m_nTotalTicksThisFrame = 0X000038 // int32
    m_nTotalTicks = 0X00003C // int32

 EventServerAdvanceTick_t: [engine2.dll]
    No schemes available

 EventServerPostAdvanceTick_t: [engine2.dll]
    No schemes available

 EventClientAdvanceTick_t: [engine2.dll]
    No schemes available

 EventClientPostAdvanceTick_t: [engine2.dll]
    No schemes available

 EventClientSendInput_t: [engine2.dll]
    m_bFinalClientCommandTick = 0X000000 // bool
    m_nAdditionalClientCommandsToCreate = 0X000004 // int32

 EventClientPredictionPostNetupdate_t: [engine2.dll]
    No schemes available

 EventClientPollNetworking_t: [engine2.dll]
    m_nTickCount = 0X000000 // int32

 EventClientProcessNetworking_t: [engine2.dll]
    No schemes available

 EventClientPreSimulate_t: [engine2.dll]
    No schemes available

 EventClientSimulate_t: [engine2.dll]
    No schemes available

 EventServerPollNetworking_t: [engine2.dll]
    No schemes available

 EventServerProcessNetworking_t: [engine2.dll]
    No schemes available

 EventServerSimulate_t: [engine2.dll]
    No schemes available

 EventServerPostSimulate_t: [engine2.dll]
    No schemes available

 EventClientPostSimulate_t: [engine2.dll]
    No schemes available

 EventClientPauseSimulate_t: [engine2.dll]
    No schemes available

 EventPostDataUpdate_t: [engine2.dll]
    m_nCount = 0X000000 // int32

 EventPreDataUpdate_t: [engine2.dll]
    m_nCount = 0X000000 // int32

 EventAppShutdown_t: [engine2.dll]
    m_nDummy0 = 0X000000 // int32

 IHandleEntity: [engine2.dll]
    No schemes available

 CNetworkVarChainer: [engine2.dll]
    m_PathIndex = 0X000020 // ChangeAccessorFieldPathIndex_t

 CVariantDefaultAllocator: [engine2.dll]
    No schemes available

 EntOutput_t: [engine2.dll]
    No schemes available

 EntComponentInfo_t: [engine2.dll]
    m_pName = 0X000000 // char*
    m_pCPPClassname = 0X000008 // char*
    m_pNetworkDataReferencedDescription = 0X000010 // char*
    m_pNetworkDataReferencedPtrPropDescription = 0X000018 // char*
    m_nRuntimeIndex = 0X000020 // int32
    m_nFlags = 0X000024 // uint32
    m_pBaseClassComponentHelper = 0X000060 // CEntityComponentHelper*

 CEntityComponent: [engine2.dll]
    No schemes available

 EntInput_t: [engine2.dll]
    No schemes available

 CEntityComponentHelper: [engine2.dll]
    m_flags = 0X000008 // uint32
    m_pInfo = 0X000010 // EntComponentInfo_t*
    m_nPriority = 0X000018 // int32
    m_pNext = 0X000020 // CEntityComponentHelper*

 CEntityIdentity: [engine2.dll]
    m_nameStringableIndex = 0X000014 // int32
    m_name = 0X000018 // CUtlSymbolLarge
    m_designerName = 0X000020 // CUtlSymbolLarge
    m_flags = 0X000030 // uint32
    m_worldGroupId = 0X000038 // WorldGroupId_t
    m_fDataObjectTypes = 0X00003C // uint32
    m_PathIndex = 0X000040 // ChangeAccessorFieldPathIndex_t
    m_pPrev = 0X000058 // CEntityIdentity*
    m_pNext = 0X000060 // CEntityIdentity*
    m_pPrevByClass = 0X000068 // CEntityIdentity*
    m_pNextByClass = 0X000070 // CEntityIdentity*

 CEmptyEntityInstance: [engine2.dll]
    No schemes available

 CEntityInstance: [engine2.dll]
    m_iszPrivateVScripts = 0X000008 // CUtlSymbolLarge
    m_pEntity = 0X000010 // CEntityIdentity*
    m_CScriptComponent = 0X000028 // CScriptComponent*

 CEntityIOOutput: [engine2.dll]
    m_Value = 0X000018 // CVariantBase< CVariantDefaultAllocator >

 CScriptComponent: [engine2.dll]
    m_scriptClassName = 0X000030 // CUtlSymbolLarge


materialsystem2.dll:
 MaterialParam_t: [materialsystem2.dll]
    m_name = 0X000000 // CUtlString

 MaterialParamInt_t: [materialsystem2.dll]
    m_nValue = 0X000008 // int32

 MaterialParamFloat_t: [materialsystem2.dll]
    m_flValue = 0X000008 // float32

 MaterialParamVector_t: [materialsystem2.dll]
    m_value = 0X000008 // Vector4D

 MaterialParamTexture_t: [materialsystem2.dll]
    m_pValue = 0X000008 // CStrongHandle< InfoForResourceTypeCTextureBase >

 MaterialParamString_t: [materialsystem2.dll]
    m_value = 0X000008 // CUtlString

 MaterialParamBuffer_t: [materialsystem2.dll]
    m_value = 0X000008 // CUtlBinaryBlock

 MaterialResourceData_t: [materialsystem2.dll]
    m_materialName = 0X000000 // CUtlString
    m_shaderName = 0X000008 // CUtlString
    m_intParams = 0X000010 // CUtlVector< MaterialParamInt_t >
    m_floatParams = 0X000028 // CUtlVector< MaterialParamFloat_t >
    m_vectorParams = 0X000040 // CUtlVector< MaterialParamVector_t >
    m_textureParams = 0X000058 // CUtlVector< MaterialParamTexture_t >
    m_dynamicParams = 0X000070 // CUtlVector< MaterialParamBuffer_t >
    m_dynamicTextureParams = 0X000088 // CUtlVector< MaterialParamBuffer_t >
    m_intAttributes = 0X0000A0 // CUtlVector< MaterialParamInt_t >
    m_floatAttributes = 0X0000B8 // CUtlVector< MaterialParamFloat_t >
    m_vectorAttributes = 0X0000D0 // CUtlVector< MaterialParamVector_t >
    m_textureAttributes = 0X0000E8 // CUtlVector< MaterialParamTexture_t >
    m_stringAttributes = 0X000100 // CUtlVector< MaterialParamString_t >
    m_renderAttributesUsed = 0X000118 // CUtlVector< CUtlString >

 PostProcessingTonemapParameters_t: [materialsystem2.dll]
    m_flExposureBias = 0X000000 // float32
    m_flShoulderStrength = 0X000004 // float32
    m_flLinearStrength = 0X000008 // float32
    m_flLinearAngle = 0X00000C // float32
    m_flToeStrength = 0X000010 // float32
    m_flToeNum = 0X000014 // float32
    m_flToeDenom = 0X000018 // float32
    m_flWhitePoint = 0X00001C // float32
    m_flLuminanceSource = 0X000020 // float32
    m_flExposureBiasShadows = 0X000024 // float32
    m_flExposureBiasHighlights = 0X000028 // float32
    m_flMinShadowLum = 0X00002C // float32
    m_flMaxShadowLum = 0X000030 // float32
    m_flMinHighlightLum = 0X000034 // float32
    m_flMaxHighlightLum = 0X000038 // float32

 PostProcessingBloomParameters_t: [materialsystem2.dll]
    m_blendMode = 0X000000 // BloomBlendMode_t
    m_flBloomStrength = 0X000004 // float32
    m_flScreenBloomStrength = 0X000008 // float32
    m_flBlurBloomStrength = 0X00000C // float32
    m_flBloomThreshold = 0X000010 // float32
    m_flBloomThresholdWidth = 0X000014 // float32
    m_flSkyboxBloomStrength = 0X000018 // float32
    m_flBloomStartValue = 0X00001C // float32
    m_flBlurWeight = 0X000020 // float32[5]
    m_vBlurTint = 0X000034 // Vector[5]

 PostProcessingVignetteParameters_t: [materialsystem2.dll]
    m_flVignetteStrength = 0X000000 // float32
    m_vCenter = 0X000004 // Vector2D
    m_flRadius = 0X00000C // float32
    m_flRoundness = 0X000010 // float32
    m_flFeather = 0X000014 // float32
    m_vColorTint = 0X000018 // Vector

 PostProcessingLocalContrastParameters_t: [materialsystem2.dll]
    m_flLocalContrastStrength = 0X000000 // float32
    m_flLocalContrastEdgeStrength = 0X000004 // float32
    m_flLocalContrastVignetteStart = 0X000008 // float32
    m_flLocalContrastVignetteEnd = 0X00000C // float32
    m_flLocalContrastVignetteBlur = 0X000010 // float32

 PostProcessingResource_t: [materialsystem2.dll]
    m_bHasTonemapParams = 0X000000 // bool
    m_toneMapParams = 0X000004 // PostProcessingTonemapParameters_t
    m_bHasBloomParams = 0X000040 // bool
    m_bloomParams = 0X000044 // PostProcessingBloomParameters_t
    m_bHasVignetteParams = 0X0000B4 // bool
    m_vignetteParams = 0X0000B8 // PostProcessingVignetteParameters_t
    m_bHasLocalContrastParams = 0X0000DC // bool
    m_localConstrastParams = 0X0000E0 // PostProcessingLocalContrastParameters_t
    m_nColorCorrectionVolumeDim = 0X0000F4 // int32
    m_colorCorrectionVolumeData = 0X0000F8 // CUtlBinaryBlock
    m_bHasColorCorrection = 0X000110 // bool


networksystem.dll:
 ChangeAccessorFieldPathIndex_t: [networksystem.dll]
    m_Value = 0X000000 // int16


animationsystem.dll:
 MoodAnimation_t: [animationsystem.dll]
    m_sName = 0X000000 // CUtlString
    m_flWeight = 0X000008 // float32

 MoodAnimationLayer_t: [animationsystem.dll]
    m_sName = 0X000000 // CUtlString
    m_bActiveListening = 0X000008 // bool
    m_bActiveTalking = 0X000009 // bool
    m_layerAnimations = 0X000010 // CUtlVector< MoodAnimation_t >
    m_flIntensity = 0X000028 // CRangeFloat
    m_flDurationScale = 0X000030 // CRangeFloat
    m_bScaleWithInts = 0X000038 // bool
    m_flNextStart = 0X00003C // CRangeFloat
    m_flStartOffset = 0X000044 // CRangeFloat
    m_flEndOffset = 0X00004C // CRangeFloat
    m_flFadeIn = 0X000054 // float32
    m_flFadeOut = 0X000058 // float32

 CMoodVData: [animationsystem.dll]
    m_sModelName = 0X000000 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_nMoodType = 0X0000E0 // MoodType_t
    m_animationLayers = 0X0000E8 // CUtlVector< MoodAnimationLayer_t >

 AnimationDecodeDebugDumpElement_t: [animationsystem.dll]
    m_nEntityIndex = 0X000000 // int32
    m_modelName = 0X000008 // CUtlString
    m_poseParams = 0X000010 // CUtlVector< CUtlString >
    m_decodeOps = 0X000028 // CUtlVector< CUtlString >
    m_internalOps = 0X000040 // CUtlVector< CUtlString >
    m_decodedAnims = 0X000058 // CUtlVector< CUtlString >

 AnimationDecodeDebugDump_t: [animationsystem.dll]
    m_processingType = 0X000000 // AnimationProcessingType_t
    m_elems = 0X000008 // CUtlVector< AnimationDecodeDebugDumpElement_t >

 AnimationSnapshotBase_t: [animationsystem.dll]
    m_flRealTime = 0X000000 // float32
    m_rootToWorld = 0X000010 // matrix3x4a_t
    m_bBonesInWorldSpace = 0X000040 // bool
    m_boneSetupMask = 0X000048 // CUtlVector< uint32 >
    m_boneTransforms = 0X000060 // CUtlVector< matrix3x4a_t >
    m_flexControllers = 0X000078 // CUtlVector< float32 >
    m_SnapshotType = 0X000090 // AnimationSnapshotType_t
    m_bHasDecodeDump = 0X000094 // bool
    m_DecodeDump = 0X000098 // AnimationDecodeDebugDumpElement_t

 AnimationSnapshot_t: [animationsystem.dll]
    m_nEntIndex = 0X000110 // int32
    m_modelName = 0X000118 // CUtlString

 CAnimBoneDifference: [animationsystem.dll]
    m_name = 0X000000 // CBufferString
    m_parent = 0X000010 // CBufferString
    m_posError = 0X000020 // Vector
    m_bHasRotation = 0X00002C // bool
    m_bHasMovement = 0X00002D // bool

 CAnimMorphDifference: [animationsystem.dll]
    m_name = 0X000000 // CBufferString

 CAnimUserDifference: [animationsystem.dll]
    m_name = 0X000000 // CBufferString
    m_nType = 0X000010 // int32

 CAnimEncodeDifference: [animationsystem.dll]
    m_boneArray = 0X000000 // CUtlVector< CAnimBoneDifference >
    m_morphArray = 0X000018 // CUtlVector< CAnimMorphDifference >
    m_userArray = 0X000030 // CUtlVector< CAnimUserDifference >
    m_bHasRotationBitArray = 0X000048 // CUtlVector< uint8 >
    m_bHasMovementBitArray = 0X000060 // CUtlVector< uint8 >
    m_bHasMorphBitArray = 0X000078 // CUtlVector< uint8 >
    m_bHasUserBitArray = 0X000090 // CUtlVector< uint8 >

 CAnimAnimEvent: [animationsystem.dll]
    m_nFrame = 0X000000 // int32
    m_flCycle = 0X000004 // float32
    m_EventData = 0X000008 // KeyValues3
    m_sLegacyOptions = 0X000018 // CBufferString
    m_sEventName = 0X000028 // CBufferString

 CAnimMovement: [animationsystem.dll]
    endframe = 0X000000 // int32
    motionflags = 0X000004 // int32
    v0 = 0X000008 // float32
    v1 = 0X00000C // float32
    angle = 0X000010 // float32
    vector = 0X000014 // Vector
    position = 0X000020 // Vector

 CAnimLocalHierarchy: [animationsystem.dll]
    m_sBone = 0X000000 // CBufferString
    m_sNewParent = 0X000010 // CBufferString
    m_nStartFrame = 0X000020 // int32
    m_nPeakFrame = 0X000024 // int32
    m_nTailFrame = 0X000028 // int32
    m_nEndFrame = 0X00002C // int32

 CAnimDecoder: [animationsystem.dll]
    m_szName = 0X000000 // CBufferString
    m_nVersion = 0X000010 // int32
    m_nType = 0X000014 // int32

 CAnimFrameSegment: [animationsystem.dll]
    m_nUniqueFrameIndex = 0X000000 // int32
    m_nLocalElementMasks = 0X000004 // uint32
    m_nLocalChannel = 0X000008 // int32
    m_container = 0X000010 // CUtlBinaryBlock

 CAnimFrameBlockAnim: [animationsystem.dll]
    m_nStartFrame = 0X000000 // int32
    m_nEndFrame = 0X000004 // int32
    m_segmentIndexArray = 0X000008 // CUtlVector< int32 >

 CAnimEncodedFrames: [animationsystem.dll]
    m_fileName = 0X000000 // CBufferString
    m_nFrames = 0X000010 // int32
    m_nFramesPerBlock = 0X000014 // int32
    m_frameblockArray = 0X000018 // CUtlVector< CAnimFrameBlockAnim >
    m_usageDifferences = 0X000030 // CAnimEncodeDifference

 CAnimDesc_Flag: [animationsystem.dll]
    m_bLooping = 0X000000 // bool
    m_bAllZeros = 0X000001 // bool
    m_bHidden = 0X000002 // bool
    m_bDelta = 0X000003 // bool
    m_bLegacyWorldspace = 0X000004 // bool
    m_bModelDoc = 0X000005 // bool
    m_bImplicitSeqIgnoreDelta = 0X000006 // bool
    m_bAnimGraphAdditive = 0X000007 // bool

 CAnimSequenceParams: [animationsystem.dll]
    m_flFadeInTime = 0X000000 // float32
    m_flFadeOutTime = 0X000004 // float32

 CAnimDesc: [animationsystem.dll]
    m_name = 0X000000 // CBufferString
    m_flags = 0X000010 // CAnimDesc_Flag
    fps = 0X000018 // float32
    m_Data = 0X000020 // CAnimEncodedFrames
    m_movementArray = 0X0000F8 // CUtlVector< CAnimMovement >
    m_eventArray = 0X000110 // CUtlVector< CAnimAnimEvent >
    m_activityArray = 0X000128 // CUtlVector< CAnimActivity >
    m_hierarchyArray = 0X000140 // CUtlVector< CAnimLocalHierarchy >
    framestalltime = 0X000158 // float32
    m_vecRootMin = 0X00015C // Vector
    m_vecRootMax = 0X000168 // Vector
    m_vecBoneWorldMin = 0X000178 // CUtlVector< Vector >
    m_vecBoneWorldMax = 0X000190 // CUtlVector< Vector >
    m_sequenceParams = 0X0001A8 // CAnimSequenceParams

 CAnimActivity: [animationsystem.dll]
    m_name = 0X000000 // CBufferString
    m_nActivity = 0X000010 // int32
    m_nFlags = 0X000014 // int32
    m_nWeight = 0X000018 // int32

 CAnimData: [animationsystem.dll]
    m_name = 0X000010 // CBufferString
    m_animArray = 0X000020 // CUtlVector< CAnimDesc >
    m_decoderArray = 0X000038 // CUtlVector< CAnimDecoder >
    m_nMaxUniqueFrameIndex = 0X000050 // int32
    m_segmentArray = 0X000058 // CUtlVector< CAnimFrameSegment >

 CAnimBone: [animationsystem.dll]
    m_name = 0X000000 // CBufferString
    m_parent = 0X000010 // int32
    m_pos = 0X000014 // Vector
    m_quat = 0X000020 // QuaternionStorage
    m_scale = 0X000030 // float32
    m_qAlignment = 0X000034 // QuaternionStorage
    m_flags = 0X000044 // int32

 CAnimUser: [animationsystem.dll]
    m_name = 0X000000 // CBufferString
    m_nType = 0X000010 // int32

 CAnimDataChannelDesc: [animationsystem.dll]
    m_szChannelClass = 0X000000 // CBufferString
    m_szVariableName = 0X000010 // CBufferString
    m_nFlags = 0X000020 // int32
    m_nType = 0X000024 // int32
    m_szGrouping = 0X000028 // CBufferString
    m_szDescription = 0X000038 // CBufferString
    m_szElementNameArray = 0X000048 // CUtlVector< CBufferString >
    m_nElementIndexArray = 0X000060 // CUtlVector< int32 >
    m_nElementMaskArray = 0X000078 // CUtlVector< uint32 >

 CAnimKeyData: [animationsystem.dll]
    m_name = 0X000000 // CBufferString
    m_boneArray = 0X000010 // CUtlVector< CAnimBone >
    m_userArray = 0X000028 // CUtlVector< CAnimUser >
    m_morphArray = 0X000040 // CUtlVector< CBufferString >
    m_nChannelElements = 0X000058 // int32
    m_dataChannelArray = 0X000060 // CUtlVector< CAnimDataChannelDesc >

 CAnimationGroup: [animationsystem.dll]
    m_nFlags = 0X000010 // uint32
    m_name = 0X000018 // CBufferString
    m_localHAnimArray_Handle = 0X000060 // CUtlVector< CStrongHandle< InfoForResourceTypeCAnimData > >
    m_includedGroupArray_Handle = 0X000078 // CUtlVector< CStrongHandle< InfoForResourceTypeCAnimationGroup > >
    m_directHSeqGroup_Handle = 0X000090 // CStrongHandle< InfoForResourceTypeCSequenceGroupData >
    m_decodeKey = 0X000098 // CAnimKeyData
    m_szScripts = 0X000110 // CUtlVector< CBufferString >

 CSeqAutoLayerFlag: [animationsystem.dll]
    m_bPost = 0X000000 // bool
    m_bSpline = 0X000001 // bool
    m_bXFade = 0X000002 // bool
    m_bNoBlend = 0X000003 // bool
    m_bLocal = 0X000004 // bool
    m_bPose = 0X000005 // bool
    m_bFetchFrame = 0X000006 // bool
    m_bSubtract = 0X000007 // bool

 CSeqAutoLayer: [animationsystem.dll]
    m_nLocalReference = 0X000000 // int16
    m_nLocalPose = 0X000002 // int16
    m_flags = 0X000004 // CSeqAutoLayerFlag
    m_start = 0X00000C // float32
    m_peak = 0X000010 // float32
    m_tail = 0X000014 // float32
    m_end = 0X000018 // float32

 CSeqIKLock: [animationsystem.dll]
    m_flPosWeight = 0X000000 // float32
    m_flAngleWeight = 0X000004 // float32
    m_nLocalBone = 0X000008 // int16
    m_bBonesOrientedAlongPositiveX = 0X00000A // bool

 CSeqBoneMaskList: [animationsystem.dll]
    m_sName = 0X000000 // CBufferString
    m_nLocalBoneArray = 0X000010 // CUtlVector< int16 >
    m_flBoneWeightArray = 0X000028 // CUtlVector< float32 >
    m_flDefaultMorphCtrlWeight = 0X000040 // float32
    m_morphCtrlWeightArray = 0X000048 // CUtlVector< CUtlPair< CBufferString, float32 > >

 CSeqScaleSet: [animationsystem.dll]
    m_sName = 0X000000 // CBufferString
    m_flRootOffsetScale = 0X000010 // float32
    m_nLocalBoneArray = 0X000018 // CUtlVector< int16 >
    m_flBoneScaleArray = 0X000030 // CUtlVector< float32 >

 CSeqMultiFetchFlag: [animationsystem.dll]
    m_bRealtime = 0X000000 // bool
    m_bCylepose = 0X000001 // bool
    m_b0D = 0X000002 // bool
    m_b1D = 0X000003 // bool
    m_b2D = 0X000004 // bool
    m_b2D_TRI = 0X000005 // bool

 CSeqMultiFetch: [animationsystem.dll]
    m_flags = 0X000000 // CSeqMultiFetchFlag
    m_localReferenceArray = 0X000008 // CUtlVector< int16 >
    m_nGroupSize = 0X000020 // int32[2]
    m_nLocalPose = 0X000028 // int32[2]
    m_poseKeyArray0 = 0X000030 // CUtlVector< float32 >
    m_poseKeyArray1 = 0X000048 // CUtlVector< float32 >
    m_nLocalCyclePoseParameter = 0X000060 // int32
    m_bCalculatePoseParameters = 0X000064 // bool

 CSeqSeqDescFlag: [animationsystem.dll]
    m_bLooping = 0X000000 // bool
    m_bSnap = 0X000001 // bool
    m_bAutoplay = 0X000002 // bool
    m_bPost = 0X000003 // bool
    m_bHidden = 0X000004 // bool
    m_bMulti = 0X000005 // bool
    m_bLegacyDelta = 0X000006 // bool
    m_bLegacyWorldspace = 0X000007 // bool
    m_bLegacyCyclepose = 0X000008 // bool
    m_bLegacyRealtime = 0X000009 // bool
    m_bModelDoc = 0X00000A // bool

 CSeqTransition: [animationsystem.dll]
    m_flFadeInTime = 0X000000 // float32
    m_flFadeOutTime = 0X000004 // float32

 CSeqS1SeqDesc: [animationsystem.dll]
    m_sName = 0X000000 // CBufferString
    m_flags = 0X000010 // CSeqSeqDescFlag
    m_fetch = 0X000020 // CSeqMultiFetch
    m_nLocalWeightlist = 0X000088 // int32
    m_autoLayerArray = 0X000090 // CUtlVector< CSeqAutoLayer >
    m_IKLockArray = 0X0000A8 // CUtlVector< CSeqIKLock >
    m_transition = 0X0000C0 // CSeqTransition
    m_SequenceKeys = 0X0000C8 // KeyValues3
    m_LegacyKeyValueText = 0X0000D8 // CBufferString
    m_activityArray = 0X0000E8 // CUtlVector< CAnimActivity >
    m_footMotion = 0X000100 // CUtlVector< CFootMotion >

 CSeqSynthAnimDesc: [animationsystem.dll]
    m_sName = 0X000000 // CBufferString
    m_flags = 0X000010 // CSeqSeqDescFlag
    m_transition = 0X00001C // CSeqTransition
    m_nLocalBaseReference = 0X000024 // int16
    m_nLocalBoneMask = 0X000026 // int16
    m_activityArray = 0X000028 // CUtlVector< CAnimActivity >

 CSeqCmdLayer: [animationsystem.dll]
    m_cmd = 0X000000 // int16
    m_nLocalReference = 0X000002 // int16
    m_nLocalBonemask = 0X000004 // int16
    m_nDstResult = 0X000006 // int16
    m_nSrcResult = 0X000008 // int16
    m_bSpline = 0X00000A // bool
    m_flVar1 = 0X00000C // float32
    m_flVar2 = 0X000010 // float32
    m_nLineNumber = 0X000014 // int16

 CSeqPoseSetting: [animationsystem.dll]
    m_sPoseParameter = 0X000000 // CBufferString
    m_sAttachment = 0X000010 // CBufferString
    m_sReferenceSequence = 0X000020 // CBufferString
    m_flValue = 0X000030 // float32
    m_bX = 0X000034 // bool
    m_bY = 0X000035 // bool
    m_bZ = 0X000036 // bool
    m_eType = 0X000038 // int32

 CSeqCmdSeqDesc: [animationsystem.dll]
    m_sName = 0X000000 // CBufferString
    m_flags = 0X000010 // CSeqSeqDescFlag
    m_transition = 0X00001C // CSeqTransition
    m_nFrameRangeSequence = 0X000024 // int16
    m_nFrameCount = 0X000026 // int16
    m_flFPS = 0X000028 // float32
    m_nSubCycles = 0X00002C // int16
    m_numLocalResults = 0X00002E // int16
    m_cmdLayerArray = 0X000030 // CUtlVector< CSeqCmdLayer >
    m_eventArray = 0X000048 // CUtlVector< CAnimAnimEvent >
    m_activityArray = 0X000060 // CUtlVector< CAnimActivity >
    m_poseSettingArray = 0X000078 // CUtlVector< CSeqPoseSetting >

 CSeqPoseParamDesc: [animationsystem.dll]
    m_sName = 0X000000 // CBufferString
    m_flStart = 0X000010 // float32
    m_flEnd = 0X000014 // float32
    m_flLoop = 0X000018 // float32
    m_bLooping = 0X00001C // bool

 CSequenceGroupData: [animationsystem.dll]
    m_sName = 0X000010 // CBufferString
    m_nFlags = 0X000020 // uint32
    m_localSequenceNameArray = 0X000028 // CUtlVector< CBufferString >
    m_localS1SeqDescArray = 0X000040 // CUtlVector< CSeqS1SeqDesc >
    m_localMultiSeqDescArray = 0X000058 // CUtlVector< CSeqS1SeqDesc >
    m_localSynthAnimDescArray = 0X000070 // CUtlVector< CSeqSynthAnimDesc >
    m_localCmdSeqDescArray = 0X000088 // CUtlVector< CSeqCmdSeqDesc >
    m_localBoneMaskArray = 0X0000A0 // CUtlVector< CSeqBoneMaskList >
    m_localScaleSetArray = 0X0000B8 // CUtlVector< CSeqScaleSet >
    m_localBoneNameArray = 0X0000D0 // CUtlVector< CBufferString >
    m_localNodeName = 0X0000E8 // CBufferString
    m_localPoseParamArray = 0X0000F8 // CUtlVector< CSeqPoseParamDesc >
    m_keyValues = 0X000110 // KeyValues3
    m_localIKAutoplayLockArray = 0X000120 // CUtlVector< CSeqIKLock >

 CCompressorGroup: [animationsystem.dll]
    m_nTotalElementCount = 0X000000 // int32
    m_szChannelClass = 0X000008 // CUtlVector< char* >
    m_szVariableName = 0X000020 // CUtlVector< char* >
    m_nType = 0X000038 // CUtlVector< fieldtype_t >
    m_nFlags = 0X000050 // CUtlVector< int32 >
    m_szGrouping = 0X000068 // CUtlVector< CUtlString >
    m_nCompressorIndex = 0X000080 // CUtlVector< int32 >
    m_szElementNames = 0X000098 // CUtlVector< CUtlVector< char* > >
    m_nElementUniqueID = 0X0000B0 // CUtlVector< CUtlVector< int32 > >
    m_nElementMask = 0X0000C8 // CUtlVector< uint32 >
    m_vectorCompressor = 0X0000F8 // CUtlVector< CCompressor< Vector >* >
    m_quaternionCompressor = 0X000110 // CUtlVector< CCompressor< QuaternionStorage >* >
    m_intCompressor = 0X000128 // CUtlVector< CCompressor< int32 >* >
    m_boolCompressor = 0X000140 // CUtlVector< CCompressor< bool >* >
    m_colorCompressor = 0X000158 // CUtlVector< CCompressor< Color >* >
    m_vector2DCompressor = 0X000170 // CUtlVector< CCompressor< Vector2D >* >
    m_vector4DCompressor = 0X000188 // CUtlVector< CCompressor< Vector4D >* >

 HSequence: [animationsystem.dll]
    m_Value = 0X000000 // int32

 CAnimationGraphVisualizerPrimitiveBase: [animationsystem.dll]
    m_Type = 0X000008 // CAnimationGraphVisualizerPrimitiveType
    m_OwningAnimNodePaths = 0X00000C // AnimNodeID[11]
    m_nOwningAnimNodePathCount = 0X000038 // int32

 CAnimationGraphVisualizerText: [animationsystem.dll]
    m_vWsPosition = 0X000040 // VectorAligned
    m_Color = 0X000050 // Color
    m_Text = 0X000058 // CUtlString

 CAnimationGraphVisualizerSphere: [animationsystem.dll]
    m_vWsPosition = 0X000040 // VectorAligned
    m_flRadius = 0X000050 // float32
    m_Color = 0X000054 // Color

 CAnimationGraphVisualizerLine: [animationsystem.dll]
    m_vWsPositionStart = 0X000040 // VectorAligned
    m_vWsPositionEnd = 0X000050 // VectorAligned
    m_Color = 0X000060 // Color

 CAnimationGraphVisualizerPie: [animationsystem.dll]
    m_vWsCenter = 0X000040 // VectorAligned
    m_vWsStart = 0X000050 // VectorAligned
    m_vWsEnd = 0X000060 // VectorAligned
    m_Color = 0X000070 // Color

 CAnimationGraphVisualizerAxis: [animationsystem.dll]
    m_xWsTransform = 0X000040 // CTransform
    m_flAxisSize = 0X000060 // float32

 AnimNodeID: [animationsystem.dll]
    m_id = 0X000000 // uint32

 AnimNodeOutputID: [animationsystem.dll]
    m_id = 0X000000 // uint32

 AnimStateID: [animationsystem.dll]
    m_id = 0X000000 // uint32

 AnimParamID: [animationsystem.dll]
    m_id = 0X000000 // uint32

 AnimTagID: [animationsystem.dll]
    m_id = 0X000000 // uint32

 AnimComponentID: [animationsystem.dll]
    m_id = 0X000000 // uint32

 AnimScriptHandle: [animationsystem.dll]
    m_id = 0X000000 // uint32

 CAnimEnum: [animationsystem.dll]
    m_value = 0X000000 // uint8

 CBlendCurve: [animationsystem.dll]
    m_flControlPoint1 = 0X000000 // float32
    m_flControlPoint2 = 0X000004 // float32

 CAnimNodePath: [animationsystem.dll]
    m_path = 0X000000 // AnimNodeID[11]
    m_nCount = 0X00002C // int32

 CPoseHandle: [animationsystem.dll]
    m_nIndex = 0X000000 // uint16
    m_eType = 0X000002 // PoseType_t

 CAnimNodeConnection: [animationsystem.dll]
    m_nodeID = 0X000000 // AnimNodeID
    m_outputID = 0X000004 // AnimNodeOutputID

 ConfigIndex: [animationsystem.dll]
    m_nGroup = 0X000000 // uint16
    m_nConfig = 0X000002 // uint16

 MotionIndex: [animationsystem.dll]
    m_nGroup = 0X000000 // uint16
    m_nMotion = 0X000002 // uint16

 CMotionGraphConfig: [animationsystem.dll]
    m_paramValues = 0X000000 // float32[4]
    m_flDuration = 0X000010 // float32
    m_nMotionIndex = 0X000014 // MotionIndex
    m_nSampleStart = 0X000018 // int32
    m_nSampleCount = 0X00001C // int32

 IKBoneNameAndIndex_t: [animationsystem.dll]
    m_Name = 0X000000 // CUtlString

 IKSolverSettings_t: [animationsystem.dll]
    m_SolverType = 0X000000 // IKSolverType
    m_nNumIterations = 0X000004 // int32

 IKTargetSettings_t: [animationsystem.dll]
    m_TargetSource = 0X000000 // IKTargetSource
    m_Bone = 0X000008 // IKBoneNameAndIndex_t
    m_AnimgraphParameterNamePosition = 0X000018 // AnimParamID
    m_TargetCoordSystem = 0X00001C // IKTargetCoordinateSystem

 CAnimationSubGraph: [animationsystem.dll]
    m_nodeManager = 0X000008 // CAnimNodeManager
    m_componentManager = 0X000050 // CAnimComponentManager
    m_localParameters = 0X000078 // CUtlVector< CSmartPtr< CAnimParameterBase > >
    m_localTags = 0X000090 // CUtlVector< CSmartPtr< CAnimTagBase > >
    m_referencedParamGroups = 0X0000A8 // CUtlVector< CUtlString >
    m_referencedTagGroups = 0X0000C0 // CUtlVector< CUtlString >

 CAnimGraphModelBinding: [animationsystem.dll]
    m_modelName = 0X000008 // CUtlString
    m_pSharedData = 0X000010 // CSmartPtr< CAnimUpdateSharedData >

 CAnimClipDataManager: [animationsystem.dll]
    m_itemTable = 0X000018 // CUtlHashtable< CUtlString, CSmartPtr< CAnimClipData > >

 CAnimClipData: [animationsystem.dll]
    m_tagSpans = 0X000020 // CUtlVector< CSmartPtr< CAnimTagSpan > >
    m_clipName = 0X000038 // CUtlString

 CAnimParameterList: [animationsystem.dll]
    m_Parameters = 0X000020 // CUtlVector< CSmartPtr< CAnimParameterBase > >

 CAnimNodeList: [animationsystem.dll]
    m_nodes = 0X000010 // CUtlVector< CAnimNodeBase* >

 CAnimNodeManager: [animationsystem.dll]
    m_nodes = 0X000008 // CUtlHashtable< AnimNodeID, CSmartPtr< CAnimNodeBase > >

 CAnimStateList: [animationsystem.dll]
    m_states = 0X000010 // CUtlVector< CAnimState* >

 CAnimInputDamping: [animationsystem.dll]
    m_speedFunction = 0X000008 // DampingSpeedFunction
    m_fSpeedScale = 0X00000C // float32

 CAnimUpdateSharedData: [animationsystem.dll]
    m_nodes = 0X000010 // CUtlVector< CSmartPtr< CAnimUpdateNodeBase > >
    m_nodeIndexMap = 0X000028 // CUtlHashtable< CAnimNodePath, int32 >
    m_components = 0X000048 // CUtlVector< CSmartPtr< CAnimComponentUpdater > >
    m_pParamListUpdater = 0X000060 // CSmartPtr< CAnimParameterListUpdater >
    m_pTagManagerUpdater = 0X000068 // CSmartPtr< CAnimTagManagerUpdater >
    m_scriptManager = 0X000070 // CSmartPtr< CAnimScriptManager >
    m_settings = 0X000078 // CAnimGraphSettingsManager
    m_pStaticPoseCache = 0X0000A8 // CSmartPtr< CStaticPoseCacheBuilder >
    m_pSkeleton = 0X0000B0 // CSmartPtr< CAnimSkeleton >
    m_rootNodePath = 0X0000B8 // CAnimNodePath

 CFloatAnimValue: [animationsystem.dll]
    m_flConstValue = 0X000008 // float32
    m_paramID = 0X00000C // AnimParamID
    m_eSource = 0X000010 // EAnimValueSource

 CCachedPose: [animationsystem.dll]
    m_transforms = 0X000008 // CUtlVector< CTransform >
    m_morphWeights = 0X000020 // CUtlVector< float32 >
    m_hSequence = 0X000038 // HSequence
    m_flCycle = 0X00003C // float32

 CStaticPoseCache: [animationsystem.dll]
    m_poses = 0X000010 // CUtlVector< CCachedPose >
    m_nBoneCount = 0X000028 // int32
    m_nMorphCount = 0X00002C // int32

 CStaticPoseCacheBuilder: [animationsystem.dll]
    No schemes available

 CAnimGraphSettingsManager: [animationsystem.dll]
    m_settingsGroups = 0X000018 // CUtlVector< CSmartPtr< CAnimGraphSettingsGroup > >

 CAnimParamSpanSample: [animationsystem.dll]
    m_value = 0X000008 // CAnimVariant
    m_flCycle = 0X00001C // float32

 CAnimParamSpan: [animationsystem.dll]
    m_samples = 0X000020 // CUtlVector< CAnimParamSpanSample >
    m_id = 0X000038 // AnimParamID
    m_flStartCycle = 0X00003C // float32
    m_flEndCycle = 0X000040 // float32

 ParamSpanSample_t: [animationsystem.dll]
    m_value = 0X000000 // CAnimVariant
    m_flCycle = 0X000014 // float32

 ParamSpan_t: [animationsystem.dll]
    m_samples = 0X000000 // CUtlVector< ParamSpanSample_t >
    m_hParam = 0X000018 // CAnimParamHandle
    m_eParamType = 0X00001A // AnimParamType_t
    m_flStartCycle = 0X00001C // float32
    m_flEndCycle = 0X000020 // float32

 CParamSpanUpdater: [animationsystem.dll]
    m_spans = 0X000000 // CUtlVector< ParamSpan_t >

 CAnimGraphSettingsGroup: [animationsystem.dll]
    No schemes available

 CAnimGraphNetworkSettings: [animationsystem.dll]
    m_bNetworkingEnabled = 0X000020 // bool

 CAnimComponentBase: [animationsystem.dll]
    m_group = 0X000018 // CUtlString
    m_id = 0X000028 // AnimComponentID
    m_bStartEnabled = 0X00002C // bool
    m_nPriority = 0X000030 // int32
    m_networkMode = 0X000034 // AnimNodeNetworkMode

 CAnimComponentManager: [animationsystem.dll]
    m_components = 0X000008 // CUtlVector< CSmartPtr< CAnimComponentBase > >

 CAnimScriptComponent: [animationsystem.dll]
    m_sName = 0X000040 // CUtlString
    m_scriptFilename = 0X000048 // CUtlString

 CActionComponent: [animationsystem.dll]
    m_actions = 0X000038 // CUtlVector< CSmartPtr< CAnimActionBase > >
    m_sName = 0X000050 // CUtlString

 CCPPScriptComponent: [animationsystem.dll]
    m_scriptsToRun = 0X000040 // CUtlVector< CUtlString >

 CDampedValueItem: [animationsystem.dll]
    m_valueType = 0X000000 // DampedValueType
    m_floatParamIn = 0X000004 // AnimParamID
    m_floatParamOut = 0X000008 // AnimParamID
    m_vectorParamIn = 0X00000C // AnimParamID
    m_vectorParamOut = 0X000010 // AnimParamID
    m_damping = 0X000018 // CAnimInputDamping

 CDampedValueComponent: [animationsystem.dll]
    m_name = 0X000038 // CUtlString
    m_items = 0X000040 // CUtlVector< CDampedValueItem >

 CDampedValueUpdateItem: [animationsystem.dll]
    m_damping = 0X000000 // CAnimInputDamping
    m_hParamIn = 0X000018 // CAnimParamHandle
    m_hParamOut = 0X00001A // CAnimParamHandle

 CMovementComponent: [animationsystem.dll]
    m_moveModes = 0X000040 // CUtlVector< CMovementMode >
    m_motors = 0X000058 // CUtlVector< CSmartPtr< CAnimMotorBase > >
    m_bNetworkPath = 0X000070 // bool
    m_eDefaultFacingMode = 0X000074 // FacingMode
    m_facingDamping = 0X000078 // CAnimInputDamping
    m_bNetworkFacing = 0X000088 // bool
    m_paramIDs = 0X00008C // AnimParamID[30]

 CLODComponent: [animationsystem.dll]
    m_nServerLOD = 0X000038 // int32

 CLookComponent: [animationsystem.dll]
    m_bNetworkLookTarget = 0X000040 // bool
    m_lookHeadingID = 0X000044 // AnimParamID
    m_lookHeadingVelocityID = 0X000048 // AnimParamID
    m_lookPitchID = 0X00004C // AnimParamID
    m_lookDistanceID = 0X000050 // AnimParamID
    m_lookDirectionID = 0X000054 // AnimParamID
    m_lookTargetID = 0X000058 // AnimParamID
    m_lookTargetWorldSpaceID = 0X00005C // AnimParamID

 CRigidBodyWeight: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_flWeight = 0X000008 // float32

 CRigidBodyWeightList: [animationsystem.dll]
    m_name = 0X000008 // CUtlString
    m_weights = 0X000010 // CUtlVector< CRigidBodyWeight >

 CRagdollComponent: [animationsystem.dll]
    m_weightLists = 0X000038 // CUtlVector< CRigidBodyWeightList >
    m_flSpringFrequencyMin = 0X000050 // float32
    m_flSpringFrequencyMax = 0X000054 // float32

 WeightList: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_weights = 0X000008 // CUtlVector< float32 >

 CSlopeComponent: [animationsystem.dll]
    m_flTraceDistance = 0X000040 // float32
    m_slopeAngleID = 0X000044 // AnimParamID
    m_slopeHeadingID = 0X000048 // AnimParamID
    m_slopeAngleSideID = 0X00004C // AnimParamID
    m_slopeAngleFrontID = 0X000050 // AnimParamID
    m_slopeNormalID = 0X000054 // AnimParamID
    m_slopeNormal_WorldSpaceID = 0X000058 // AnimParamID

 CVRInputComponent: [animationsystem.dll]
    m_FingerCurl_Thumb = 0X000038 // AnimParamID
    m_FingerCurl_Index = 0X00003C // AnimParamID
    m_FingerCurl_Middle = 0X000040 // AnimParamID
    m_FingerCurl_Ring = 0X000044 // AnimParamID
    m_FingerCurl_Pinky = 0X000048 // AnimParamID
    m_FingerSplay_Thumb_Index = 0X00004C // AnimParamID
    m_FingerSplay_Index_Middle = 0X000050 // AnimParamID
    m_FingerSplay_Middle_Ring = 0X000054 // AnimParamID
    m_FingerSplay_Ring_Pinky = 0X000058 // AnimParamID

 CAnimActionBase: [animationsystem.dll]
    No schemes available

 CEmitTagAction: [animationsystem.dll]
    m_tag = 0X000028 // AnimTagID

 CSetParameterAction: [animationsystem.dll]
    m_param = 0X000028 // AnimParamID
    m_value = 0X00002C // CAnimVariant

 CToggleComponentAction: [animationsystem.dll]
    m_componentID = 0X000028 // AnimComponentID
    m_bSetEnabled = 0X00002C // bool

 CExpressionAction: [animationsystem.dll]
    m_param = 0X000028 // AnimParamID
    m_expression = 0X000030 // CUtlString

 CAnimMotorBase: [animationsystem.dll]
    m_name = 0X000018 // CUtlString
    m_bDefault = 0X000020 // bool

 CPathAnimMotorBase: [animationsystem.dll]
    m_bLockToPath = 0X000028 // bool

 CPathAnimMotor: [animationsystem.dll]
    No schemes available

 CDampedPathAnimMotor: [animationsystem.dll]
    m_flAnticipationTime = 0X000030 // float32
    m_flMinSpeedScale = 0X000034 // float32
    m_anticipationPosParam = 0X000038 // AnimParamID
    m_anticipationHeadingParam = 0X00003C // AnimParamID
    m_flSpringConstant = 0X000040 // float32
    m_flMinSpringTension = 0X000044 // float32
    m_flMaxSpringTension = 0X000048 // float32

 CPlayerInputAnimMotor: [animationsystem.dll]
    m_sampleTimes = 0X000028 // CUtlVector< float32 >
    m_bUseAcceleration = 0X000040 // bool
    m_flSpringConstant = 0X000044 // float32
    m_flAnticipationDistance = 0X000048 // float32
    m_anticipationPosParam = 0X00004C // AnimParamID
    m_anticipationHeadingParam = 0X000050 // AnimParamID

 CAnimParameterBase: [animationsystem.dll]
    m_name = 0X000018 // CAnimGraphSymbolWithStorage
    m_group = 0X000038 // CUtlString
    m_id = 0X000040 // AnimParamID
    m_componentName = 0X000058 // CUtlString
    m_previewButton = 0X000064 // AnimParamButton_t
    m_bUseMostRecentValue = 0X000068 // bool
    m_bAutoReset = 0X000069 // bool
    m_eNetworkSetting = 0X00006C // AnimParamNetworkSetting
    m_bGameWritable = 0X000070 // bool
    m_bGraphWritable = 0X000071 // bool
    m_bIsReferenced = 0X000072 // bool
    m_bNetworkingRequested = 0X000073 // bool

 CBoolAnimParameter: [animationsystem.dll]
    m_bDefaultValue = 0X000078 // bool

 CEnumAnimParameter: [animationsystem.dll]
    m_defaultValue = 0X000080 // uint8
    m_enumOptions = 0X000088 // CUtlVector< CUtlString >

 CIntAnimParameter: [animationsystem.dll]
    m_defaultValue = 0X000078 // int32
    m_minValue = 0X00007C // int32
    m_maxValue = 0X000080 // int32

 CFloatAnimParameter: [animationsystem.dll]
    m_fDefaultValue = 0X000078 // float32
    m_fMinValue = 0X00007C // float32
    m_fMaxValue = 0X000080 // float32
    m_bInterpolate = 0X000084 // bool

 CVectorAnimParameter: [animationsystem.dll]
    m_defaultValue = 0X000078 // Vector
    m_bInterpolate = 0X000084 // bool

 CQuaternionAnimParameter: [animationsystem.dll]
    m_defaultValue = 0X000080 // Quaternion
    m_bInterpolate = 0X000090 // bool

 CAnimNodeBase: [animationsystem.dll]
    m_sName = 0X000020 // CUtlString
    m_vecPosition = 0X000028 // Vector2D
    m_nNodeID = 0X000030 // AnimNodeID
    m_networkMode = 0X000034 // AnimNodeNetworkMode

 CSequenceAnimNode: [animationsystem.dll]
    m_tagSpans = 0X000068 // CUtlVector< CSmartPtr< CAnimTagSpan > >
    m_paramSpans = 0X000080 // CUtlVector< CSmartPtr< CAnimParamSpan > >
    m_sequenceName = 0X000098 // CUtlString
    m_playbackSpeed = 0X0000A0 // float32
    m_bLoop = 0X0000A4 // bool

 CBlendNodeChild: [animationsystem.dll]
    m_inputConnection = 0X000008 // CAnimNodeConnection
    m_name = 0X000010 // CUtlString
    m_blendValue = 0X000018 // float32

 CBlendAnimNode: [animationsystem.dll]
    m_children = 0X000048 // CUtlVector< CBlendNodeChild >
    m_blendValueSource = 0X000060 // AnimValueSource
    m_param = 0X000064 // AnimParamID
    m_blendKeyType = 0X000068 // BlendKeyType
    m_bLockBlendOnReset = 0X00006C // bool
    m_bSyncCycles = 0X00006D // bool
    m_bLoop = 0X00006E // bool
    m_bLockWhenWaning = 0X00006F // bool
    m_damping = 0X000070 // CAnimInputDamping

 CRagdollAnimNode: [animationsystem.dll]
    m_weightListName = 0X000038 // CUtlString
    m_poseControlMethod = 0X000040 // RagdollPoseControl
    m_inputConnection = 0X000044 // CAnimNodeConnection

 CRootAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000050 // CAnimNodeConnection

 CChoiceNodeChild: [animationsystem.dll]
    m_inputConnection = 0X000000 // CAnimNodeConnection
    m_name = 0X000008 // CUtlString
    m_weight = 0X000010 // float32
    m_blendTime = 0X000014 // float32

 CChoiceAnimNode: [animationsystem.dll]
    m_children = 0X000038 // CUtlVector< CChoiceNodeChild >
    m_seed = 0X000050 // int32
    m_choiceMethod = 0X000054 // ChoiceMethod
    m_choiceChangeMethod = 0X000058 // ChoiceChangeMethod
    m_blendMethod = 0X00005C // ChoiceBlendMethod
    m_blendTime = 0X000060 // float32
    m_bCrossFade = 0X000064 // bool
    m_bResetChosen = 0X000065 // bool
    m_bDontResetSameSelection = 0X000066 // bool

 CCycleControlAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_valueSource = 0X000040 // AnimValueSource
    m_param = 0X000044 // AnimParamID

 CCycleControlClipAnimNode: [animationsystem.dll]
    m_tagSpans = 0X000050 // CUtlVector< CSmartPtr< CAnimTagSpan > >
    m_sequenceName = 0X000068 // CUtlString
    m_valueSource = 0X000070 // AnimValueSource
    m_param = 0X000074 // AnimParamID

 CAddAnimNode: [animationsystem.dll]
    m_baseInput = 0X000038 // CAnimNodeConnection
    m_additiveInput = 0X000040 // CAnimNodeConnection
    m_timingBehavior = 0X000048 // BinaryNodeTiming
    m_flTimingBlend = 0X00004C // float32
    m_footMotionTiming = 0X000050 // BinaryNodeChildOption
    m_bApplyToFootMotion = 0X000054 // bool
    m_bResetBase = 0X000055 // bool
    m_bResetAdditive = 0X000056 // bool
    m_bApplyChannelsSeparately = 0X000057 // bool
    m_bUseModelSpace = 0X000058 // bool

 CSubtractAnimNode: [animationsystem.dll]
    m_baseInputConnection = 0X000038 // CAnimNodeConnection
    m_subtractInputConnection = 0X000040 // CAnimNodeConnection
    m_timingBehavior = 0X000048 // BinaryNodeTiming
    m_flTimingBlend = 0X00004C // float32
    m_footMotionTiming = 0X000050 // BinaryNodeChildOption
    m_bApplyToFootMotion = 0X000054 // bool
    m_bResetBase = 0X000055 // bool
    m_bResetSubtract = 0X000056 // bool
    m_bApplyChannelsSeparately = 0X000057 // bool
    m_bUseModelSpace = 0X000058 // bool

 CMoverAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_bApplyMovement = 0X000040 // bool
    m_moveVectorParam = 0X000044 // AnimParamID
    m_bOrientMovement = 0X000048 // bool
    m_moveHeadingParam = 0X00004C // AnimParamID
    m_bAdditive = 0X000050 // bool
    m_bTurnToFace = 0X000051 // bool
    m_facingTarget = 0X000054 // AnimValueSource
    m_param = 0X000058 // AnimParamID
    m_bLimitOnly = 0X00005C // bool
    m_flTurnToFaceOffset = 0X000060 // float32
    m_flTurnToFaceLimit = 0X000064 // float32
    m_damping = 0X000068 // CAnimInputDamping

 CSlowDownOnSlopesAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_flSlowDownStrength = 0X000040 // float32

 CTurnHelperAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_facingTarget = 0X000040 // AnimValueSource
    m_turnStartTime = 0X000044 // float32
    m_turnDuration = 0X000048 // float32
    m_bMatchChildDuration = 0X00004C // bool
    m_bUseManualTurnOffset = 0X00004D // bool
    m_manualTurnOffset = 0X000050 // float32

 CAimMatrixAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000040 // CAnimNodeConnection
    m_sequenceName = 0X000048 // CUtlString
    m_fAngleIncrement = 0X000050 // float32
    m_target = 0X000054 // AnimVectorSource
    m_param = 0X000058 // AnimParamID
    m_attachmentName = 0X000060 // CUtlString
    m_blendMode = 0X000068 // AimMatrixBlendMode
    m_boneMaskName = 0X000070 // CUtlString
    m_bResetBase = 0X000078 // bool
    m_bLockWhenWaning = 0X000079 // bool
    m_damping = 0X000080 // CAnimInputDamping

 CSpeedScaleAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_param = 0X000040 // AnimParamID

 CDirectionalBlendAnimNode: [animationsystem.dll]
    m_animNamePrefix = 0X000040 // CUtlString
    m_blendValueSource = 0X000048 // AnimValueSource
    m_param = 0X00004C // AnimParamID
    m_bLoop = 0X000050 // bool
    m_bLockBlendOnReset = 0X000051 // bool
    m_playbackSpeed = 0X000054 // float32
    m_damping = 0X000058 // CAnimInputDamping

 CWayPointHelperAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_flStartCycle = 0X000040 // float32
    m_flEndCycle = 0X000044 // float32
    m_bOnlyGoals = 0X000048 // bool
    m_bPreventOvershoot = 0X000049 // bool
    m_bPreventUndershoot = 0X00004A // bool

 CBoneMaskAnimNode: [animationsystem.dll]
    m_weightListName = 0X000038 // CUtlString
    m_inputConnection1 = 0X000040 // CAnimNodeConnection
    m_inputConnection2 = 0X000048 // CAnimNodeConnection
    m_blendSpace = 0X000050 // BoneMaskBlendSpace
    m_bUseBlendScale = 0X000054 // bool
    m_blendValueSource = 0X000058 // AnimValueSource
    m_blendParameter = 0X00005C // AnimParamID
    m_timingBehavior = 0X000060 // BinaryNodeTiming
    m_flTimingBlend = 0X000064 // float32
    m_flRootMotionBlend = 0X000068 // float32
    m_footMotionTiming = 0X00006C // BinaryNodeChildOption
    m_bResetChild1 = 0X000070 // bool
    m_bResetChild2 = 0X000071 // bool

 CChoreoAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection

 CDirectPlaybackAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_bFinishEarly = 0X000040 // bool
    m_bResetOnFinish = 0X000041 // bool

 CLeanMatrixAnimNode: [animationsystem.dll]
    m_sequenceName = 0X000040 // CUtlString
    m_flMaxValue = 0X000048 // float32
    m_blendSource = 0X00004C // AnimVectorSource
    m_param = 0X000050 // AnimParamID
    m_verticalAxisDirection = 0X000054 // Vector
    m_horizontalAxisDirection = 0X000060 // Vector
    m_damping = 0X000070 // CAnimInputDamping

 CTwoBoneIKAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_ikChainName = 0X000040 // CUtlString
    m_bAutoDetectHingeAxis = 0X000048 // bool
    m_endEffectorType = 0X00004C // IkEndEffectorType
    m_endEffectorAttachmentName = 0X000050 // CUtlString
    m_targetType = 0X000058 // IkTargetType
    m_attachmentName = 0X000060 // CUtlString
    m_targetBoneName = 0X000068 // CUtlString
    m_targetParam = 0X000070 // AnimParamID
    m_bMatchTargetOrientation = 0X000074 // bool
    m_rotationParam = 0X000078 // AnimParamID
    m_bConstrainTwist = 0X00007C // bool
    m_flMaxTwist = 0X000080 // float32

 CSolveIKChainAnimNodeChainData: [animationsystem.dll]
    m_IkChain = 0X000008 // CUtlString
    m_SolverSettingSource = 0X000010 // SolveIKChainAnimNodeSettingSource
    m_OverrideSolverSettings = 0X000014 // IKSolverSettings_t
    m_TargetSettingSource = 0X00001C // SolveIKChainAnimNodeSettingSource
    m_OverrideTargetSettings = 0X000020 // IKTargetSettings_t
    m_DebugSetting = 0X000040 // SolveIKChainAnimNodeDebugSetting
    m_flDebugNormalizedLength = 0X000044 // float32
    m_vDebugOffset = 0X000048 // Vector

 CSolveIKChainAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000040 // CAnimNodeConnection
    m_IkChains = 0X000048 // CUtlVector< CSolveIKChainAnimNodeChainData >

 CLookAtAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_target = 0X000040 // AnimVectorSource
    m_param = 0X000044 // AnimParamID
    m_bIsPosition = 0X000048 // bool
    m_weightParam = 0X00004C // AnimParamID
    m_lookatChainName = 0X000050 // CUtlString
    m_attachmentName = 0X000058 // CUtlString
    m_bRotateYawForward = 0X000060 // bool
    m_flYawLimit = 0X000064 // float32
    m_flPitchLimit = 0X000068 // float32
    m_bMaintainUpDirection = 0X00006C // bool
    m_bResetBase = 0X00006D // bool
    m_bLockWhenWaning = 0X00006E // bool
    m_bUseHysteresis = 0X00006F // bool
    m_flHysteresisInnerAngle = 0X000070 // float32
    m_flHysteresisOuterAngle = 0X000074 // float32
    m_damping = 0X000078 // CAnimInputDamping

 CPathHelperAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_flStoppingRadius = 0X000040 // float32
    m_flStoppingSpeedScale = 0X000044 // float32

 CConnectionProxyItem: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_outputID = 0X000008 // AnimNodeOutputID
    m_inputConnection = 0X00000C // CAnimNodeConnection

 CProxyAnimNodeBase: [animationsystem.dll]
    m_proxyItems = 0X000040 // CUtlVector< CConnectionProxyItem >

 CFollowAttachmentAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_boneName = 0X000040 // CUtlString
    m_attachmentName = 0X000048 // CUtlString
    m_bMatchTranslation = 0X000050 // bool
    m_bMatchRotation = 0X000051 // bool

 CSkeletalInputAnimNode: [animationsystem.dll]
    m_transformSource = 0X000038 // AnimVrBoneTransformSource_t
    m_motionRange = 0X00003C // AnimVRHandMotionRange_t
    m_bEnableIK = 0X000040 // bool
    m_bEnableCollision = 0X000041 // bool

 CStanceOverrideAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_stanceSourceConnection = 0X000040 // CAnimNodeConnection
    m_blendParamID = 0X000048 // AnimParamID
    m_eMode = 0X00004C // StanceOverrideMode
    m_sequenceName = 0X000050 // CUtlString
    m_nFrameIndex = 0X000058 // int32

 CStanceScaleAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_param = 0X000040 // AnimParamID

 CSelectorAnimNode: [animationsystem.dll]
    m_children = 0X000040 // CUtlVector< CAnimNodeConnection >
    m_tags = 0X000058 // CUtlVector< AnimTagID >
    m_selectionSource = 0X000070 // SelectionSource_t
    m_boolParamID = 0X000074 // AnimParamID
    m_enumParamID = 0X000078 // AnimParamID
    m_blendDuration = 0X000080 // CFloatAnimValue
    m_tagBehavior = 0X000098 // SelectorTagBehavior_t
    m_bResetOnChange = 0X00009C // bool
    m_bSyncCyclesOnChange = 0X00009D // bool
    m_blendCurve = 0X0000A0 // CBlendCurve

 CHitReactAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_flMinDelayBetweenHits = 0X000040 // float32
    m_triggerParam = 0X000044 // AnimParamID
    m_hitBoneParam = 0X000048 // AnimParamID
    m_hitOffsetParam = 0X00004C // AnimParamID
    m_hitDirectionParam = 0X000050 // AnimParamID
    m_hitStrengthParam = 0X000054 // AnimParamID
    m_weightListName = 0X000058 // CUtlString
    m_hipBoneName = 0X000060 // CUtlString
    m_flHipBoneTranslationScale = 0X000068 // float32
    m_nEffectedBoneCount = 0X00006C // int32
    m_flMaxImpactForce = 0X000070 // float32
    m_flMinImpactForce = 0X000074 // float32
    m_flWhipImpactScale = 0X000078 // float32
    m_flCounterRotationScale = 0X00007C // float32
    m_flDistanceFadeScale = 0X000080 // float32
    m_flPropagationScale = 0X000084 // float32
    m_flWhipDelay = 0X000088 // float32
    m_flSpringStrength = 0X00008C // float32
    m_flWhipSpringStrength = 0X000090 // float32
    m_flHipDipSpringStrength = 0X000094 // float32
    m_flHipDipImpactScale = 0X000098 // float32
    m_flHipDipDelay = 0X00009C // float32
    m_bResetBase = 0X0000A0 // bool

 CBlend2DItemBase: [animationsystem.dll]
    m_blendValue = 0X000018 // Vector2D
    m_bUseCustomDuration = 0X000028 // bool
    m_flCustomDuration = 0X00002C // float32

 CSequenceBlend2DItem: [animationsystem.dll]
    m_tagSpans = 0X000038 // CUtlVector< CSmartPtr< CAnimTagSpan > >
    m_sequenceName = 0X000050 // CUtlString

 CNodeBlend2DItem: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_name = 0X000040 // CUtlString

 CBlend2DAnimNode: [animationsystem.dll]
    m_items = 0X000050 // CUtlVector< CSmartPtr< CBlend2DItemBase > >
    m_tagSpans = 0X000068 // CUtlVector< CSmartPtr< CAnimTagSpan > >
    m_paramSpans = 0X000080 // CUtlVector< CSmartPtr< CAnimParamSpan > >
    m_blendSourceX = 0X000098 // AnimValueSource
    m_paramX = 0X00009C // AnimParamID
    m_blendSourceY = 0X0000A0 // AnimValueSource
    m_paramY = 0X0000A4 // AnimParamID
    m_bLoop = 0X0000A8 // bool
    m_bLockBlendOnReset = 0X0000A9 // bool
    m_bLockWhenWaning = 0X0000AA // bool
    m_playbackSpeed = 0X0000AC // float32
    m_damping = 0X0000B0 // CAnimInputDamping
    m_bAnimEventsAndTagsOnMostWeightedOnly = 0X0000C0 // bool

 CFootAdjustmentAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_facingTarget = 0X000040 // AnimParamID
    m_bResetChild = 0X000044 // bool
    m_bAnimationDriven = 0X000045 // bool
    m_baseClipName = 0X000048 // CUtlString
    m_clips = 0X000050 // CUtlVector< CUtlString >
    m_flTurnTimeMin = 0X000068 // float32
    m_flTurnTimeMax = 0X00006C // float32
    m_flStepHeightMax = 0X000070 // float32
    m_flStepHeightMaxAngle = 0X000074 // float32

 CFootLockItem: [animationsystem.dll]
    m_footName = 0X000000 // CUtlString
    m_targetBoneName = 0X000008 // CUtlString
    m_ikChainName = 0X000010 // CUtlString
    m_disableTagID = 0X000018 // AnimTagID
    m_flMaxRotationLeft = 0X00001C // float32
    m_flMaxRotationRight = 0X000020 // float32
    m_footstepLandedTag = 0X000024 // AnimTagID

 CFootLockAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_items = 0X000040 // CUtlVector< CFootLockItem >
    m_hipBoneName = 0X000058 // CUtlString
    m_flBlendTime = 0X000060 // float32
    m_bApplyFootRotationLimits = 0X000064 // bool
    m_bResetChild = 0X000065 // bool
    m_ikSolverType = 0X000068 // IKSolverType
    m_bAlwaysUseFallbackHinge = 0X00006C // bool
    m_bApplyLegTwistLimits = 0X00006D // bool
    m_flMaxLegTwist = 0X000070 // float32
    m_flStrideCurveScale = 0X000074 // float32
    m_flStrideCurveLimitScale = 0X000078 // float32
    m_bEnableVerticalCurvedPaths = 0X00007C // bool
    m_bModulateStepHeight = 0X00007D // bool
    m_flStepHeightIncreaseScale = 0X000080 // float32
    m_flStepHeightDecreaseScale = 0X000084 // float32
    m_bEnableHipShift = 0X000088 // bool
    m_flHipShiftScale = 0X00008C // float32
    m_hipShiftDamping = 0X000090 // CAnimInputDamping
    m_bApplyTilt = 0X0000A0 // bool
    m_flTiltPlanePitchSpringStrength = 0X0000A4 // float32
    m_flTiltPlaneRollSpringStrength = 0X0000A8 // float32
    m_bEnableLockBreaking = 0X0000AC // bool
    m_flLockBreakTolerance = 0X0000B0 // float32
    m_flLockBreakBlendTime = 0X0000B4 // float32
    m_bEnableStretching = 0X0000B8 // bool
    m_flMaxStretchAmount = 0X0000BC // float32
    m_flStretchExtensionScale = 0X0000C0 // float32
    m_bEnableGroundTracing = 0X0000C4 // bool
    m_flTraceAngleBlend = 0X0000C8 // float32
    m_bApplyHipDrop = 0X0000CC // bool
    m_flMaxFootHeight = 0X0000D0 // float32
    m_flExtensionScale = 0X0000D4 // float32
    m_hipDampingSettings = 0X0000D8 // CAnimInputDamping
    m_bEnableRootHeightDamping = 0X0000E8 // bool
    m_rootHeightDamping = 0X0000F0 // CAnimInputDamping
    m_flMaxRootHeightOffset = 0X000100 // float32
    m_flMinRootHeightOffset = 0X000104 // float32

 FootFixedData_t: [animationsystem.dll]
    m_vToeOffset = 0X000000 // VectorAligned
    m_vHeelOffset = 0X000010 // VectorAligned
    m_nTargetBoneIndex = 0X000020 // int32
    m_nAnkleBoneIndex = 0X000024 // int32
    m_nIKAnchorBoneIndex = 0X000028 // int32
    m_ikChainIndex = 0X00002C // int32
    m_flMaxIKLength = 0X000030 // float32
    m_nFootIndex = 0X000034 // int32
    m_nTagIndex = 0X000038 // int32
    m_flMaxRotationLeft = 0X00003C // float32
    m_flMaxRotationRight = 0X000040 // float32

 CFootPinningItem: [animationsystem.dll]
    m_footName = 0X000000 // CUtlString
    m_targetBoneName = 0X000008 // CUtlString
    m_ikChainName = 0X000010 // CUtlString
    m_tag = 0X000018 // AnimTagID
    m_param = 0X00001C // AnimParamID
    m_flMaxRotationLeft = 0X000020 // float32
    m_flMaxRotationRight = 0X000024 // float32

 CFootPinningAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_items = 0X000040 // CUtlVector< CFootPinningItem >
    m_eTimingSource = 0X000058 // FootPinningTimingSource
    m_flBlendTime = 0X00005C // float32
    m_flLockBreakDistance = 0X000060 // float32
    m_flMaxLegStraightAmount = 0X000064 // float32
    m_bApplyFootRotationLimits = 0X000068 // bool
    m_hipBoneName = 0X000070 // CUtlString
    m_bApplyLegTwistLimits = 0X000078 // bool
    m_flMaxLegTwist = 0X00007C // float32
    m_bResetChild = 0X000080 // bool

 CFollowPathAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_flBlendOutTime = 0X000040 // float32
    m_bBlockNonPathMovement = 0X000044 // bool
    m_bStopFeetAtGoal = 0X000045 // bool
    m_bScaleSpeed = 0X000046 // bool
    m_flScale = 0X000048 // float32
    m_flMinAngle = 0X00004C // float32
    m_flMaxAngle = 0X000050 // float32
    m_flSpeedScaleBlending = 0X000054 // float32
    m_bTurnToFace = 0X000058 // bool
    m_facingTarget = 0X00005C // AnimValueSource
    m_param = 0X000060 // AnimParamID
    m_flTurnToFaceOffset = 0X000064 // float32
    m_damping = 0X000068 // CAnimInputDamping

 CMotionMatchingAnimNode: [animationsystem.dll]
    m_groups = 0X000048 // CUtlVector< CSmartPtr< CMotionItemGroup > >
    m_metrics = 0X000060 // CUtlVector< CSmartPtr< CMotionMetricBase > >
    m_blendCurve = 0X000078 // CBlendCurve
    m_nRandomSeed = 0X000080 // int32
    m_flSampleRate = 0X000084 // float32
    m_bSearchEveryTick = 0X000088 // bool
    m_flSearchInterval = 0X00008C // float32
    m_bSearchWhenMotionEnds = 0X000090 // bool
    m_bSearchWhenGoalChanges = 0X000091 // bool
    m_flBlendTime = 0X000094 // float32
    m_flSelectionThreshold = 0X000098 // float32
    m_flReselectionTimeWindow = 0X00009C // float32
    m_bLockSelectionWhenWaning = 0X0000A0 // bool
    m_bEnableRotationCorrection = 0X0000A1 // bool
    m_bGoalAssist = 0X0000A2 // bool
    m_flGoalAssistDistance = 0X0000A4 // float32
    m_flGoalAssistTolerance = 0X0000A8 // float32
    m_bEnableDistanceScaling = 0X0000AC // bool
    m_flDistanceScale_OuterRadius = 0X0000B0 // float32
    m_flDistanceScale_InnerRadius = 0X0000B4 // float32
    m_flDistanceScale_MaxScale = 0X0000B8 // float32
    m_flDistanceScale_MinScale = 0X0000BC // float32
    m_distanceScale_Damping = 0X0000C0 // CAnimInputDamping

 CSetFacingAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_facingMode = 0X000040 // FacingMode
    m_bResetChild = 0X000044 // bool

 CStopAtGoalAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_flOuterRadius = 0X000040 // float32
    m_flInnerRadius = 0X000044 // float32
    m_flMaxScale = 0X000048 // float32
    m_flMinScale = 0X00004C // float32
    m_damping = 0X000050 // CAnimInputDamping

 CJiggleBoneItem: [animationsystem.dll]
    m_boneName = 0X000000 // CUtlString
    m_flSpringStrength = 0X000008 // float32
    m_flSimRateFPS = 0X00000C // float32
    m_flDamping = 0X000010 // float32
    m_eSimSpace = 0X000014 // JiggleBoneSimSpace
    m_vBoundsMaxLS = 0X000018 // Vector
    m_vBoundsMinLS = 0X000024 // Vector

 CJiggleBoneAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_items = 0X000040 // CUtlVector< CJiggleBoneItem >

 CJumpHelperAnimNode: [animationsystem.dll]
    m_targetParamID = 0X0000B0 // AnimParamID
    m_flJumpStartCycle = 0X0000B4 // float32
    m_flJumpDuration = 0X0000B8 // float32
    m_bTranslateX = 0X0000BC // bool
    m_bTranslateY = 0X0000BD // bool
    m_bTranslateZ = 0X0000BE // bool
    m_bScaleSpeed = 0X0000BF // bool
    m_eCorrectionMethod = 0X0000C0 // JumpCorrectionMethod

 CSingleFrameAnimNode: [animationsystem.dll]
    m_sequenceName = 0X000050 // CUtlString
    m_eFrameSelection = 0X000058 // SingleFrameSelection
    m_nFrameIndex = 0X00005C // int32
    m_actions = 0X000060 // CUtlVector< CSmartPtr< CAnimActionBase > >

 CCommentAnimNode: [animationsystem.dll]
    m_commentText = 0X000040 // CUtlString
    m_size = 0X000048 // Vector2D
    m_color = 0X000050 // Color

 CContainerAnimNodeBase: [animationsystem.dll]
    m_inputNodeID = 0X000048 // AnimNodeID
    m_outputNodeID = 0X00004C // AnimNodeID
    m_inputConnectionMap = 0X000050 // CUtlHashtable< AnimNodeOutputID, CAnimNodeConnection >

 CInputStreamAnimNode: [animationsystem.dll]
    No schemes available

 CFootStepTriggerItem: [animationsystem.dll]
    m_footName = 0X000000 // CUtlString
    m_triggerPhase = 0X000008 // StepPhase
    m_tags = 0X000010 // CUtlVector< AnimTagID >

 CFootStepTriggerAnimNode: [animationsystem.dll]
    m_inputConnection = 0X000038 // CAnimNodeConnection
    m_flTolerance = 0X000040 // float32
    m_items = 0X000048 // CUtlVector< CFootStepTriggerItem >

 CSubGraphAnimNode: [animationsystem.dll]
    m_subGraphFilename = 0X000078 // CUtlString
    m_animNameMap = 0X000080 // CUtlHashtable< CUtlString, CUtlString >

 CBindPoseAnimNode: [animationsystem.dll]
    No schemes available

 CZeroPoseAnimNode: [animationsystem.dll]
    No schemes available

 CStateAction: [animationsystem.dll]
    m_pAction = 0X000008 // CSmartPtr< CAnimActionBase >
    m_eBehavior = 0X000010 // StateActionBehavior

 CAnimState: [animationsystem.dll]
    m_transitions = 0X000028 // CUtlVector< CSmartPtr< CAnimStateTransition > >
    m_actions = 0X000040 // CUtlVector< CStateAction >
    m_name = 0X000058 // CUtlString
    m_stateID = 0X000060 // AnimStateID
    m_position = 0X000064 // Vector2D
    m_bIsStartState = 0X00006C // bool
    m_bIsEndtState = 0X00006D // bool
    m_bIsPassthrough = 0X00006E // bool

 CAnimStateTransition: [animationsystem.dll]
    m_conditionList = 0X000028 // CConditionContainer
    m_srcState = 0X000060 // AnimStateID
    m_destState = 0X000064 // AnimStateID
    m_bDisabled = 0X000068 // bool

 CAnimStateMachine: [animationsystem.dll]
    m_states = 0X000008 // CUtlVector< CSmartPtr< CAnimState > >

 CStateActionUpdater: [animationsystem.dll]
    m_pAction = 0X000000 // CSmartPtr< CAnimActionUpdater >
    m_eBehavior = 0X000008 // StateActionBehavior

 CTransitionUpdateData: [animationsystem.dll]
    m_srcStateIndex = 0X000000 // uint8
    m_destStateIndex = 0X000001 // uint8
    m_bDisabled = 0X000000 // bitfield:1

 CStateUpdateData: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_hScript = 0X000008 // AnimScriptHandle
    m_transitionIndices = 0X000010 // CUtlVector< int32 >
    m_actions = 0X000028 // CUtlVector< CStateActionUpdater >
    m_stateID = 0X000040 // AnimStateID
    m_bIsStartState = 0X000000 // bitfield:1
    m_bIsEndState = 0X000000 // bitfield:1
    m_bIsPassthrough = 0X000000 // bitfield:1

 CAnimStateMachineUpdater: [animationsystem.dll]
    m_states = 0X000008 // CUtlVector< CStateUpdateData >
    m_transitions = 0X000020 // CUtlVector< CTransitionUpdateData >
    m_startStateIndex = 0X000050 // int32

 CConditionBase: [animationsystem.dll]
    No schemes available

 CConditionContainer: [animationsystem.dll]
    m_conditions = 0X000010 // CUtlVector< CSmartPtr< CConditionBase > >

 CCycleCondition: [animationsystem.dll]
    m_comparisonOp = 0X000028 // Comparison_t
    m_comparisonString = 0X000030 // CUtlString
    m_comparisonValue = 0X000038 // float32
    m_comparisonValueType = 0X00003C // ComparisonValueType
    m_comparisonParamID = 0X000040 // AnimParamID

 CFinishedCondition: [animationsystem.dll]
    m_option = 0X000028 // FinishedConditionOption
    m_bIsFinished = 0X00002C // bool

 COrCondition: [animationsystem.dll]
    No schemes available

 CParameterCondition: [animationsystem.dll]
    m_paramID = 0X000028 // AnimParamID
    m_comparisonOp = 0X00002C // Comparison_t
    m_comparisonValue = 0X000030 // CAnimVariant
    m_comparisonString = 0X000048 // CUtlString

 CStateStatusCondition: [animationsystem.dll]
    m_sourceValue = 0X000028 // StateValue
    m_comparisonValueType = 0X00002C // StateComparisonValueType
    m_comparisonFixedValue = 0X000030 // float32
    m_comparisonStateValue = 0X000034 // StateValue
    m_comparisonParamID = 0X000038 // AnimParamID
    m_comparisonOp = 0X00003C // Comparison_t

 CTagCondition: [animationsystem.dll]
    m_tagID = 0X000028 // AnimTagID
    m_comparisonValue = 0X00002C // bool

 CTimeCondition: [animationsystem.dll]
    m_comparisonOp = 0X000028 // Comparison_t
    m_comparisonString = 0X000030 // CUtlString

 TagSpan_t: [animationsystem.dll]
    m_tagIndex = 0X000000 // int32
    m_startCycle = 0X000004 // float32
    m_endCycle = 0X000008 // float32

 CAnimTagSpan: [animationsystem.dll]
    m_id = 0X000020 // AnimTagID
    m_fStartCycle = 0X000024 // float32
    m_fDuration = 0X000028 // float32

 CAnimTagManager: [animationsystem.dll]
    m_tags = 0X000018 // CUtlVector< CSmartPtr< CAnimTagBase > >

 CAnimTagBase: [animationsystem.dll]
    m_name = 0X000020 // CUtlString
    m_group = 0X000028 // CUtlString
    m_tagID = 0X000030 // AnimTagID
    m_bIsReferenced = 0X000034 // bool

 CStringAnimTag: [animationsystem.dll]
    No schemes available

 CFootFallAnimTag: [animationsystem.dll]
    m_foot = 0X000040 // FootFallTagFoot_t

 CAudioAnimTag: [animationsystem.dll]
    m_clipName = 0X000040 // CUtlString
    m_attachmentName = 0X000048 // CUtlString
    m_flVolume = 0X000050 // float32
    m_bStopWhenTagEnds = 0X000054 // bool
    m_bStopWhenGraphEnds = 0X000055 // bool
    m_bPlayOnServer = 0X000056 // bool
    m_bPlayOnClient = 0X000057 // bool

 CFootstepLandedAnimTag: [animationsystem.dll]
    m_FootstepType = 0X000040 // FootstepLandedFootSoundType_t
    m_OverrideSoundName = 0X000048 // CUtlString
    m_DebugAnimSourceString = 0X000050 // CUtlString
    m_BoneName = 0X000058 // CUtlString

 CSequenceFinishedAnimTag: [animationsystem.dll]
    m_sequenceName = 0X000040 // CUtlString

 CTaskStatusAnimTag: [animationsystem.dll]
    m_identifierString = 0X000040 // CUtlString

 CClothSettingsAnimTag: [animationsystem.dll]
    m_flStiffness = 0X000040 // float32
    m_flEaseIn = 0X000044 // float32
    m_flEaseOut = 0X000048 // float32
    m_nVertexSet = 0X000050 // CUtlString

 CRagdollAnimTag: [animationsystem.dll]
    m_nPoseControl = 0X000040 // AnimPoseControl
    m_flFrequency = 0X000044 // float32
    m_flDampingRatio = 0X000048 // float32
    m_flDecayDuration = 0X00004C // float32
    m_flDecayBias = 0X000050 // float32
    m_bDestroy = 0X000054 // bool

 CParticleAnimTag: [animationsystem.dll]
    m_hParticleSystem = 0X000040 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_particleSystemName = 0X000048 // CUtlString
    m_configName = 0X000050 // CUtlString
    m_bDetachFromOwner = 0X000058 // bool
    m_bStopWhenTagEnds = 0X000059 // bool
    m_bTagEndStopIsInstant = 0X00005A // bool
    m_attachmentName = 0X000060 // CUtlString
    m_attachmentType = 0X000068 // ParticleAttachment_t
    m_attachmentCP1Name = 0X000070 // CUtlString
    m_attachmentCP1Type = 0X000078 // ParticleAttachment_t

 CMaterialAttributeAnimTag: [animationsystem.dll]
    m_AttributeName = 0X000040 // CUtlString
    m_AttributeType = 0X000048 // MatterialAttributeTagType_t
    m_flValue = 0X00004C // float32
    m_Color = 0X000050 // Color

 CBodyGroupSetting: [animationsystem.dll]
    m_BodyGroupName = 0X000000 // CUtlString
    m_nBodyGroupOption = 0X000008 // int32

 CBodyGroupAnimTag: [animationsystem.dll]
    m_nPriority = 0X000040 // int32
    m_bodyGroupSettings = 0X000048 // CUtlVector< CBodyGroupSetting >

 CMotionNodeManager: [animationsystem.dll]
    No schemes available

 CMotionParameterManager: [animationsystem.dll]
    m_params = 0X000010 // CUtlVector< CSmartPtr< CMotionParameter > >

 CMotionParameter: [animationsystem.dll]
    m_name = 0X000018 // CUtlString
    m_id = 0X000020 // AnimParamID
    m_flMinValue = 0X000024 // float32
    m_flMaxValue = 0X000028 // float32
    m_nSamples = 0X00002C // int32

 SampleCode: [animationsystem.dll]
    m_subCode = 0X000000 // uint8[8]

 MotionDBIndex: [animationsystem.dll]
    m_nIndex = 0X000000 // uint32

 CVectorQuantizer: [animationsystem.dll]
    m_centroidVectors = 0X000000 // CUtlVector< float32 >
    m_nCentroids = 0X000018 // int32
    m_nDimensions = 0X00001C // int32

 CProductQuantizer: [animationsystem.dll]
    m_subQuantizers = 0X000000 // CUtlVector< CVectorQuantizer >
    m_nDimensions = 0X000018 // int32

 CMotionSearchNode: [animationsystem.dll]
    m_children = 0X000000 // CUtlVector< CMotionSearchNode* >
    m_quantizer = 0X000018 // CVectorQuantizer
    m_sampleCodes = 0X000038 // CUtlVector< CUtlVector< SampleCode > >
    m_sampleIndices = 0X000050 // CUtlVector< CUtlVector< int32 > >
    m_selectableSamples = 0X000068 // CUtlVector< int32 >

 CMotionSearchDB: [animationsystem.dll]
    m_rootNode = 0X000000 // CMotionSearchNode
    m_residualQuantizer = 0X000080 // CProductQuantizer
    m_codeIndices = 0X0000A0 // CUtlVector< MotionDBIndex >

 CMotionItemGroup: [animationsystem.dll]
    m_motions = 0X000020 // CUtlVector< CSmartPtr< CMotionItem > >
    m_name = 0X000038 // CUtlString
    m_conditions = 0X000040 // CConditionContainer

 CMotionItem: [animationsystem.dll]
    m_paramManager = 0X000028 // CMotionParameterManager
    m_blockSpans = 0X000050 // CUtlVector< CSmartPtr< CAnimTagSpan > >
    m_tagSpans = 0X000068 // CUtlVector< CSmartPtr< CAnimTagSpan > >
    m_paramSpans = 0X000080 // CUtlVector< CSmartPtr< CAnimParamSpan > >
    m_bLoop = 0X0000A0 // bool

 CSequenceMotionItem: [animationsystem.dll]
    m_sequenceName = 0X0000B0 // CUtlString

 CGraphMotionItem: [animationsystem.dll]
    m_name = 0X0000B0 // CUtlString
    m_nodeManager = 0X0000B8 // CMotionNodeManager

 CMotionMetricBase: [animationsystem.dll]
    m_flWeight = 0X000020 // float32

 CBlockSelectionMetric: [animationsystem.dll]
    No schemes available

 CFootCycleMetric: [animationsystem.dll]
    m_feet = 0X000028 // CUtlVector< CUtlString >

 CCurrentRotationVelocityMetric: [animationsystem.dll]
    No schemes available

 CCurrentVelocityMetric: [animationsystem.dll]
    No schemes available

 CPathMetric: [animationsystem.dll]
    m_flDistance = 0X000028 // float32
    m_pathSamples = 0X000030 // CUtlVector< float32 >
    m_bExtrapolateMovement = 0X000048 // bool
    m_flMinExtrapolationSpeed = 0X00004C // float32

 CFutureFacingMetric: [animationsystem.dll]
    m_flDistance = 0X000028 // float32
    m_flTime = 0X00002C // float32

 CFutureVelocityMetric: [animationsystem.dll]
    m_flDistance = 0X000028 // float32
    m_flStoppingDistance = 0X00002C // float32
    m_eMode = 0X000030 // VelocityMetricMode
    m_bAutoTargetSpeed = 0X000031 // bool
    m_flManualTargetSpeed = 0X000034 // float32

 CBonePositionMetric: [animationsystem.dll]
    m_boneName = 0X000028 // CUtlString

 CBoneVelocityMetric: [animationsystem.dll]
    m_boneName = 0X000028 // CUtlString

 CDistanceRemainingMetric: [animationsystem.dll]
    m_flMaxDistance = 0X000028 // float32
    m_bFilterFixedMinDistance = 0X00002C // bool
    m_flMinDistance = 0X000030 // float32
    m_bFilterGoalDistance = 0X000034 // bool
    m_flStartGoalFilterDistance = 0X000038 // float32
    m_bFilterGoalOvershoot = 0X00003C // bool
    m_flMaxGoalOvershootScale = 0X000040 // float32

 CStepsRemainingMetric: [animationsystem.dll]
    m_feet = 0X000028 // CUtlVector< CUtlString >
    m_flMinStepsRemaining = 0X000040 // float32

 CTimeRemainingMetric: [animationsystem.dll]
    m_bMatchByTimeRemaining = 0X000028 // bool
    m_flMaxTimeRemaining = 0X00002C // float32
    m_bFilterByTimeRemaining = 0X000030 // bool
    m_flMinTimeRemaining = 0X000034 // float32

 CFootPositionMetric: [animationsystem.dll]
    m_feet = 0X000028 // CUtlVector< CUtlString >
    m_bIgnoreSlope = 0X000040 // bool

 ScriptInfo_t: [animationsystem.dll]
    m_code = 0X000000 // CUtlString
    m_paramsModified = 0X000008 // CUtlVector< CAnimParamHandle >
    m_proxyReadParams = 0X000020 // CUtlVector< int32 >
    m_proxyWriteParams = 0X000038 // CUtlVector< int32 >
    m_eScriptType = 0X000050 // AnimScriptType

 CAnimScriptManager: [animationsystem.dll]
    m_scriptInfo = 0X000010 // CUtlVector< ScriptInfo_t >

 CAnimParamHandle: [animationsystem.dll]
    m_type = 0X000000 // AnimParamType_t
    m_index = 0X000001 // uint8

 CAnimReplayFrame: [animationsystem.dll]
    m_inputDataBlocks = 0X000010 // CUtlVector< CUtlBinaryBlock >
    m_instanceData = 0X000028 // CUtlBinaryBlock
    m_startingLocalToWorldTransform = 0X000040 // CTransform
    m_localToWorldTransform = 0X000060 // CTransform
    m_timeStamp = 0X000080 // float32

 CAnimGraphDebugReplay: [animationsystem.dll]
    m_animGraphFileName = 0X000040 // CUtlString
    m_frameList = 0X000048 // CUtlVector< CSmartPtr< CAnimReplayFrame > >
    m_startIndex = 0X000060 // int32
    m_writeIndex = 0X000064 // int32
    m_frameCount = 0X000068 // int32

 CAnimParamHandleMap: [animationsystem.dll]
    m_list = 0X000000 // CUtlHashtable< uint16, int16 >

 CAnimParameterListUpdater: [animationsystem.dll]
    m_parameters = 0X000018 // CUtlVector< CSmartPtr< CAnimParameterBase > >
    m_idToIndexMap = 0X000030 // CUtlHashtable< AnimParamID, int32 >
    m_nameToIndexMap = 0X000050 // CUtlHashtable< CUtlString, int32 >
    m_indexToHandle = 0X000070 // CUtlVector< CAnimParamHandle >
    m_autoResetParams = 0X000088 // CUtlVector< CUtlPair< CAnimParamHandle, CAnimVariant > >
    m_autoResetMap = 0X0000A0 // CUtlHashtable< CAnimParamHandle, int16 >

 CAnimTagManagerUpdater: [animationsystem.dll]
    m_tags = 0X000018 // CUtlVector< CSmartPtr< CAnimTagBase > >

 CAnimComponentUpdater: [animationsystem.dll]
    m_name = 0X000018 // CUtlString
    m_id = 0X000020 // AnimComponentID
    m_networkMode = 0X000024 // AnimNodeNetworkMode
    m_bStartEnabled = 0X000028 // bool

 CMovementMode: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_flSpeed = 0X000008 // float32

 CMovementComponentUpdater: [animationsystem.dll]
    m_movementModes = 0X000030 // CUtlVector< CMovementMode >
    m_motors = 0X000048 // CUtlVector< CSmartPtr< CAnimMotorUpdaterBase > >
    m_facingDamping = 0X000060 // CAnimInputDamping
    m_eDefaultFacingMode = 0X000070 // FacingMode
    m_nDefaultMotorIndex = 0X00007C // int32
    m_bMoveVarsDisabled = 0X000080 // bool
    m_bNetworkPath = 0X000081 // bool
    m_bNetworkFacing = 0X000082 // bool
    m_paramHandles = 0X000083 // CAnimParamHandle[30]

 CLookComponentUpdater: [animationsystem.dll]
    m_hLookHeading = 0X000034 // CAnimParamHandle
    m_hLookHeadingVelocity = 0X000036 // CAnimParamHandle
    m_hLookPitch = 0X000038 // CAnimParamHandle
    m_hLookDistance = 0X00003A // CAnimParamHandle
    m_hLookDirection = 0X00003C // CAnimParamHandle
    m_hLookTarget = 0X00003E // CAnimParamHandle
    m_hLookTargetWorldSpace = 0X000040 // CAnimParamHandle
    m_bNetworkLookTarget = 0X000042 // bool

 CSlopeComponentUpdater: [animationsystem.dll]
    m_flTraceDistance = 0X000034 // float32
    m_hSlopeAngle = 0X000038 // CAnimParamHandle
    m_hSlopeAngleFront = 0X00003A // CAnimParamHandle
    m_hSlopeAngleSide = 0X00003C // CAnimParamHandle
    m_hSlopeHeading = 0X00003E // CAnimParamHandle
    m_hSlopeNormal = 0X000040 // CAnimParamHandle
    m_hSlopeNormal_WorldSpace = 0X000042 // CAnimParamHandle

 CAnimActionUpdater: [animationsystem.dll]
    No schemes available

 CAnimMotorUpdaterBase: [animationsystem.dll]
    m_name = 0X000010 // CUtlString
    m_bDefault = 0X000018 // bool

 CPathAnimMotorUpdaterBase: [animationsystem.dll]
    m_bLockToPath = 0X000020 // bool

 CPathAnimMotorUpdater: [animationsystem.dll]
    No schemes available

 CDampedPathAnimMotorUpdater: [animationsystem.dll]
    m_flAnticipationTime = 0X00002C // float32
    m_flMinSpeedScale = 0X000030 // float32
    m_hAnticipationPosParam = 0X000034 // CAnimParamHandle
    m_hAnticipationHeadingParam = 0X000036 // CAnimParamHandle
    m_flSpringConstant = 0X000038 // float32
    m_flMinSpringTension = 0X00003C // float32
    m_flMaxSpringTension = 0X000040 // float32

 CPlayerInputAnimMotorUpdater: [animationsystem.dll]
    m_sampleTimes = 0X000020 // CUtlVector< float32 >
    m_flSpringConstant = 0X00003C // float32
    m_flAnticipationDistance = 0X000040 // float32
    m_hAnticipationPosParam = 0X000044 // CAnimParamHandle
    m_hAnticipationHeadingParam = 0X000046 // CAnimParamHandle
    m_bUseAcceleration = 0X000048 // bool

 CStateNodeTransitionData: [animationsystem.dll]
    m_curve = 0X000000 // CBlendCurve
    m_blendDuration = 0X000008 // CAnimValue< float32 >
    m_resetCycleValue = 0X000010 // CAnimValue< float32 >
    m_bReset = 0X000000 // bitfield:1
    m_resetCycleOption = 0X000000 // bitfield:3

 CStateNodeStateData: [animationsystem.dll]
    m_pChild = 0X000000 // CAnimUpdateNodeRef
    m_bExclusiveRootMotion = 0X000000 // bitfield:1

 CAnimUpdateNodeRef: [animationsystem.dll]
    m_nodeIndex = 0X000008 // int32

 CAnimUpdateNodeBase: [animationsystem.dll]
    m_nodePath = 0X000018 // CAnimNodePath
    m_name = 0X000048 // CUtlString
    m_networkMode = 0X000050 // AnimNodeNetworkMode

 CDirectPlaybackTagData: [animationsystem.dll]
    m_sequenceName = 0X000000 // CUtlString
    m_tags = 0X000008 // CUtlVector< TagSpan_t >

 TwoBoneIKSettings_t: [animationsystem.dll]
    m_endEffectorType = 0X000000 // IkEndEffectorType
    m_endEffectorAttachment = 0X000010 // CAnimAttachment
    m_targetType = 0X000090 // IkTargetType
    m_targetAttachment = 0X0000A0 // CAnimAttachment
    m_targetBoneIndex = 0X000120 // int32
    m_hPositionParam = 0X000124 // CAnimParamHandle
    m_hRotationParam = 0X000126 // CAnimParamHandle
    m_bAlwaysUseFallbackHinge = 0X000128 // bool
    m_vLsFallbackHingeAxis = 0X000130 // VectorAligned
    m_nFixedBoneIndex = 0X000140 // int32
    m_nMiddleBoneIndex = 0X000144 // int32
    m_nEndBoneIndex = 0X000148 // int32
    m_bMatchTargetOrientation = 0X00014C // bool
    m_bConstrainTwist = 0X00014D // bool
    m_flMaxTwist = 0X000150 // float32

 CBinaryUpdateNode: [animationsystem.dll]
    m_pChild1 = 0X000058 // CAnimUpdateNodeRef
    m_pChild2 = 0X000068 // CAnimUpdateNodeRef
    m_timingBehavior = 0X000078 // BinaryNodeTiming
    m_flTimingBlend = 0X00007C // float32
    m_bResetChild1 = 0X000080 // bool
    m_bResetChild2 = 0X000081 // bool

 CUnaryUpdateNode: [animationsystem.dll]
    m_pChildNode = 0X000058 // CAnimUpdateNodeRef

 CLeafUpdateNode: [animationsystem.dll]
    No schemes available

 CSkeletalInputUpdateNode: [animationsystem.dll]
    m_fixedOpData = 0X000058 // SkeletalInputOpFixedSettings_t

 StanceInfo_t: [animationsystem.dll]
    m_vPosition = 0X000000 // Vector
    m_flDirection = 0X00000C // float32

 CStanceOverrideUpdateNode: [animationsystem.dll]
    m_footStanceInfo = 0X000068 // CUtlVector< StanceInfo_t >
    m_pStanceSourceNode = 0X000080 // CAnimUpdateNodeRef
    m_hParameter = 0X000090 // CAnimParamHandle
    m_eMode = 0X000094 // StanceOverrideMode

 CStanceScaleUpdateNode: [animationsystem.dll]
    m_hParam = 0X000068 // CAnimParamHandle

 CSelectorUpdateNode: [animationsystem.dll]
    m_children = 0X000058 // CUtlVector< CAnimUpdateNodeRef >
    m_tags = 0X000070 // CUtlVector< int8 >
    m_blendCurve = 0X00008C // CBlendCurve
    m_flBlendTime = 0X000094 // CAnimValue< float32 >
    m_hParameter = 0X00009C // CAnimParamHandle
    m_eTagBehavior = 0X0000A0 // SelectorTagBehavior_t
    m_bResetOnChange = 0X0000A4 // bool
    m_bSyncCyclesOnChange = 0X0000A5 // bool

 CHitReactUpdateNode: [animationsystem.dll]
    m_opFixedSettings = 0X000068 // HitReactFixedSettings_t
    m_triggerParam = 0X0000B4 // CAnimParamHandle
    m_hitBoneParam = 0X0000B6 // CAnimParamHandle
    m_hitOffsetParam = 0X0000B8 // CAnimParamHandle
    m_hitDirectionParam = 0X0000BA // CAnimParamHandle
    m_hitStrengthParam = 0X0000BC // CAnimParamHandle
    m_flMinDelayBetweenHits = 0X0000C0 // float32
    m_bResetChild = 0X0000C4 // bool

 BlendItem_t: [animationsystem.dll]
    m_tags = 0X000000 // CUtlVector< TagSpan_t >
    m_pChild = 0X000018 // CAnimUpdateNodeRef
    m_hSequence = 0X000028 // HSequence
    m_vPos = 0X00002C // Vector2D
    m_flDuration = 0X000034 // float32
    m_bUseCustomDuration = 0X000038 // bool

 CBlend2DUpdateNode: [animationsystem.dll]
    m_items = 0X000060 // CUtlVector< BlendItem_t >
    m_tags = 0X000078 // CUtlVector< TagSpan_t >
    m_paramSpans = 0X000090 // CParamSpanUpdater
    m_nodeItemIndices = 0X0000A8 // CUtlVector< int32 >
    m_damping = 0X0000C0 // CAnimInputDamping
    m_blendSourceX = 0X0000D0 // AnimValueSource
    m_paramX = 0X0000D4 // CAnimParamHandle
    m_blendSourceY = 0X0000D8 // AnimValueSource
    m_paramY = 0X0000DC // CAnimParamHandle
    m_eBlendMode = 0X0000E0 // Blend2DMode
    m_playbackSpeed = 0X0000E4 // float32
    m_bLoop = 0X0000E8 // bool
    m_bLockBlendOnReset = 0X0000E9 // bool
    m_bLockWhenWaning = 0X0000EA // bool
    m_bAnimEventsAndTagsOnMostWeightedOnly = 0X0000EB // bool

 CFootAdjustmentUpdateNode: [animationsystem.dll]
    m_clips = 0X000070 // CUtlVector< HSequence >
    m_hBasePoseCacheHandle = 0X000088 // CPoseHandle
    m_facingTarget = 0X00008C // CAnimParamHandle
    m_flTurnTimeMin = 0X000090 // float32
    m_flTurnTimeMax = 0X000094 // float32
    m_flStepHeightMax = 0X000098 // float32
    m_flStepHeightMaxAngle = 0X00009C // float32
    m_bResetChild = 0X0000A0 // bool
    m_bAnimationDriven = 0X0000A1 // bool

 TraceSettings_t: [animationsystem.dll]
    m_flTraceHeight = 0X000000 // float32
    m_flTraceRadius = 0X000004 // float32

 FootFixedSettings: [animationsystem.dll]
    m_traceSettings = 0X000000 // TraceSettings_t
    m_vFootBaseBindPosePositionMS = 0X000010 // VectorAligned
    m_flFootBaseLength = 0X000020 // float32
    m_flMaxRotationLeft = 0X000024 // float32
    m_flMaxRotationRight = 0X000028 // float32
    m_footstepLandedTagIndex = 0X00002C // int32
    m_bEnableTracing = 0X000030 // bool
    m_flTraceAngleBlend = 0X000034 // float32
    m_nDisableTagIndex = 0X000038 // int32
    m_nFootIndex = 0X00003C // int32

 CFootLockUpdateNode: [animationsystem.dll]
    m_opFixedSettings = 0X000068 // FootLockPoseOpFixedSettings
    m_footSettings = 0X0000D0 // CUtlVector< FootFixedSettings >
    m_hipShiftDamping = 0X0000E8 // CAnimInputDamping
    m_rootHeightDamping = 0X0000F8 // CAnimInputDamping
    m_flStrideCurveScale = 0X000108 // float32
    m_flStrideCurveLimitScale = 0X00010C // float32
    m_flStepHeightIncreaseScale = 0X000110 // float32
    m_flStepHeightDecreaseScale = 0X000114 // float32
    m_flHipShiftScale = 0X000118 // float32
    m_flBlendTime = 0X00011C // float32
    m_flMaxRootHeightOffset = 0X000120 // float32
    m_flMinRootHeightOffset = 0X000124 // float32
    m_flTiltPlanePitchSpringStrength = 0X000128 // float32
    m_flTiltPlaneRollSpringStrength = 0X00012C // float32
    m_bApplyFootRotationLimits = 0X000130 // bool
    m_bApplyHipShift = 0X000131 // bool
    m_bModulateStepHeight = 0X000132 // bool
    m_bResetChild = 0X000133 // bool
    m_bEnableVerticalCurvedPaths = 0X000134 // bool
    m_bEnableRootHeightDamping = 0X000135 // bool

 CFootPinningUpdateNode: [animationsystem.dll]
    m_poseOpFixedData = 0X000070 // FootPinningPoseOpFixedData_t
    m_eTimingSource = 0X0000A0 // FootPinningTimingSource
    m_params = 0X0000A8 // CUtlVector< CAnimParamHandle >
    m_bResetChild = 0X0000C0 // bool

 CFollowPathUpdateNode: [animationsystem.dll]
    m_flBlendOutTime = 0X00006C // float32
    m_bBlockNonPathMovement = 0X000070 // bool
    m_bStopFeetAtGoal = 0X000071 // bool
    m_bScaleSpeed = 0X000072 // bool
    m_flScale = 0X000074 // float32
    m_flMinAngle = 0X000078 // float32
    m_flMaxAngle = 0X00007C // float32
    m_flSpeedScaleBlending = 0X000080 // float32
    m_turnDamping = 0X000088 // CAnimInputDamping
    m_facingTarget = 0X000098 // AnimValueSource
    m_hParam = 0X00009C // CAnimParamHandle
    m_flTurnToFaceOffset = 0X0000A0 // float32
    m_bTurnToFace = 0X0000A4 // bool

 CMotionMatchingUpdateNode: [animationsystem.dll]
    m_dataSet = 0X000058 // CMotionDataSet
    m_metrics = 0X000078 // CUtlVector< CSmartPtr< CMotionMetricEvaluator > >
    m_weights = 0X000090 // CUtlVector< float32 >
    m_bSearchEveryTick = 0X0000E0 // bool
    m_flSearchInterval = 0X0000E4 // float32
    m_bSearchWhenClipEnds = 0X0000E8 // bool
    m_bSearchWhenGoalChanges = 0X0000E9 // bool
    m_blendCurve = 0X0000EC // CBlendCurve
    m_flSampleRate = 0X0000F4 // float32
    m_flBlendTime = 0X0000F8 // float32
    m_bLockClipWhenWaning = 0X0000FC // bool
    m_flSelectionThreshold = 0X000100 // float32
    m_flReselectionTimeWindow = 0X000104 // float32
    m_bEnableRotationCorrection = 0X000108 // bool
    m_bGoalAssist = 0X000109 // bool
    m_flGoalAssistDistance = 0X00010C // float32
    m_flGoalAssistTolerance = 0X000110 // float32
    m_distanceScale_Damping = 0X000118 // CAnimInputDamping
    m_flDistanceScale_OuterRadius = 0X000128 // float32
    m_flDistanceScale_InnerRadius = 0X00012C // float32
    m_flDistanceScale_MaxScale = 0X000130 // float32
    m_flDistanceScale_MinScale = 0X000134 // float32
    m_bEnableDistanceScaling = 0X000138 // bool

 CSetFacingUpdateNode: [animationsystem.dll]
    m_facingMode = 0X000068 // FacingMode
    m_bResetChild = 0X00006C // bool

 CStopAtGoalUpdateNode: [animationsystem.dll]
    m_flOuterRadius = 0X00006C // float32
    m_flInnerRadius = 0X000070 // float32
    m_flMaxScale = 0X000074 // float32
    m_flMinScale = 0X000078 // float32
    m_damping = 0X000080 // CAnimInputDamping

 CJiggleBoneUpdateNode: [animationsystem.dll]
    m_opFixedData = 0X000068 // JiggleBoneSettingsList_t

 CSingleFrameUpdateNode: [animationsystem.dll]
    m_actions = 0X000058 // CUtlVector< CSmartPtr< CAnimActionUpdater > >
    m_hPoseCacheHandle = 0X000070 // CPoseHandle
    m_hSequence = 0X000074 // HSequence
    m_flCycle = 0X000078 // float32

 CInputStreamUpdateNode: [animationsystem.dll]
    No schemes available

 FootStepTrigger: [animationsystem.dll]
    m_tags = 0X000000 // CUtlVector< int32 >
    m_nFootIndex = 0X000018 // int32
    m_triggerPhase = 0X00001C // StepPhase

 CFootStepTriggerUpdateNode: [animationsystem.dll]
    m_triggers = 0X000068 // CUtlVector< FootStepTrigger >
    m_flTolerance = 0X000084 // float32

 CMotionGraphGroup: [animationsystem.dll]
    m_searchDB = 0X000000 // CMotionSearchDB
    m_motionGraphs = 0X0000B8 // CUtlVector< CSmartPtr< CMotionGraph > >
    m_motionGraphConfigs = 0X0000D0 // CUtlVector< CMotionGraphConfig >
    m_sampleToConfig = 0X0000E8 // CUtlVector< int32 >
    m_hIsActiveScript = 0X000100 // AnimScriptHandle

 CMotionDataSet: [animationsystem.dll]
    m_groups = 0X000000 // CUtlVector< CMotionGraphGroup >
    m_nDimensionCount = 0X000018 // int32

 CMotionGraph: [animationsystem.dll]
    m_paramSpans = 0X000010 // CParamSpanUpdater
    m_tags = 0X000028 // CUtlVector< TagSpan_t >
    m_pRootNode = 0X000040 // CSmartPtr< CMotionNode >
    m_nParameterCount = 0X000048 // int32
    m_nConfigStartIndex = 0X00004C // int32
    m_nConfigCount = 0X000050 // int32
    m_bLoop = 0X000054 // bool

 CEditableMotionGraph: [animationsystem.dll]
    No schemes available

 CMotionNode: [animationsystem.dll]
    m_name = 0X000018 // CUtlString
    m_id = 0X000020 // AnimNodeID

 CMotionNodeSequence: [animationsystem.dll]
    m_tags = 0X000028 // CUtlVector< TagSpan_t >
    m_hSequence = 0X000040 // HSequence
    m_flPlaybackSpeed = 0X000044 // float32

 MotionBlendItem: [animationsystem.dll]
    m_pChild = 0X000000 // CSmartPtr< CMotionNode >
    m_flKeyValue = 0X000008 // float32

 CMotionNodeBlend1D: [animationsystem.dll]
    m_blendItems = 0X000028 // CUtlVector< MotionBlendItem >
    m_nParamIndex = 0X000040 // int32

 CMotionMetricEvaluator: [animationsystem.dll]
    m_means = 0X000018 // CUtlVector< float32 >
    m_standardDeviations = 0X000030 // CUtlVector< float32 >
    m_flWeight = 0X000048 // float32
    m_nDimensionStartIndex = 0X00004C // int32

 CBlockSelectionMetricEvaluator: [animationsystem.dll]
    No schemes available

 CFootCycleMetricEvaluator: [animationsystem.dll]
    m_footIndices = 0X000050 // CUtlVector< int32 >

 CCurrentRotationVelocityMetricEvaluator: [animationsystem.dll]
    No schemes available

 CCurrentVelocityMetricEvaluator: [animationsystem.dll]
    No schemes available

 CPathMetricEvaluator: [animationsystem.dll]
    m_pathTimeSamples = 0X000050 // CUtlVector< float32 >
    m_flDistance = 0X000068 // float32
    m_bExtrapolateMovement = 0X00006C // bool
    m_flMinExtrapolationSpeed = 0X000070 // float32

 CFutureFacingMetricEvaluator: [animationsystem.dll]
    m_flDistance = 0X000050 // float32
    m_flTime = 0X000054 // float32

 CFutureVelocityMetricEvaluator: [animationsystem.dll]
    m_flDistance = 0X000050 // float32
    m_flStoppingDistance = 0X000054 // float32
    m_flTargetSpeed = 0X000058 // float32
    m_eMode = 0X00005C // VelocityMetricMode

 CBonePositionMetricEvaluator: [animationsystem.dll]
    m_nBoneIndex = 0X000050 // int32

 CBoneVelocityMetricEvaluator: [animationsystem.dll]
    m_nBoneIndex = 0X000050 // int32

 CDistanceRemainingMetricEvaluator: [animationsystem.dll]
    m_flMaxDistance = 0X000050 // float32
    m_flMinDistance = 0X000054 // float32
    m_flStartGoalFilterDistance = 0X000058 // float32
    m_flMaxGoalOvershootScale = 0X00005C // float32
    m_bFilterFixedMinDistance = 0X000060 // bool
    m_bFilterGoalDistance = 0X000061 // bool
    m_bFilterGoalOvershoot = 0X000062 // bool

 CStepsRemainingMetricEvaluator: [animationsystem.dll]
    m_footIndices = 0X000050 // CUtlVector< int32 >
    m_flMinStepsRemaining = 0X000068 // float32

 CTimeRemainingMetricEvaluator: [animationsystem.dll]
    m_bMatchByTimeRemaining = 0X000050 // bool
    m_flMaxTimeRemaining = 0X000054 // float32
    m_bFilterByTimeRemaining = 0X000058 // bool
    m_flMinTimeRemaining = 0X00005C // float32

 CFootPositionMetricEvaluator: [animationsystem.dll]
    m_footIndices = 0X000050 // CUtlVector< int32 >
    m_bIgnoreSlope = 0X000068 // bool

 AimMatrixOpFixedSettings_t: [animationsystem.dll]
    m_attachment = 0X000000 // CAnimAttachment
    m_damping = 0X000080 // CAnimInputDamping
    m_poseCacheHandles = 0X000090 // CPoseHandle[10]
    m_eBlendMode = 0X0000B8 // AimMatrixBlendMode
    m_fAngleIncrement = 0X0000BC // float32
    m_nSequenceMaxFrame = 0X0000C0 // int32
    m_nBoneMaskIndex = 0X0000C4 // int32
    m_bTargetIsPosition = 0X0000C8 // bool

 LookAtBone_t: [animationsystem.dll]
    m_index = 0X000000 // int32
    m_weight = 0X000004 // float32

 LookAtOpFixedSettings_t: [animationsystem.dll]
    m_attachment = 0X000000 // CAnimAttachment
    m_damping = 0X000080 // CAnimInputDamping
    m_bones = 0X000090 // CUtlVector< LookAtBone_t >
    m_flYawLimit = 0X0000A8 // float32
    m_flPitchLimit = 0X0000AC // float32
    m_flHysteresisInnerAngle = 0X0000B0 // float32
    m_flHysteresisOuterAngle = 0X0000B4 // float32
    m_bRotateYawForward = 0X0000B8 // bool
    m_bMaintainUpDirection = 0X0000B9 // bool
    m_bTargetIsPosition = 0X0000BA // bool
    m_bUseHysteresis = 0X0000BB // bool

 FollowAttachmentSettings_t: [animationsystem.dll]
    m_attachment = 0X000000 // CAnimAttachment
    m_boneIndex = 0X000080 // int32
    m_bMatchTranslation = 0X000084 // bool
    m_bMatchRotation = 0X000085 // bool

 FingerSource_t: [animationsystem.dll]
    m_nFingerIndex = 0X000000 // AnimVRFinger_t
    m_flFingerWeight = 0X000004 // float32

 FingerBone_t: [animationsystem.dll]
    m_boneIndex = 0X000000 // int32
    m_hingeAxis = 0X000004 // Vector
    m_vCapsulePos1 = 0X000010 // Vector
    m_vCapsulePos2 = 0X00001C // Vector
    m_flMinAngle = 0X000028 // float32
    m_flMaxAngle = 0X00002C // float32
    m_flRadius = 0X000030 // float32

 FingerChain_t: [animationsystem.dll]
    m_targets = 0X000000 // CUtlVector< FingerSource_t >
    m_bones = 0X000018 // CUtlVector< FingerBone_t >
    m_vTipOffset = 0X000030 // Vector
    m_vSplayHingeAxis = 0X00003C // Vector
    m_tipParentBoneIndex = 0X000048 // int32
    m_metacarpalBoneIndex = 0X00004C // int32
    m_flSplayMinAngle = 0X000050 // float32
    m_flSplayMaxAngle = 0X000054 // float32
    m_flFingerScaleRatio = 0X000058 // float32

 WristBone_t: [animationsystem.dll]
    m_xOffsetTransformMS = 0X000000 // CTransform
    m_boneIndex = 0X000020 // int32

 SkeletalInputOpFixedSettings_t: [animationsystem.dll]
    m_wristBones = 0X000000 // CUtlVector< WristBone_t >
    m_fingers = 0X000018 // CUtlVector< FingerChain_t >
    m_outerKnuckle1 = 0X000030 // int32
    m_outerKnuckle2 = 0X000034 // int32
    m_eHand = 0X000038 // AnimVRHand_t
    m_eMotionRange = 0X00003C // AnimVRHandMotionRange_t
    m_eTransformSource = 0X000040 // AnimVrBoneTransformSource_t
    m_bEnableIK = 0X000044 // bool
    m_bEnableCollision = 0X000045 // bool

 HitReactFixedSettings_t: [animationsystem.dll]
    m_nWeightListIndex = 0X000000 // int32
    m_nEffectedBoneCount = 0X000004 // int32
    m_flMaxImpactForce = 0X000008 // float32
    m_flMinImpactForce = 0X00000C // float32
    m_flWhipImpactScale = 0X000010 // float32
    m_flCounterRotationScale = 0X000014 // float32
    m_flDistanceFadeScale = 0X000018 // float32
    m_flPropagationScale = 0X00001C // float32
    m_flWhipDelay = 0X000020 // float32
    m_flSpringStrength = 0X000024 // float32
    m_flWhipSpringStrength = 0X000028 // float32
    m_flMaxAngleRadians = 0X00002C // float32
    m_nHipBoneIndex = 0X000030 // int32
    m_flHipBoneTranslationScale = 0X000034 // float32
    m_flHipDipSpringStrength = 0X000038 // float32
    m_flHipDipImpactScale = 0X00003C // float32
    m_flHipDipDelay = 0X000040 // float32

 FootLockPoseOpFixedSettings: [animationsystem.dll]
    m_footInfo = 0X000000 // CUtlVector< FootFixedData_t >
    m_hipDampingSettings = 0X000018 // CAnimInputDamping
    m_nHipBoneIndex = 0X000028 // int32
    m_ikSolverType = 0X00002C // IKSolverType
    m_bApplyTilt = 0X000030 // bool
    m_bApplyHipDrop = 0X000031 // bool
    m_bAlwaysUseFallbackHinge = 0X000032 // bool
    m_bApplyFootRotationLimits = 0X000033 // bool
    m_bApplyLegTwistLimits = 0X000034 // bool
    m_flMaxFootHeight = 0X000038 // float32
    m_flExtensionScale = 0X00003C // float32
    m_flMaxLegTwist = 0X000040 // float32
    m_bEnableLockBreaking = 0X000044 // bool
    m_flLockBreakTolerance = 0X000048 // float32
    m_flLockBlendTime = 0X00004C // float32
    m_bEnableStretching = 0X000050 // bool
    m_flMaxStretchAmount = 0X000054 // float32
    m_flStretchExtensionScale = 0X000058 // float32

 FootPinningPoseOpFixedData_t: [animationsystem.dll]
    m_footInfo = 0X000000 // CUtlVector< FootFixedData_t >
    m_flBlendTime = 0X000018 // float32
    m_flLockBreakDistance = 0X00001C // float32
    m_flMaxLegTwist = 0X000020 // float32
    m_nHipBoneIndex = 0X000024 // int32
    m_bApplyLegTwistLimits = 0X000028 // bool
    m_bApplyFootRotationLimits = 0X000029 // bool

 ChainToSolveData_t: [animationsystem.dll]
    m_nChainIndex = 0X000000 // int32
    m_SolverSettings = 0X000004 // IKSolverSettings_t
    m_TargetSettings = 0X000010 // IKTargetSettings_t
    m_DebugSetting = 0X000030 // SolveIKChainAnimNodeDebugSetting
    m_flDebugNormalizedValue = 0X000034 // float32
    m_vDebugOffset = 0X000040 // VectorAligned

 SolveIKChainPoseOpFixedSettings_t: [animationsystem.dll]
    m_ChainsToSolveData = 0X000000 // CUtlVector< ChainToSolveData_t >

 JiggleBoneSettings_t: [animationsystem.dll]
    m_nBoneIndex = 0X000000 // int32
    m_flSpringStrength = 0X000004 // float32
    m_flMaxTimeStep = 0X000008 // float32
    m_flDamping = 0X00000C // float32
    m_vBoundsMaxLS = 0X000010 // Vector
    m_vBoundsMinLS = 0X00001C // Vector
    m_eSimSpace = 0X000028 // JiggleBoneSimSpace

 JiggleBoneSettingsList_t: [animationsystem.dll]
    m_boneSettings = 0X000000 // CUtlVector< JiggleBoneSettings_t >

 VPhysics2ShapeDef_t: [animationsystem.dll]
    m_spheres = 0X000000 // CUtlVector< RnSphereDesc_t >
    m_capsules = 0X000018 // CUtlVector< RnCapsuleDesc_t >
    m_hulls = 0X000030 // CUtlVector< RnHullDesc_t >
    m_meshes = 0X000048 // CUtlVector< RnMeshDesc_t >
    m_CollisionAttributeIndices = 0X000060 // CUtlVector< uint16 >

 VPhysXBodyPart_t: [animationsystem.dll]
    m_nFlags = 0X000000 // uint32
    m_flMass = 0X000004 // float32
    m_rnShape = 0X000008 // VPhysics2ShapeDef_t
    m_nCollisionAttributeIndex = 0X000080 // uint16
    m_nReserved = 0X000082 // uint16
    m_flInertiaScale = 0X000084 // float32
    m_flLinearDamping = 0X000088 // float32
    m_flAngularDamping = 0X00008C // float32
    m_bOverrideMassCenter = 0X000090 // bool
    m_vMassCenterOverride = 0X000094 // Vector

 VPhysXCollisionAttributes_t: [animationsystem.dll]
    m_CollisionGroup = 0X000000 // uint32
    m_InteractAs = 0X000008 // CUtlVector< uint32 >
    m_InteractWith = 0X000020 // CUtlVector< uint32 >
    m_InteractExclude = 0X000038 // CUtlVector< uint32 >
    m_CollisionGroupString = 0X000050 // CUtlString
    m_InteractAsStrings = 0X000058 // CUtlVector< CUtlString >
    m_InteractWithStrings = 0X000070 // CUtlVector< CUtlString >
    m_InteractExcludeStrings = 0X000088 // CUtlVector< CUtlString >

 VPhysXRange_t: [animationsystem.dll]
    m_flMin = 0X000000 // float32
    m_flMax = 0X000004 // float32

 VPhysXConstraintParams_t: [animationsystem.dll]
    m_nType = 0X000000 // int8
    m_nTranslateMotion = 0X000001 // int8
    m_nRotateMotion = 0X000002 // int8
    m_nFlags = 0X000003 // int8
    m_anchor = 0X000004 // Vector[2]
    m_axes = 0X00001C // QuaternionStorage[2]
    m_maxForce = 0X00003C // float32
    m_maxTorque = 0X000040 // float32
    m_linearLimitValue = 0X000044 // float32
    m_linearLimitRestitution = 0X000048 // float32
    m_linearLimitSpring = 0X00004C // float32
    m_linearLimitDamping = 0X000050 // float32
    m_twistLowLimitValue = 0X000054 // float32
    m_twistLowLimitRestitution = 0X000058 // float32
    m_twistLowLimitSpring = 0X00005C // float32
    m_twistLowLimitDamping = 0X000060 // float32
    m_twistHighLimitValue = 0X000064 // float32
    m_twistHighLimitRestitution = 0X000068 // float32
    m_twistHighLimitSpring = 0X00006C // float32
    m_twistHighLimitDamping = 0X000070 // float32
    m_swing1LimitValue = 0X000074 // float32
    m_swing1LimitRestitution = 0X000078 // float32
    m_swing1LimitSpring = 0X00007C // float32
    m_swing1LimitDamping = 0X000080 // float32
    m_swing2LimitValue = 0X000084 // float32
    m_swing2LimitRestitution = 0X000088 // float32
    m_swing2LimitSpring = 0X00008C // float32
    m_swing2LimitDamping = 0X000090 // float32
    m_goalPosition = 0X000094 // Vector
    m_goalOrientation = 0X0000A0 // QuaternionStorage
    m_goalAngularVelocity = 0X0000B0 // Vector
    m_driveSpringX = 0X0000BC // float32
    m_driveSpringY = 0X0000C0 // float32
    m_driveSpringZ = 0X0000C4 // float32
    m_driveDampingX = 0X0000C8 // float32
    m_driveDampingY = 0X0000CC // float32
    m_driveDampingZ = 0X0000D0 // float32
    m_driveSpringTwist = 0X0000D4 // float32
    m_driveSpringSwing = 0X0000D8 // float32
    m_driveSpringSlerp = 0X0000DC // float32
    m_driveDampingTwist = 0X0000E0 // float32
    m_driveDampingSwing = 0X0000E4 // float32
    m_driveDampingSlerp = 0X0000E8 // float32
    m_solverIterationCount = 0X0000EC // int32
    m_projectionLinearTolerance = 0X0000F0 // float32
    m_projectionAngularTolerance = 0X0000F4 // float32

 VPhysXConstraint2_t: [animationsystem.dll]
    m_nFlags = 0X000000 // uint32
    m_nParent = 0X000004 // uint16
    m_nChild = 0X000006 // uint16
    m_params = 0X000008 // VPhysXConstraintParams_t

 VPhysXJoint_t: [animationsystem.dll]
    m_nType = 0X000000 // uint16
    m_nBody1 = 0X000002 // uint16
    m_nBody2 = 0X000004 // uint16
    m_nFlags = 0X000006 // uint16
    m_Frame1 = 0X000010 // CTransform
    m_Frame2 = 0X000030 // CTransform
    m_bEnableCollision = 0X000050 // bool
    m_bEnableLinearLimit = 0X000051 // bool
    m_LinearLimit = 0X000054 // VPhysXRange_t
    m_bEnableLinearMotor = 0X00005C // bool
    m_vLinearTargetVelocity = 0X000060 // Vector
    m_flMaxForce = 0X00006C // float32
    m_bEnableSwingLimit = 0X000070 // bool
    m_SwingLimit = 0X000074 // VPhysXRange_t
    m_bEnableTwistLimit = 0X00007C // bool
    m_TwistLimit = 0X000080 // VPhysXRange_t
    m_bEnableAngularMotor = 0X000088 // bool
    m_vAngularTargetVelocity = 0X00008C // Vector
    m_flMaxTorque = 0X000098 // float32
    m_flLinearFrequency = 0X00009C // float32
    m_flLinearDampingRatio = 0X0000A0 // float32
    m_flAngularFrequency = 0X0000A4 // float32
    m_flAngularDampingRatio = 0X0000A8 // float32
    m_flFriction = 0X0000AC // float32

 PhysSoftbodyDesc_t: [animationsystem.dll]
    m_ParticleBoneHash = 0X000000 // CUtlVector< uint32 >
    m_Particles = 0X000018 // CUtlVector< RnSoftbodyParticle_t >
    m_Springs = 0X000030 // CUtlVector< RnSoftbodySpring_t >
    m_Capsules = 0X000048 // CUtlVector< RnSoftbodyCapsule_t >
    m_InitPose = 0X000060 // CUtlVector< CTransform >
    m_ParticleBoneName = 0X000078 // CUtlVector< CUtlString >

 VPhysXAggregateData_t: [animationsystem.dll]
    m_nFlags = 0X000000 // uint16
    m_nRefCounter = 0X000002 // uint16
    m_bonesHash = 0X000008 // CUtlVector< uint32 >
    m_boneNames = 0X000020 // CUtlVector< CUtlString >
    m_indexNames = 0X000038 // CUtlVector< uint16 >
    m_indexHash = 0X000050 // CUtlVector< uint16 >
    m_bindPose = 0X000068 // CUtlVector< matrix3x4a_t >
    m_parts = 0X000080 // CUtlVector< VPhysXBodyPart_t >
    m_constraints2 = 0X000098 // CUtlVector< VPhysXConstraint2_t >
    m_joints = 0X0000B0 // CUtlVector< VPhysXJoint_t >
    m_pFeModel = 0X0000C8 // PhysFeModelDesc_t*
    m_boneParents = 0X0000D0 // CUtlVector< uint16 >
    m_surfacePropertyHashes = 0X0000E8 // CUtlVector< uint32 >
    m_collisionAttributes = 0X000100 // CUtlVector< VPhysXCollisionAttributes_t >
    m_debugPartNames = 0X000118 // CUtlVector< CUtlString >
    m_embeddedKeyvalues = 0X000130 // CUtlString

 CPhysSurfacePropertiesPhysics: [animationsystem.dll]
    m_friction = 0X000000 // float32
    m_elasticity = 0X000004 // float32
    m_density = 0X000008 // float32
    m_thickness = 0X00000C // float32
    m_softContactFrequency = 0X000010 // float32
    m_softContactDampingRatio = 0X000014 // float32
    m_wheelDrag = 0X000018 // float32

 CPhysSurfacePropertiesAudio: [animationsystem.dll]
    m_reflectivity = 0X000000 // float32
    m_hardnessFactor = 0X000004 // float32
    m_roughnessFactor = 0X000008 // float32
    m_roughThreshold = 0X00000C // float32
    m_hardThreshold = 0X000010 // float32
    m_hardVelocityThreshold = 0X000014 // float32
    m_flStaticImpactVolume = 0X000018 // float32
    m_flOcclusionFactor = 0X00001C // float32

 CPhysSurfacePropertiesSoundNames: [animationsystem.dll]
    m_impactSoft = 0X000000 // CUtlString
    m_impactHard = 0X000008 // CUtlString
    m_scrapeSmooth = 0X000010 // CUtlString
    m_scrapeRough = 0X000018 // CUtlString
    m_bulletImpact = 0X000020 // CUtlString
    m_rolling = 0X000028 // CUtlString
    m_break = 0X000030 // CUtlString
    m_strain = 0X000038 // CUtlString

 CPhysSurfaceProperties: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_nameHash = 0X000008 // uint32
    m_baseNameHash = 0X00000C // uint32
    m_bHidden = 0X000018 // bool
    m_description = 0X000020 // CUtlString
    m_physics = 0X000028 // CPhysSurfacePropertiesPhysics
    m_audioSounds = 0X000048 // CPhysSurfacePropertiesSoundNames
    m_audioParams = 0X000088 // CPhysSurfacePropertiesAudio

 CVPhysXSurfacePropertiesList: [animationsystem.dll]
    m_surfacePropertiesList = 0X000000 // CUtlVector< CPhysSurfaceProperties* >

 MaterialGroup_t: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_materials = 0X000008 // CUtlVector< CStrongHandle< InfoForResourceTypeIMaterial2 > >

 ModelSkeletonData_t: [animationsystem.dll]
    m_boneName = 0X000000 // CUtlVector< CUtlString >
    m_nParent = 0X000018 // CUtlVector< int16 >
    m_boneSphere = 0X000030 // CUtlVector< float32 >
    m_nFlag = 0X000048 // CUtlVector< uint32 >
    m_bonePosParent = 0X000060 // CUtlVector< Vector >
    m_boneRotParent = 0X000078 // CUtlVector< QuaternionStorage >
    m_boneScaleParent = 0X000090 // CUtlVector< float32 >

 PermModelInfo_t: [animationsystem.dll]
    m_nFlags = 0X000000 // uint32
    m_vHullMin = 0X000004 // Vector
    m_vHullMax = 0X000010 // Vector
    m_vViewMin = 0X00001C // Vector
    m_vViewMax = 0X000028 // Vector
    m_flMass = 0X000034 // float32
    m_vEyePosition = 0X000038 // Vector
    m_flMaxEyeDeflection = 0X000044 // float32
    m_sSurfaceProperty = 0X000048 // CUtlString
    m_keyValueText = 0X000050 // CUtlString

 PermModelExtPart_t: [animationsystem.dll]
    m_Transform = 0X000000 // CTransform
    m_Name = 0X000020 // CUtlString
    m_nParent = 0X000028 // int32
    m_refModel = 0X000030 // CStrongHandle< InfoForResourceTypeCModel >

 ModelBoneFlexDriverControl_t: [animationsystem.dll]
    m_nBoneComponent = 0X000000 // ModelBoneFlexComponent_t
    m_flexController = 0X000008 // CUtlString
    m_flexControllerToken = 0X000010 // uint32
    m_flMin = 0X000014 // float32
    m_flMax = 0X000018 // float32

 ModelBoneFlexDriver_t: [animationsystem.dll]
    m_boneName = 0X000000 // CUtlString
    m_boneNameToken = 0X000008 // uint32
    m_controls = 0X000010 // CUtlVector< ModelBoneFlexDriverControl_t >

 PermModelDataAnimatedMaterialAttribute_t: [animationsystem.dll]
    m_AttributeName = 0X000000 // CUtlString
    m_nNumChannels = 0X000008 // int32

 PermModelData_t: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_modelInfo = 0X000008 // PermModelInfo_t
    m_ExtParts = 0X000060 // CUtlVector< PermModelExtPart_t >
    m_refMeshes = 0X000078 // CUtlVector< CStrongHandle< InfoForResourceTypeCRenderMesh > >
    m_refMeshGroupMasks = 0X000090 // CUtlVector< uint64 >
    m_refPhysGroupMasks = 0X0000A8 // CUtlVector< uint64 >
    m_refLODGroupMasks = 0X0000C0 // CUtlVector< uint8 >
    m_lodGroupSwitchDistances = 0X0000D8 // CUtlVector< float32 >
    m_refPhysicsData = 0X0000F0 // CUtlVector< CStrongHandle< InfoForResourceTypeCPhysAggregateData > >
    m_refPhysicsHitboxData = 0X000108 // CUtlVector< CStrongHandle< InfoForResourceTypeCPhysAggregateData > >
    m_refAnimGroups = 0X000120 // CUtlVector< CStrongHandle< InfoForResourceTypeCAnimationGroup > >
    m_refSequenceGroups = 0X000138 // CUtlVector< CStrongHandle< InfoForResourceTypeCSequenceGroupData > >
    m_meshGroups = 0X000150 // CUtlVector< CUtlString >
    m_materialGroups = 0X000168 // CUtlVector< MaterialGroup_t >
    m_nDefaultMeshGroupMask = 0X000180 // uint64
    m_modelSkeleton = 0X000188 // ModelSkeletonData_t
    m_remappingTable = 0X000230 // CUtlVector< int16 >
    m_remappingTableStarts = 0X000248 // CUtlVector< uint16 >
    m_boneFlexDrivers = 0X000260 // CUtlVector< ModelBoneFlexDriver_t >
    m_pModelConfigList = 0X000278 // CModelConfigList*
    m_BodyGroupsHiddenInTools = 0X000280 // CUtlVector< CUtlString >
    m_refAnimIncludeModels = 0X000298 // CUtlVector< CStrongHandle< InfoForResourceTypeCModel > >
    m_AnimatedMaterialAttributes = 0X0002B0 // CUtlVector< PermModelDataAnimatedMaterialAttribute_t >

 AttachmentHandle_t: [animationsystem.dll]
    m_Value = 0X000000 // uint8

 CModelConfigElement: [animationsystem.dll]
    m_ElementName = 0X000008 // CUtlString
    m_NestedElements = 0X000010 // CUtlVector< CModelConfigElement* >

 CModelConfigElement_AttachedModel: [animationsystem.dll]
    m_InstanceName = 0X000048 // CUtlString
    m_EntityClass = 0X000050 // CUtlString
    m_hModel = 0X000058 // CStrongHandle< InfoForResourceTypeCModel >
    m_vOffset = 0X000060 // Vector
    m_aAngOffset = 0X00006C // QAngle
    m_AttachmentName = 0X000078 // CUtlString
    m_LocalAttachmentOffsetName = 0X000080 // CUtlString
    m_AttachmentType = 0X000088 // ModelConfigAttachmentType_t
    m_bBoneMergeFlex = 0X00008C // bool
    m_bUserSpecifiedColor = 0X00008D // bool
    m_bUserSpecifiedMaterialGroup = 0X00008E // bool
    m_bAcceptParentMaterialDrivenDecals = 0X00008F // bool
    m_BodygroupOnOtherModels = 0X000090 // CUtlString
    m_MaterialGroupOnOtherModels = 0X000098 // CUtlString

 CModelConfigElement_UserPick: [animationsystem.dll]
    m_Choices = 0X000048 // CUtlVector< CUtlString >

 CModelConfigElement_RandomPick: [animationsystem.dll]
    m_Choices = 0X000048 // CUtlVector< CUtlString >

 CModelConfigElement_SetMaterialGroup: [animationsystem.dll]
    m_MaterialGroupName = 0X000048 // CUtlString

 CModelConfigElement_SetMaterialGroupOnAttachedModels: [animationsystem.dll]
    m_MaterialGroupName = 0X000048 // CUtlString

 CModelConfigElement_SetRenderColor: [animationsystem.dll]
    m_Color = 0X000048 // Color

 CModelConfigElement_RandomColor: [animationsystem.dll]
    m_Gradient = 0X000048 // CColorGradient

 CModelConfigElement_SetBodygroup: [animationsystem.dll]
    m_GroupName = 0X000048 // CUtlString
    m_nChoice = 0X000050 // int32

 CModelConfigElement_SetBodygroupOnAttachedModels: [animationsystem.dll]
    m_GroupName = 0X000048 // CUtlString
    m_nChoice = 0X000050 // int32

 CModelConfigElement_Command: [animationsystem.dll]
    m_Command = 0X000048 // CUtlString
    m_Args = 0X000050 // KeyValues3

 CModelConfig: [animationsystem.dll]
    m_ConfigName = 0X000000 // CUtlString
    m_Elements = 0X000008 // CUtlVector< CModelConfigElement* >
    m_bTopLevel = 0X000020 // bool

 CModelConfigList: [animationsystem.dll]
    m_bHideMaterialGroupInTools = 0X000000 // bool
    m_bHideRenderColorInTools = 0X000001 // bool
    m_Configs = 0X000008 // CUtlVector< CModelConfig* >

 CRenderBufferBinding: [animationsystem.dll]
    m_hBuffer = 0X000000 // uint64
    m_nBindOffsetBytes = 0X000010 // uint32

 SkeletonBoneBounds_t: [animationsystem.dll]
    m_vecCenter = 0X000000 // Vector
    m_vecSize = 0X00000C // Vector

 RenderSkeletonBone_t: [animationsystem.dll]
    m_boneName = 0X000000 // CUtlString
    m_parentName = 0X000008 // CUtlString
    m_invBindPose = 0X000010 // matrix3x4_t
    m_bbox = 0X000040 // SkeletonBoneBounds_t
    m_flSphereRadius = 0X000058 // float32

 CRenderSkeleton: [animationsystem.dll]
    m_bones = 0X000000 // CUtlVector< RenderSkeletonBone_t >
    m_boneParents = 0X000030 // CUtlVector< int32 >
    m_nBoneWeightCount = 0X000048 // int32

 CDrawCullingData: [animationsystem.dll]
    m_vConeApex = 0X000000 // Vector
    m_ConeAxis = 0X00000C // int8[3]
    m_ConeCutoff = 0X00000F // int8

 CMaterialDrawDescriptor: [animationsystem.dll]
    m_nPrimitiveType = 0X000000 // RenderPrimitiveType_t
    m_nBaseVertex = 0X000004 // int32
    m_nVertexCount = 0X000008 // int32
    m_nStartIndex = 0X00000C // int32
    m_nIndexCount = 0X000010 // int32
    m_flUvDensity = 0X000014 // float32
    m_vTintColor = 0X000018 // Vector
    m_flAlpha = 0X000024 // float32
    m_nFirstMeshlet = 0X00002C // uint32
    m_nNumMeshlets = 0X000030 // uint16
    m_indexBuffer = 0X0000B8 // CRenderBufferBinding
    m_material = 0X0000E0 // CStrongHandle< InfoForResourceTypeIMaterial2 >

 CMeshletDescriptor: [animationsystem.dll]
    m_PackedAABB = 0X000000 // PackedAABB_t
    m_CullingData = 0X000008 // CDrawCullingData

 CSceneObjectData: [animationsystem.dll]
    m_vMinBounds = 0X000000 // Vector
    m_vMaxBounds = 0X00000C // Vector
    m_drawCalls = 0X000018 // CUtlVector< CMaterialDrawDescriptor >
    m_drawBounds = 0X000030 // CUtlVector< AABB_t >
    m_meshlets = 0X000048 // CUtlVector< CMeshletDescriptor >
    m_vTintColor = 0X000060 // Vector4D

 CAttachment: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_influenceNames = 0X000008 // CUtlString[3]
    m_vInfluenceRotations = 0X000020 // Quaternion[3]
    m_vInfluenceOffsets = 0X000050 // Vector[3]
    m_influenceWeights = 0X000074 // float32[3]
    m_bInfluenceRootTransform = 0X000080 // bool[3]
    m_nInfluences = 0X000083 // uint8
    m_bIgnoreRotation = 0X000084 // bool

 CHitBox: [animationsystem.dll]
    m_vMinBounds = 0X000020 // Vector
    m_vMaxBounds = 0X00002C // Vector
    m_name = 0X000038 // CUtlString
    m_sSurfaceProperty = 0X000040 // CUtlString
    m_sBoneName = 0X000048 // CUtlString
    m_flShapeRadius = 0X000050 // float32
    m_nBoneNameHash = 0X000054 // uint32
    m_nGroupId = 0X000058 // int32
    m_cRenderColor = 0X00005C // Color
    m_nHitBoxIndex = 0X000060 // uint16
    m_nShapeType = 0X000062 // uint8
    m_bTranslationOnly = 0X000064 // bool
    m_bVisible = 0X000065 // bool
    m_bSelected = 0X000066 // bool

 CHitBoxSet: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_nNameHash = 0X000008 // uint32
    m_HitBoxes = 0X000010 // CUtlVector< CHitBox >
    m_SourceFilename = 0X000028 // CUtlString

 CHitBoxSetList: [animationsystem.dll]
    m_HitBoxSets = 0X000000 // CUtlVector< CHitBoxSet >

 CRenderMesh: [animationsystem.dll]
    m_sceneObjects = 0X000010 // CUtlVectorFixedGrowable< CSceneObjectData >
    m_constraints = 0X0000A0 // CUtlVector< CBaseConstraint* >
    m_skeleton = 0X0000B8 // CRenderSkeleton

 CConstraintTarget: [animationsystem.dll]
    m_qOffset = 0X000020 // Quaternion
    m_vOffset = 0X000030 // Vector
    m_nBoneHash = 0X00003C // uint32
    m_sName = 0X000040 // CUtlString
    m_flWeight = 0X000048 // float32
    m_bIsAttachment = 0X000059 // bool

 CConstraintSlave: [animationsystem.dll]
    m_qBaseOrientation = 0X000000 // Quaternion
    m_vBasePosition = 0X000010 // Vector
    m_nBoneHash = 0X00001C // uint32
    m_flWeight = 0X000020 // float32
    m_sName = 0X000028 // CUtlString

 CBoneConstraintBase: [animationsystem.dll]
    No schemes available

 CBaseConstraint: [animationsystem.dll]
    m_name = 0X000028 // CUtlString
    m_vUpVector = 0X000030 // Vector
    m_slaves = 0X000040 // CUtlVector< CConstraintSlave >
    m_targets = 0X000058 // CUtlVector< CConstraintTarget >

 CPointConstraint: [animationsystem.dll]
    No schemes available

 COrientConstraint: [animationsystem.dll]
    No schemes available

 CAimConstraint: [animationsystem.dll]
    m_qAimOffset = 0X000070 // Quaternion
    m_nUpType = 0X000080 // uint32

 CTwistConstraint: [animationsystem.dll]
    m_bInverse = 0X000070 // bool
    m_qParentBindRotation = 0X000080 // Quaternion
    m_qChildBindRotation = 0X000090 // Quaternion

 CTiltTwistConstraint: [animationsystem.dll]
    m_nTargetAxis = 0X000070 // int32
    m_nSlaveAxis = 0X000074 // int32

 CMorphConstraint: [animationsystem.dll]
    m_sTargetMorph = 0X000070 // CUtlString
    m_nSlaveChannel = 0X000078 // int32
    m_flMin = 0X00007C // float32
    m_flMax = 0X000080 // float32

 CParentConstraint: [animationsystem.dll]
    No schemes available

 CBoneConstraintPoseSpaceMorph: [animationsystem.dll]
    m_sBoneName = 0X000028 // CUtlString
    m_sAttachmentName = 0X000030 // CUtlString
    m_outputMorph = 0X000038 // CUtlVector< CUtlString >
    m_inputList = 0X000050 // CUtlVector< CBoneConstraintPoseSpaceMorph::Input_t >
    m_bClamp = 0X000068 // bool

 CBoneConstraintPoseSpaceMorph::Input_t: [animationsystem.dll]
    m_inputValue = 0X000000 // Vector
    m_outputWeightList = 0X000010 // CUtlVector< float32 >

 CBoneConstraintPoseSpaceBone: [animationsystem.dll]
    m_inputList = 0X000070 // CUtlVector< CBoneConstraintPoseSpaceBone::Input_t >

 CBoneConstraintPoseSpaceBone::Input_t: [animationsystem.dll]
    m_inputValue = 0X000000 // Vector
    m_outputTransformList = 0X000010 // CUtlVector< CTransform >

 CFlexOp: [animationsystem.dll]
    m_OpCode = 0X000000 // FlexOpCode_t
    m_Data = 0X000004 // int32

 CFlexRule: [animationsystem.dll]
    m_nFlex = 0X000000 // int32
    m_FlexOps = 0X000008 // CUtlVector< CFlexOp >

 CFlexDesc: [animationsystem.dll]
    m_szFacs = 0X000000 // CUtlString

 CFlexController: [animationsystem.dll]
    m_szName = 0X000000 // CUtlString
    m_szType = 0X000008 // CUtlString
    min = 0X000010 // float32
    max = 0X000014 // float32

 CMorphBundleData: [animationsystem.dll]
    m_flULeftSrc = 0X000000 // float32
    m_flVTopSrc = 0X000004 // float32
    m_offsets = 0X000008 // CUtlVector< float32 >
    m_ranges = 0X000020 // CUtlVector< float32 >

 CMorphRectData: [animationsystem.dll]
    m_nXLeftDst = 0X000000 // int16
    m_nYTopDst = 0X000002 // int16
    m_flUWidthSrc = 0X000004 // float32
    m_flVHeightSrc = 0X000008 // float32
    m_bundleDatas = 0X000010 // CUtlVector< CMorphBundleData >

 CMorphData: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_morphRectDatas = 0X000008 // CUtlVector< CMorphRectData >

 CMorphSetData: [animationsystem.dll]
    m_nWidth = 0X000010 // int32
    m_nHeight = 0X000014 // int32
    m_bundleTypes = 0X000018 // CUtlVector< MorphBundleType_t >
    m_morphDatas = 0X000030 // CUtlVector< CMorphData >
    m_pTextureAtlas = 0X000048 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_FlexDesc = 0X000050 // CUtlVector< CFlexDesc >
    m_FlexControllers = 0X000068 // CUtlVector< CFlexController >
    m_FlexRules = 0X000080 // CUtlVector< CFlexRule >

 CAnimFoot: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_vBallOffset = 0X000008 // Vector
    m_vHeelOffset = 0X000014 // Vector
    m_ankleBoneIndex = 0X000020 // int32
    m_toeBoneIndex = 0X000024 // int32

 CAnimSkeleton: [animationsystem.dll]
    m_localSpaceTransforms = 0X000010 // CUtlVector< CTransform >
    m_modelSpaceTransforms = 0X000028 // CUtlVector< CTransform >
    m_boneNames = 0X000040 // CUtlVector< CUtlString >
    m_children = 0X000058 // CUtlVector< CUtlVector< int32 > >
    m_parents = 0X000070 // CUtlVector< int32 >
    m_feet = 0X000088 // CUtlVector< CAnimFoot >
    m_morphNames = 0X0000A0 // CUtlVector< CUtlString >
    m_lodBoneCounts = 0X0000B8 // CUtlVector< int32 >

 CFootDefinition: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_ankleBoneName = 0X000008 // CUtlString
    m_toeBoneName = 0X000010 // CUtlString
    m_vBallOffset = 0X000018 // Vector
    m_vHeelOffset = 0X000024 // Vector
    m_flFootLength = 0X000030 // float32
    m_flBindPoseDirectionMS = 0X000034 // float32
    m_flTraceHeight = 0X000038 // float32
    m_flTraceRadius = 0X00003C // float32

 CCycleBase: [animationsystem.dll]
    m_flCycle = 0X000000 // float32

 CAnimCycle: [animationsystem.dll]
    No schemes available

 CFootCycle: [animationsystem.dll]
    No schemes available

 CFootCycleDefinition: [animationsystem.dll]
    m_vStancePositionMS = 0X000000 // Vector
    m_vMidpointPositionMS = 0X00000C // Vector
    m_flStanceDirectionMS = 0X000018 // float32
    m_vToStrideStartPos = 0X00001C // Vector
    m_stanceCycle = 0X000028 // CAnimCycle
    m_footLiftCycle = 0X00002C // CFootCycle
    m_footOffCycle = 0X000030 // CFootCycle
    m_footStrikeCycle = 0X000034 // CFootCycle
    m_footLandCycle = 0X000038 // CFootCycle

 CFootTrajectory: [animationsystem.dll]
    m_vOffset = 0X000000 // Vector
    m_flRotationOffset = 0X00000C // float32
    m_flProgression = 0X000010 // float32

 CFootTrajectories: [animationsystem.dll]
    m_trajectories = 0X000000 // CUtlVector< CFootTrajectory >

 CFootStride: [animationsystem.dll]
    m_definition = 0X000000 // CFootCycleDefinition
    m_trajectories = 0X000040 // CFootTrajectories

 CFootMotion: [animationsystem.dll]
    m_strides = 0X000000 // CUtlVector< CFootStride >
    m_name = 0X000018 // CUtlString
    m_bAdditive = 0X000020 // bool

 CFingerSource: [animationsystem.dll]
    m_nFingerIndex = 0X000000 // AnimVRFinger_t
    m_flFingerWeight = 0X000004 // float32

 CFingerBone: [animationsystem.dll]
    m_boneName = 0X000000 // CUtlString
    m_hingeAxis = 0X000008 // Vector
    m_vCapsulePos1 = 0X000014 // Vector
    m_vCapsulePos2 = 0X000020 // Vector
    m_flMinAngle = 0X00002C // float32
    m_flMaxAngle = 0X000030 // float32
    m_flRadius = 0X000034 // float32

 CFingerChain: [animationsystem.dll]
    m_targets = 0X000000 // CUtlVector< CFingerSource >
    m_bones = 0X000018 // CUtlVector< CFingerBone >
    m_name = 0X000030 // CUtlString
    m_tipParentBoneName = 0X000038 // CUtlString
    m_vTipOffset = 0X000040 // Vector
    m_metacarpalBoneName = 0X000050 // CUtlString
    m_vSplayHingeAxis = 0X000058 // Vector
    m_flSplayMinAngle = 0X000064 // float32
    m_flSplayMaxAngle = 0X000068 // float32
    m_flFingerScaleRatio = 0X00006C // float32

 CWristBone: [animationsystem.dll]
    m_name = 0X000000 // CUtlString
    m_vForwardLS = 0X000008 // Vector
    m_vUpLS = 0X000014 // Vector
    m_vOffset = 0X000020 // Vector

 CVrSkeletalInputSettings: [animationsystem.dll]
    m_wristBones = 0X000000 // CUtlVector< CWristBone >
    m_fingers = 0X000018 // CUtlVector< CFingerChain >
    m_name = 0X000030 // CUtlString
    m_outerKnuckle1 = 0X000038 // CUtlString
    m_outerKnuckle2 = 0X000040 // CUtlString
    m_eHand = 0X000048 // AnimVRHand_t

 CAnimationGraph: [animationsystem.dll]
    m_pSettingsManager = 0X0000E8 // CSmartPtr< CAnimGraphSettingsManager >
    m_clipDataManager = 0X0000F8 // CAnimClipDataManager
    m_modelName = 0X000140 // CUtlString
    m_previewModelName = 0X000148 // CUtlString

 CAnimScriptComponentUpdater: [animationsystem.dll]
    m_hScript = 0X000030 // AnimScriptHandle

 CActionComponentUpdater: [animationsystem.dll]
    m_actions = 0X000030 // CUtlVector< CSmartPtr< CAnimActionUpdater > >

 CCPPScriptComponentUpdater: [animationsystem.dll]
    m_scriptsToRun = 0X000030 // CUtlVector< CUtlString >

 CDampedValueComponentUpdater: [animationsystem.dll]
    m_items = 0X000030 // CUtlVector< CDampedValueUpdateItem >

 CLODComponentUpdater: [animationsystem.dll]
    m_nServerLOD = 0X000030 // int32

 CRagdollComponentUpdater: [animationsystem.dll]
    m_ragdollNodePaths = 0X000030 // CUtlVector< CAnimNodePath >
    m_boneIndices = 0X000048 // CUtlVector< int32 >
    m_boneNames = 0X000060 // CUtlVector< CUtlString >
    m_weightLists = 0X000078 // CUtlVector< WeightList >
    m_flSpringFrequencyMin = 0X000090 // float32
    m_flSpringFrequencyMax = 0X000094 // float32

 CAnimComponentStateTransition: [animationsystem.dll]
    No schemes available

 CAnimComponentState: [animationsystem.dll]
    No schemes available

 CStateMachineComponent: [animationsystem.dll]
    m_sName = 0X000060 // CUtlString

 CStateMachineComponentUpdater: [animationsystem.dll]
    m_stateMachine = 0X000030 // CAnimStateMachineUpdater

 CVRInputComponentUpdater: [animationsystem.dll]
    m_FingerCurl_Thumb = 0X000034 // CAnimParamHandle
    m_FingerCurl_Index = 0X000036 // CAnimParamHandle
    m_FingerCurl_Middle = 0X000038 // CAnimParamHandle
    m_FingerCurl_Ring = 0X00003A // CAnimParamHandle
    m_FingerCurl_Pinky = 0X00003C // CAnimParamHandle
    m_FingerSplay_Thumb_Index = 0X00003E // CAnimParamHandle
    m_FingerSplay_Index_Middle = 0X000040 // CAnimParamHandle
    m_FingerSplay_Middle_Ring = 0X000042 // CAnimParamHandle
    m_FingerSplay_Ring_Pinky = 0X000044 // CAnimParamHandle

 CEmitTagActionUpdater: [animationsystem.dll]
    m_nTagIndex = 0X000018 // int32
    m_bIsZeroDuration = 0X00001C // bool

 CSetParameterActionUpdater: [animationsystem.dll]
    m_hParam = 0X000018 // CAnimParamHandle
    m_value = 0X00001A // CAnimVariant

 CToggleComponentActionUpdater: [animationsystem.dll]
    m_componentID = 0X000018 // AnimComponentID
    m_bSetEnabled = 0X00001C // bool

 CExpressionActionUpdater: [animationsystem.dll]
    m_hParam = 0X000018 // CAnimParamHandle
    m_eParamType = 0X00001A // AnimParamType_t
    m_hScript = 0X00001C // AnimScriptHandle

 CAnimNodeStateTransition: [animationsystem.dll]
    m_blendDuration = 0X000078 // CFloatAnimValue
    m_bReset = 0X000090 // bool
    m_resetCycleOption = 0X000094 // ResetCycleOption
    m_flFixedCycleValue = 0X000098 // CFloatAnimValue
    m_blendCurve = 0X0000B0 // CBlendCurve

 CAnimNodeState: [animationsystem.dll]
    m_inputConnection = 0X000070 // CAnimNodeConnection
    m_bIsRootMotionExclusive = 0X000078 // bool

 CStateMachineAnimNode: [animationsystem.dll]
    m_bBlockWaningTags = 0X000060 // bool
    m_bLockStateWhenWaning = 0X000061 // bool

 CRagdollUpdateNode: [animationsystem.dll]
    m_nWeightListIndex = 0X000068 // int32
    m_poseControlMethod = 0X00006C // RagdollPoseControl

 CGroupAnimNode: [animationsystem.dll]
    m_nodeMgr = 0X000070 // CAnimNodeManager

 CGroupInputAnimNode: [animationsystem.dll]
    No schemes available

 CGroupOutputAnimNode: [animationsystem.dll]
    No schemes available

 CBindPoseUpdateNode: [animationsystem.dll]
    No schemes available

 CZeroPoseUpdateNode: [animationsystem.dll]
    No schemes available

 CAndCondition: [animationsystem.dll]
    No schemes available

 CRootUpdateNode: [animationsystem.dll]
    No schemes available

 CSequenceUpdateNode: [animationsystem.dll]
    m_paramSpans = 0X000060 // CParamSpanUpdater
    m_tags = 0X000078 // CUtlVector< TagSpan_t >
    m_hSequence = 0X000094 // HSequence
    m_playbackSpeed = 0X000098 // float32
    m_duration = 0X00009C // float32
    m_bLoop = 0X0000A0 // bool

 CBlendUpdateNode: [animationsystem.dll]
    m_children = 0X000060 // CUtlVector< CAnimUpdateNodeRef >
    m_sortedOrder = 0X000078 // CUtlVector< uint8 >
    m_targetValues = 0X000090 // CUtlVector< float32 >
    m_blendValueSource = 0X0000AC // AnimValueSource
    m_paramIndex = 0X0000B0 // CAnimParamHandle
    m_damping = 0X0000B8 // CAnimInputDamping
    m_blendKeyType = 0X0000C8 // BlendKeyType
    m_bLockBlendOnReset = 0X0000CC // bool
    m_bSyncCycles = 0X0000CD // bool
    m_bLoop = 0X0000CE // bool
    m_bLockWhenWaning = 0X0000CF // bool

 CStateMachineUpdateNode: [animationsystem.dll]
    m_stateMachine = 0X000068 // CAnimStateMachineUpdater
    m_stateData = 0X0000C0 // CUtlVector< CStateNodeStateData >
    m_transitionData = 0X0000D8 // CUtlVector< CStateNodeTransitionData >
    m_bBlockWaningTags = 0X0000F4 // bool
    m_bLockStateWhenWaning = 0X0000F5 // bool

 CChoiceUpdateNode: [animationsystem.dll]
    m_children = 0X000058 // CUtlVector< CAnimUpdateNodeRef >
    m_weights = 0X000070 // CUtlVector< float32 >
    m_blendTimes = 0X000088 // CUtlVector< float32 >
    m_choiceMethod = 0X0000A0 // ChoiceMethod
    m_choiceChangeMethod = 0X0000A4 // ChoiceChangeMethod
    m_blendMethod = 0X0000A8 // ChoiceBlendMethod
    m_blendTime = 0X0000AC // float32
    m_bCrossFade = 0X0000B0 // bool
    m_bResetChosen = 0X0000B1 // bool
    m_bDontResetSameSelection = 0X0000B2 // bool

 CCycleControlUpdateNode: [animationsystem.dll]
    m_valueSource = 0X000068 // AnimValueSource
    m_paramIndex = 0X00006C // CAnimParamHandle

 CCycleControlClipUpdateNode: [animationsystem.dll]
    m_tags = 0X000060 // CUtlVector< TagSpan_t >
    m_hSequence = 0X00007C // HSequence
    m_duration = 0X000080 // float32
    m_valueSource = 0X000084 // AnimValueSource
    m_paramIndex = 0X000088 // CAnimParamHandle

 CAddUpdateNode: [animationsystem.dll]
    m_footMotionTiming = 0X00008C // BinaryNodeChildOption
    m_bApplyToFootMotion = 0X000090 // bool
    m_bApplyChannelsSeparately = 0X000091 // bool
    m_bUseModelSpace = 0X000092 // bool

 CSubtractUpdateNode: [animationsystem.dll]
    m_footMotionTiming = 0X00008C // BinaryNodeChildOption
    m_bApplyToFootMotion = 0X000090 // bool
    m_bApplyChannelsSeparately = 0X000091 // bool
    m_bUseModelSpace = 0X000092 // bool

 CMoverUpdateNode: [animationsystem.dll]
    m_damping = 0X000070 // CAnimInputDamping
    m_facingTarget = 0X000080 // AnimValueSource
    m_hMoveVecParam = 0X000084 // CAnimParamHandle
    m_hMoveHeadingParam = 0X000086 // CAnimParamHandle
    m_hTurnToFaceParam = 0X000088 // CAnimParamHandle
    m_flTurnToFaceOffset = 0X00008C // float32
    m_flTurnToFaceLimit = 0X000090 // float32
    m_bAdditive = 0X000094 // bool
    m_bApplyMovement = 0X000095 // bool
    m_bOrientMovement = 0X000096 // bool
    m_bApplyRotation = 0X000097 // bool
    m_bLimitOnly = 0X000098 // bool

 CSlowDownOnSlopesUpdateNode: [animationsystem.dll]
    m_flSlowDownStrength = 0X000068 // float32

 CTurnHelperUpdateNode: [animationsystem.dll]
    m_facingTarget = 0X00006C // AnimValueSource
    m_turnStartTimeOffset = 0X000070 // float32
    m_turnDuration = 0X000074 // float32
    m_bMatchChildDuration = 0X000078 // bool
    m_manualTurnOffset = 0X00007C // float32
    m_bUseManualTurnOffset = 0X000080 // bool

 CAimMatrixUpdateNode: [animationsystem.dll]
    m_opFixedSettings = 0X000070 // AimMatrixOpFixedSettings_t
    m_target = 0X000148 // AnimVectorSource
    m_paramIndex = 0X00014C // CAnimParamHandle
    m_hSequence = 0X000150 // HSequence
    m_bResetChild = 0X000154 // bool
    m_bLockWhenWaning = 0X000155 // bool

 CSpeedScaleUpdateNode: [animationsystem.dll]
    m_paramIndex = 0X000068 // CAnimParamHandle

 CDirectionalBlendUpdateNode: [animationsystem.dll]
    m_hSequences = 0X00005C // HSequence[8]
    m_damping = 0X000080 // CAnimInputDamping
    m_blendValueSource = 0X000090 // AnimValueSource
    m_paramIndex = 0X000094 // CAnimParamHandle
    m_playbackSpeed = 0X000098 // float32
    m_duration = 0X00009C // float32
    m_bLoop = 0X0000A0 // bool
    m_bLockBlendOnReset = 0X0000A1 // bool

 CWayPointHelperUpdateNode: [animationsystem.dll]
    m_flStartCycle = 0X00006C // float32
    m_flEndCycle = 0X000070 // float32
    m_bOnlyGoals = 0X000074 // bool
    m_bPreventOvershoot = 0X000075 // bool
    m_bPreventUndershoot = 0X000076 // bool

 CBoneMaskUpdateNode: [animationsystem.dll]
    m_nWeightListIndex = 0X00008C // int32
    m_flRootMotionBlend = 0X000090 // float32
    m_blendSpace = 0X000094 // BoneMaskBlendSpace
    m_footMotionTiming = 0X000098 // BinaryNodeChildOption
    m_bUseBlendScale = 0X00009C // bool
    m_blendValueSource = 0X0000A0 // AnimValueSource
    m_hBlendParameter = 0X0000A4 // CAnimParamHandle

 CChoreoUpdateNode: [animationsystem.dll]
    No schemes available

 CDirectPlaybackUpdateNode: [animationsystem.dll]
    m_bFinishEarly = 0X00006C // bool
    m_bResetOnFinish = 0X00006D // bool
    m_allTags = 0X000070 // CUtlVector< CDirectPlaybackTagData >

 CLeanMatrixUpdateNode: [animationsystem.dll]
    m_frameCorners = 0X00005C // int32[3][3]
    m_poses = 0X000080 // CPoseHandle[9]
    m_damping = 0X0000A8 // CAnimInputDamping
    m_blendSource = 0X0000B8 // AnimVectorSource
    m_paramIndex = 0X0000BC // CAnimParamHandle
    m_verticalAxis = 0X0000C0 // Vector
    m_horizontalAxis = 0X0000CC // Vector
    m_hSequence = 0X0000D8 // HSequence
    m_flMaxValue = 0X0000DC // float32
    m_nSequenceMaxFrame = 0X0000E0 // int32

 CTwoBoneIKUpdateNode: [animationsystem.dll]
    m_opFixedData = 0X000070 // TwoBoneIKSettings_t

 CSolveIKChainUpdateNode: [animationsystem.dll]
    m_targetHandles = 0X000068 // CUtlVector< CAnimParamHandle >
    m_opFixedData = 0X000080 // SolveIKChainPoseOpFixedSettings_t

 CLookAtUpdateNode: [animationsystem.dll]
    m_opFixedSettings = 0X000070 // LookAtOpFixedSettings_t
    m_target = 0X000138 // AnimVectorSource
    m_paramIndex = 0X00013C // CAnimParamHandle
    m_weightParamIndex = 0X00013E // CAnimParamHandle
    m_bResetChild = 0X000140 // bool
    m_bLockWhenWaning = 0X000141 // bool

 CPathHelperUpdateNode: [animationsystem.dll]
    m_flStoppingRadius = 0X000068 // float32
    m_flStoppingSpeedScale = 0X00006C // float32

 CFollowAttachmentUpdateNode: [animationsystem.dll]
    m_opFixedData = 0X000070 // FollowAttachmentSettings_t

 CJumpHelperUpdateNode: [animationsystem.dll]
    m_hTargetParam = 0X0000A8 // CAnimParamHandle
    m_flOriginalJumpMovement = 0X0000AC // Vector
    m_flOriginalJumpDuration = 0X0000B8 // float32
    m_flJumpStartCycle = 0X0000BC // float32
    m_flJumpEndCycle = 0X0000C0 // float32
    m_eCorrectionMethod = 0X0000C4 // JumpCorrectionMethod
    m_bTranslationAxis = 0X0000C8 // bool[3]
    m_bScaleSpeed = 0X0000CB // bool


vphysics2.dll:
 constraint_breakableparams_t: [vphysics2.dll]
    strength = 0X000000 // float32
    forceLimit = 0X000004 // float32
    torqueLimit = 0X000008 // float32
    bodyMassScale = 0X00000C // float32[2]
    isActive = 0X000014 // bool

 constraint_axislimit_t: [vphysics2.dll]
    flMinRotation = 0X000000 // float32
    flMaxRotation = 0X000004 // float32
    flMotorTargetAngSpeed = 0X000008 // float32
    flMotorMaxTorque = 0X00000C // float32

 constraint_hingeparams_t: [vphysics2.dll]
    worldPosition = 0X000000 // Vector
    worldAxisDirection = 0X00000C // Vector
    hingeAxis = 0X000018 // constraint_axislimit_t
    constraint = 0X000028 // constraint_breakableparams_t

 IPhysicsPlayerController: [vphysics2.dll]
    No schemes available

 CFeJiggleBone: [vphysics2.dll]
    m_nFlags = 0X000000 // uint32
    m_flLength = 0X000004 // float32
    m_flTipMass = 0X000008 // float32
    m_flYawStiffness = 0X00000C // float32
    m_flYawDamping = 0X000010 // float32
    m_flPitchStiffness = 0X000014 // float32
    m_flPitchDamping = 0X000018 // float32
    m_flAlongStiffness = 0X00001C // float32
    m_flAlongDamping = 0X000020 // float32
    m_flAngleLimit = 0X000024 // float32
    m_flMinYaw = 0X000028 // float32
    m_flMaxYaw = 0X00002C // float32
    m_flYawFriction = 0X000030 // float32
    m_flYawBounce = 0X000034 // float32
    m_flMinPitch = 0X000038 // float32
    m_flMaxPitch = 0X00003C // float32
    m_flPitchFriction = 0X000040 // float32
    m_flPitchBounce = 0X000044 // float32
    m_flBaseMass = 0X000048 // float32
    m_flBaseStiffness = 0X00004C // float32
    m_flBaseDamping = 0X000050 // float32
    m_flBaseMinLeft = 0X000054 // float32
    m_flBaseMaxLeft = 0X000058 // float32
    m_flBaseLeftFriction = 0X00005C // float32
    m_flBaseMinUp = 0X000060 // float32
    m_flBaseMaxUp = 0X000064 // float32
    m_flBaseUpFriction = 0X000068 // float32
    m_flBaseMinForward = 0X00006C // float32
    m_flBaseMaxForward = 0X000070 // float32
    m_flBaseForwardFriction = 0X000074 // float32
    m_flRadius0 = 0X000078 // float32
    m_flRadius1 = 0X00007C // float32
    m_vPoint0 = 0X000080 // Vector
    m_vPoint1 = 0X00008C // Vector
    m_nCollisionMask = 0X000098 // uint16

 CFeNamedJiggleBone: [vphysics2.dll]
    m_strParentBone = 0X000000 // CUtlString
    m_transform = 0X000010 // CTransform
    m_nJiggleParent = 0X000030 // uint32
    m_jiggleBone = 0X000034 // CFeJiggleBone

 CFeIndexedJiggleBone: [vphysics2.dll]
    m_nNode = 0X000000 // uint32
    m_nJiggleParent = 0X000004 // uint32
    m_jiggleBone = 0X000008 // CFeJiggleBone

 PhysFeModelDesc_t: [vphysics2.dll]
    m_CtrlHash = 0X000000 // CUtlVector< uint32 >
    m_CtrlName = 0X000018 // CUtlVector< CUtlString >
    m_nStaticNodeFlags = 0X000030 // uint32
    m_nDynamicNodeFlags = 0X000034 // uint32
    m_flLocalForce = 0X000038 // float32
    m_flLocalRotation = 0X00003C // float32
    m_nNodeCount = 0X000040 // uint16
    m_nStaticNodes = 0X000042 // uint16
    m_nRotLockStaticNodes = 0X000044 // uint16
    m_nFirstPositionDrivenNode = 0X000046 // uint16
    m_nSimdTriCount1 = 0X000048 // uint16
    m_nSimdTriCount2 = 0X00004A // uint16
    m_nSimdQuadCount1 = 0X00004C // uint16
    m_nSimdQuadCount2 = 0X00004E // uint16
    m_nQuadCount1 = 0X000050 // uint16
    m_nQuadCount2 = 0X000052 // uint16
    m_nCollisionSphereInclusiveCount = 0X000054 // uint16
    m_nTreeDepth = 0X000056 // uint16
    m_nNodeBaseJiggleboneDependsCount = 0X000058 // uint16
    m_nRopeCount = 0X00005A // uint16
    m_Ropes = 0X000060 // CUtlVector< uint16 >
    m_NodeBases = 0X000078 // CUtlVector< FeNodeBase_t >
    m_SimdNodeBases = 0X000090 // CUtlVector< FeSimdNodeBase_t >
    m_Quads = 0X0000A8 // CUtlVector< FeQuad_t >
    m_SimdQuads = 0X0000C0 // CUtlVector< FeSimdQuad_t >
    m_SimdTris = 0X0000D8 // CUtlVector< FeSimdTri_t >
    m_SimdRods = 0X0000F0 // CUtlVector< FeSimdRodConstraint_t >
    m_InitPose = 0X000108 // CUtlVector< CTransform >
    m_Rods = 0X000120 // CUtlVector< FeRodConstraint_t >
    m_Twists = 0X000138 // CUtlVector< FeTwistConstraint_t >
    m_AxialEdges = 0X000150 // CUtlVector< FeAxialEdgeBend_t >
    m_NodeInvMasses = 0X000168 // CUtlVector< float32 >
    m_CtrlOffsets = 0X000180 // CUtlVector< FeCtrlOffset_t >
    m_CtrlOsOffsets = 0X000198 // CUtlVector< FeCtrlOsOffset_t >
    m_FollowNodes = 0X0001B0 // CUtlVector< FeFollowNode_t >
    m_CollisionSpheres = 0X0001C8 // CUtlVector< FeCollisionSphere_t >
    m_CollisionPlanes = 0X0001E0 // CUtlVector< FeCollisionPlane_t >
    m_NodeIntegrator = 0X0001F8 // CUtlVector< FeNodeIntegrator_t >
    m_SpringIntegrator = 0X000210 // CUtlVector< FeSpringIntegrator_t >
    m_SimdSpringIntegrator = 0X000228 // CUtlVector< FeSimdSpringIntegrator_t >
    m_WorldCollisionParams = 0X000240 // CUtlVector< FeWorldCollisionParams_t >
    m_LegacyStretchForce = 0X000258 // CUtlVector< float32 >
    m_NodeCollisionRadii = 0X000270 // CUtlVector< float32 >
    m_DynNodeFriction = 0X000288 // CUtlVector< float32 >
    m_LocalRotation = 0X0002A0 // CUtlVector< float32 >
    m_LocalForce = 0X0002B8 // CUtlVector< float32 >
    m_TaperedCapsuleStretches = 0X0002D0 // CUtlVector< FeTaperedCapsuleStretch_t >
    m_TaperedCapsuleRigids = 0X0002E8 // CUtlVector< FeTaperedCapsuleRigid_t >
    m_SphereRigids = 0X000300 // CUtlVector< FeSphereRigid_t >
    m_WorldCollisionNodes = 0X000318 // CUtlVector< uint16 >
    m_TreeParents = 0X000330 // CUtlVector< uint16 >
    m_TreeCollisionMasks = 0X000348 // CUtlVector< uint16 >
    m_TreeChildren = 0X000360 // CUtlVector< FeTreeChildren_t >
    m_FreeNodes = 0X000378 // CUtlVector< uint16 >
    m_FitMatrices = 0X000390 // CUtlVector< FeFitMatrix_t >
    m_FitWeights = 0X0003A8 // CUtlVector< FeFitWeight_t >
    m_ReverseOffsets = 0X0003C0 // CUtlVector< FeNodeReverseOffset_t >
    m_AnimStrayRadii = 0X0003D8 // CUtlVector< FeAnimStrayRadius_t >
    m_SimdAnimStrayRadii = 0X0003F0 // CUtlVector< FeSimdAnimStrayRadius_t >
    m_KelagerBends = 0X000408 // CUtlVector< FeKelagerBend2_t >
    m_CtrlSoftOffsets = 0X000420 // CUtlVector< FeCtrlSoftOffset_t >
    m_JiggleBones = 0X000438 // CUtlVector< CFeIndexedJiggleBone >
    m_SourceElems = 0X000450 // CUtlVector< uint16 >
    m_GoalDampedSpringIntegrators = 0X000468 // CUtlVector< uint32 >
    m_Tris = 0X000480 // CUtlVector< FeTri_t >
    m_nTriCount1 = 0X000498 // uint16
    m_nTriCount2 = 0X00049A // uint16
    m_nReservedUint8 = 0X00049C // uint8
    m_nExtraPressureIterations = 0X00049D // uint8
    m_nExtraGoalIterations = 0X00049E // uint8
    m_nExtraIterations = 0X00049F // uint8
    m_BoxRigids = 0X0004A0 // CUtlVector< FeBoxRigid_t >
    m_DynNodeVertexSet = 0X0004B8 // CUtlVector< uint8 >
    m_VertexSetNames = 0X0004D0 // CUtlVector< uint32 >
    m_RigidColliderPriorities = 0X0004E8 // CUtlVector< FeRigidColliderIndices_t >
    m_MorphLayers = 0X000500 // CUtlVector< FeMorphLayerDepr_t >
    m_MorphSetData = 0X000518 // CUtlVector< uint8 >
    m_VertexMaps = 0X000530 // CUtlVector< FeVertexMapDesc_t >
    m_VertexMapValues = 0X000548 // CUtlVector< uint8 >
    m_Effects = 0X000560 // CUtlVector< FeEffectDesc_t >
    m_LockToParent = 0X000578 // CUtlVector< FeCtrlOffset_t >
    m_LockToGoal = 0X000590 // CUtlVector< uint16 >
    m_DynNodeWindBases = 0X0005A8 // CUtlVector< FeNodeWindBase_t >
    m_flInternalPressure = 0X0005C0 // float32
    m_flDefaultTimeDilation = 0X0005C4 // float32
    m_flWindage = 0X0005C8 // float32
    m_flWindDrag = 0X0005CC // float32
    m_flDefaultSurfaceStretch = 0X0005D0 // float32
    m_flDefaultThreadStretch = 0X0005D4 // float32
    m_flDefaultGravityScale = 0X0005D8 // float32
    m_flDefaultVelAirDrag = 0X0005DC // float32
    m_flDefaultExpAirDrag = 0X0005E0 // float32
    m_flDefaultVelQuadAirDrag = 0X0005E4 // float32
    m_flDefaultExpQuadAirDrag = 0X0005E8 // float32
    m_flRodVelocitySmoothRate = 0X0005EC // float32
    m_flQuadVelocitySmoothRate = 0X0005F0 // float32
    m_flAddWorldCollisionRadius = 0X0005F4 // float32
    m_flDefaultVolumetricSolveAmount = 0X0005F8 // float32
    m_nRodVelocitySmoothIterations = 0X0005FC // uint16
    m_nQuadVelocitySmoothIterations = 0X0005FE // uint16

 FourVectors2D: [vphysics2.dll]
    x = 0X000000 // fltx4
    y = 0X000010 // fltx4

 FeEdgeDesc_t: [vphysics2.dll]
    nEdge = 0X000000 // uint16[2]
    nSide = 0X000004 // uint16[2][2]
    nVirtElem = 0X00000C // uint16[2]

 OldFeEdge_t: [vphysics2.dll]
    m_flK = 0X000000 // float32[3]
    invA = 0X00000C // float32
    t = 0X000010 // float32
    flThetaRelaxed = 0X000014 // float32
    flThetaFactor = 0X000018 // float32
    c01 = 0X00001C // float32
    c02 = 0X000020 // float32
    c03 = 0X000024 // float32
    c04 = 0X000028 // float32
    flAxialModelDist = 0X00002C // float32
    flAxialModelWeights = 0X000030 // float32[4]
    m_nNode = 0X000040 // uint16[4]

 FeWeightedNode_t: [vphysics2.dll]
    nNode = 0X000000 // uint16
    nWeight = 0X000002 // uint16

 FeKelagerBend2_t: [vphysics2.dll]
    flWeight = 0X000000 // float32[3]
    flHeight0 = 0X00000C // float32
    nNode = 0X000010 // uint16[3]
    nReserved = 0X000016 // uint16

 FeStiffHingeBuild_t: [vphysics2.dll]
    flMaxAngle = 0X000000 // float32
    flStrength = 0X000004 // float32
    flMotionBias = 0X000008 // float32[3]
    nNode = 0X000014 // uint16[3]

 FeTri_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[3]
    w1 = 0X000008 // float32
    w2 = 0X00000C // float32
    v1x = 0X000010 // float32
    v2 = 0X000014 // Vector2D

 FeSimdTri_t: [vphysics2.dll]
    nNode = 0X000000 // uint32[4][3]
    w1 = 0X000030 // fltx4
    w2 = 0X000040 // fltx4
    v1x = 0X000050 // fltx4
    v2 = 0X000060 // FourVectors2D

 FeQuad_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[4]
    flSlack = 0X000008 // float32
    vShape = 0X00000C // Vector4D[4]

 FeNodeBase_t: [vphysics2.dll]
    nNode = 0X000000 // uint16
    nDummy = 0X000002 // uint16[3]
    nNodeX0 = 0X000008 // uint16
    nNodeX1 = 0X00000A // uint16
    nNodeY0 = 0X00000C // uint16
    nNodeY1 = 0X00000E // uint16
    qAdjust = 0X000010 // QuaternionStorage

 FeNodeWindBase_t: [vphysics2.dll]
    nNodeX0 = 0X000000 // uint16
    nNodeX1 = 0X000002 // uint16
    nNodeY0 = 0X000004 // uint16
    nNodeY1 = 0X000006 // uint16

 FeNodeReverseOffset_t: [vphysics2.dll]
    vOffset = 0X000000 // Vector
    nBoneCtrl = 0X00000C // uint16
    nTargetNode = 0X00000E // uint16

 FeSimdQuad_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[4][4]
    f4Slack = 0X000020 // fltx4
    vShape = 0X000030 // FourVectors[4]
    f4Weights = 0X0000F0 // fltx4[4]

 FeAxialEdgeBend_t: [vphysics2.dll]
    te = 0X000000 // float32
    tv = 0X000004 // float32
    flDist = 0X000008 // float32
    flWeight = 0X00000C // float32[4]
    nNode = 0X00001C // uint16[6]

 FeBandBendLimit_t: [vphysics2.dll]
    flDistMin = 0X000000 // float32
    flDistMax = 0X000004 // float32
    nNode = 0X000008 // uint16[6]

 FeRodConstraint_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[2]
    flMaxDist = 0X000004 // float32
    flMinDist = 0X000008 // float32
    flWeight0 = 0X00000C // float32
    flRelaxationFactor = 0X000010 // float32

 FeTwistConstraint_t: [vphysics2.dll]
    nNodeOrient = 0X000000 // uint16
    nNodeEnd = 0X000002 // uint16
    flTwistRelax = 0X000004 // float32
    flSwingRelax = 0X000008 // float32

 FeSimdRodConstraint_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[4][2]
    f4MaxDist = 0X000010 // fltx4
    f4MinDist = 0X000020 // fltx4
    f4Weight0 = 0X000030 // fltx4
    f4RelaxationFactor = 0X000040 // fltx4

 FeAnimStrayRadius_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[2]
    flMaxDist = 0X000004 // float32
    flRelaxationFactor = 0X000008 // float32

 FeSimdAnimStrayRadius_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[4][2]
    flMaxDist = 0X000010 // fltx4
    flRelaxationFactor = 0X000020 // fltx4

 FeSimdNodeBase_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[4]
    nNodeX0 = 0X000008 // uint16[4]
    nNodeX1 = 0X000010 // uint16[4]
    nNodeY0 = 0X000018 // uint16[4]
    nNodeY1 = 0X000020 // uint16[4]
    nDummy = 0X000028 // uint16[4]
    qAdjust = 0X000030 // FourQuaternions

 FeNodeIntegrator_t: [vphysics2.dll]
    flPointDamping = 0X000000 // float32
    flAnimationForceAttraction = 0X000004 // float32
    flAnimationVertexAttraction = 0X000008 // float32
    flGravity = 0X00000C // float32

 FeSpringIntegrator_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[2]
    flSpringRestLength = 0X000004 // float32
    flSpringConstant = 0X000008 // float32
    flSpringDamping = 0X00000C // float32
    flNodeWeight0 = 0X000010 // float32

 FeSimdSpringIntegrator_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[4][2]
    flSpringRestLength = 0X000010 // fltx4
    flSpringConstant = 0X000020 // fltx4
    flSpringDamping = 0X000030 // fltx4
    flNodeWeight0 = 0X000040 // fltx4

 FeCtrlOffset_t: [vphysics2.dll]
    vOffset = 0X000000 // Vector
    nCtrlParent = 0X00000C // uint16
    nCtrlChild = 0X00000E // uint16

 FeSoftParent_t: [vphysics2.dll]
    nParent = 0X000000 // int32
    flAlpha = 0X000004 // float32

 FeCtrlSoftOffset_t: [vphysics2.dll]
    nCtrlParent = 0X000000 // uint16
    nCtrlChild = 0X000002 // uint16
    vOffset = 0X000004 // Vector
    flAlpha = 0X000010 // float32

 FeCtrlOsOffset_t: [vphysics2.dll]
    nCtrlParent = 0X000000 // uint16
    nCtrlChild = 0X000002 // uint16

 FeFollowNode_t: [vphysics2.dll]
    nParentNode = 0X000000 // uint16
    nChildNode = 0X000002 // uint16
    flWeight = 0X000004 // float32

 FeCollisionSphere_t: [vphysics2.dll]
    nCtrlParent = 0X000000 // uint16
    nChildNode = 0X000002 // uint16
    m_flRFactor = 0X000004 // float32
    m_vOrigin = 0X000008 // Vector
    flStickiness = 0X000014 // float32

 FeCollisionPlane_t: [vphysics2.dll]
    nCtrlParent = 0X000000 // uint16
    nChildNode = 0X000002 // uint16
    m_Plane = 0X000004 // RnPlane_t
    flStickiness = 0X000014 // float32
    flStrength = 0X000018 // float32

 FeWorldCollisionParams_t: [vphysics2.dll]
    flWorldFriction = 0X000000 // float32
    flGroundFriction = 0X000004 // float32
    nListBegin = 0X000008 // uint16
    nListEnd = 0X00000A // uint16

 FeTreeChildren_t: [vphysics2.dll]
    nChild = 0X000000 // uint16[2]

 FeTaperedCapsuleRigid_t: [vphysics2.dll]
    vSphere = 0X000000 // fltx4[2]
    flStickiness = 0X000020 // float32
    nNode = 0X000024 // uint16
    nCollisionMask = 0X000026 // uint16
    nVertexMapIndex = 0X000028 // uint16
    nFlags = 0X00002A // uint16

 FeSphereRigid_t: [vphysics2.dll]
    vSphere = 0X000000 // fltx4
    flStickiness = 0X000010 // float32
    nNode = 0X000014 // uint16
    nCollisionMask = 0X000016 // uint16
    nVertexMapIndex = 0X000018 // uint16
    nFlags = 0X00001A // uint16

 FeTaperedCapsuleStretch_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[2]
    nCollisionMask = 0X000004 // uint16
    nDummy = 0X000006 // uint16
    flRadius = 0X000008 // float32[2]
    flStickiness = 0X000010 // float32

 FeBoxRigid_t: [vphysics2.dll]
    tmFrame2 = 0X000000 // CTransform
    nNode = 0X000020 // uint16
    nCollisionMask = 0X000022 // uint16
    vSize = 0X000024 // Vector
    flStickiness = 0X000030 // float32
    nVertexMapIndex = 0X000034 // uint16
    nFlags = 0X000036 // uint16
    flReserved = 0X000038 // float32[2]

 CovMatrix3: [vphysics2.dll]
    m_vDiag = 0X000000 // Vector
    m_flXY = 0X00000C // float32
    m_flXZ = 0X000010 // float32
    m_flYZ = 0X000014 // float32

 FourCovMatrices3: [vphysics2.dll]
    m_vDiag = 0X000000 // FourVectors
    m_flXY = 0X000030 // fltx4
    m_flXZ = 0X000040 // fltx4
    m_flYZ = 0X000050 // fltx4

 FeFitWeight_t: [vphysics2.dll]
    flWeight = 0X000000 // float32
    nNode = 0X000004 // uint16
    nDummy = 0X000006 // uint16

 FeFitInfluence_t: [vphysics2.dll]
    nVertexNode = 0X000000 // uint32
    flWeight = 0X000004 // float32
    nMatrixNode = 0X000008 // uint32

 FeFitMatrix_t: [vphysics2.dll]
    bone = 0X000000 // CTransform
    vCenter = 0X000020 // Vector
    nEnd = 0X00002C // uint16
    nNode = 0X00002E // uint16
    nBeginDynamic = 0X000030 // uint16

 FeRigidColliderIndices_t: [vphysics2.dll]
    m_nTaperedCapsuleRigidIndex = 0X000000 // uint16
    m_nSphereRigidIndex = 0X000002 // uint16
    m_nBoxRigidIndex = 0X000004 // uint16
    m_nCollisionSphereIndex = 0X000006 // uint16[2]
    m_nCollisionPlaneIndex = 0X00000A // uint16

 FeBuildTaperedCapsuleRigid_t: [vphysics2.dll]
    m_nPriority = 0X000030 // int32
    m_nVertexMapHash = 0X000034 // uint32

 FeBuildBoxRigid_t: [vphysics2.dll]
    m_nPriority = 0X000040 // int32
    m_nVertexMapHash = 0X000044 // uint32

 FeBuildSphereRigid_t: [vphysics2.dll]
    m_nPriority = 0X000020 // int32
    m_nVertexMapHash = 0X000024 // uint32

 FeSourceEdge_t: [vphysics2.dll]
    nNode = 0X000000 // uint16[2]

 FeEffectDesc_t: [vphysics2.dll]
    sName = 0X000000 // CUtlString
    nNameHash = 0X000008 // uint32
    nType = 0X00000C // int32
    m_Params = 0X000010 // KeyValues3

 FeVertexMapBuild_t: [vphysics2.dll]
    m_VertexMapName = 0X000000 // CUtlString
    m_nNameHash = 0X000008 // uint32
    m_Color = 0X00000C // Color
    m_flVolumetricSolveStrength = 0X000010 // float32
    m_nScaleSourceNode = 0X000014 // int32
    m_Weights = 0X000018 // CUtlVector< float32 >

 CFeVertexMapBuildArray: [vphysics2.dll]
    m_Array = 0X000000 // CUtlVector< FeVertexMapBuild_t* >

 FeProxyVertexMap_t: [vphysics2.dll]
    m_Name = 0X000000 // CUtlString
    m_flWeight = 0X000008 // float32

 FeVertexMapDesc_t: [vphysics2.dll]
    sName = 0X000000 // CUtlString
    nNameHash = 0X000008 // uint32
    nColor = 0X00000C // uint32
    nFlags = 0X000010 // uint32
    nVertexBase = 0X000014 // uint16
    nVertexCount = 0X000016 // uint16
    nMapOffset = 0X000018 // uint32
    nNodeListOffset = 0X00001C // uint32
    vCenterOfMass = 0X000020 // Vector
    flVolumetricSolveStrength = 0X00002C // float32
    nScaleSourceNode = 0X000030 // int16
    nNodeListCount = 0X000032 // uint16

 FeMorphLayerDepr_t: [vphysics2.dll]
    m_Name = 0X000000 // CUtlString
    m_nNameHash = 0X000008 // uint32
    m_Nodes = 0X000010 // CUtlVector< uint16 >
    m_InitPos = 0X000028 // CUtlVector< Vector >
    m_Gravity = 0X000040 // CUtlVector< float32 >
    m_GoalStrength = 0X000058 // CUtlVector< float32 >
    m_GoalDamping = 0X000070 // CUtlVector< float32 >
    m_nFlags = 0X000088 // uint32

 CFeMorphLayer: [vphysics2.dll]
    m_Name = 0X000000 // CUtlString
    m_nNameHash = 0X000008 // uint32
    m_Nodes = 0X000010 // CUtlVector< uint16 >
    m_InitPos = 0X000028 // CUtlVector< Vector >
    m_Gravity = 0X000040 // CUtlVector< float32 >
    m_GoalStrength = 0X000058 // CUtlVector< float32 >
    m_GoalDamping = 0X000070 // CUtlVector< float32 >

 Dop26_t: [vphysics2.dll]
    m_flSupport = 0X000000 // float32[26]

 RnSphere_t: [vphysics2.dll]
    m_vCenter = 0X000000 // Vector
    m_flRadius = 0X00000C // float32

 RnCapsule_t: [vphysics2.dll]
    m_vCenter = 0X000000 // Vector[2]
    m_flRadius = 0X000018 // float32

 RnPlane_t: [vphysics2.dll]
    m_vNormal = 0X000000 // Vector
    m_flOffset = 0X00000C // float32

 RnHalfEdge_t: [vphysics2.dll]
    m_nNext = 0X000000 // uint8
    m_nTwin = 0X000001 // uint8
    m_nOrigin = 0X000002 // uint8
    m_nFace = 0X000003 // uint8

 RnFace_t: [vphysics2.dll]
    m_nEdge = 0X000000 // uint8

 CRegionSVM: [vphysics2.dll]
    m_Planes = 0X000000 // CUtlVector< RnPlane_t >
    m_Nodes = 0X000018 // CUtlVector< uint32 >

 RnHull_t: [vphysics2.dll]
    m_vCentroid = 0X000000 // Vector
    m_flMaxAngularRadius = 0X00000C // float32
    m_Bounds = 0X000010 // AABB_t
    m_vOrthographicAreas = 0X000028 // Vector
    m_MassProperties = 0X000034 // matrix3x4_t
    m_flVolume = 0X000064 // float32
    m_Vertices = 0X000068 // CUtlVector< Vector >
    m_Edges = 0X000080 // CUtlVector< RnHalfEdge_t >
    m_Faces = 0X000098 // CUtlVector< RnFace_t >
    m_Planes = 0X0000B0 // CUtlVector< RnPlane_t >
    m_nFlags = 0X0000C8 // uint32
    m_pRegionSVM = 0X0000D0 // CRegionSVM*

 RnTriangle_t: [vphysics2.dll]
    m_nIndex = 0X000000 // int32[3]

 RnWing_t: [vphysics2.dll]
    m_nIndex = 0X000000 // int32[3]

 RnNode_t: [vphysics2.dll]
    m_vMin = 0X000000 // Vector
    m_nChildren = 0X00000C // uint32
    m_vMax = 0X000010 // Vector
    m_nTriangleOffset = 0X00001C // uint32

 RnMesh_t: [vphysics2.dll]
    m_vMin = 0X000000 // Vector
    m_vMax = 0X00000C // Vector
    m_Nodes = 0X000018 // CUtlVector< RnNode_t >
    m_Vertices = 0X000030 // CUtlVectorSIMDPaddedVector
    m_Triangles = 0X000048 // CUtlVector< RnTriangle_t >
    m_Wings = 0X000060 // CUtlVector< RnWing_t >
    m_Materials = 0X000078 // CUtlVector< uint8 >
    m_vOrthographicAreas = 0X000090 // Vector

 RnShapeDesc_t: [vphysics2.dll]
    m_nCollisionAttributeIndex = 0X000000 // uint32
    m_nSurfacePropertyIndex = 0X000004 // uint32
    m_UserFriendlyName = 0X000008 // CUtlString

 RnSphereDesc_t: [vphysics2.dll]
    m_Sphere = 0X000010 // RnSphere_t

 RnCapsuleDesc_t: [vphysics2.dll]
    m_Capsule = 0X000010 // RnCapsule_t

 RnHullDesc_t: [vphysics2.dll]
    m_Hull = 0X000010 // RnHull_t

 RnMeshDesc_t: [vphysics2.dll]
    m_Mesh = 0X000010 // RnMesh_t

 RnSoftbodyParticle_t: [vphysics2.dll]
    m_flMassInv = 0X000000 // float32

 RnSoftbodySpring_t: [vphysics2.dll]
    m_nParticle = 0X000000 // uint16[2]
    m_flLength = 0X000004 // float32

 RnSoftbodyCapsule_t: [vphysics2.dll]
    m_vCenter = 0X000000 // Vector[2]
    m_flRadius = 0X000018 // float32
    m_nParticle = 0X00001C // uint16[2]

 RnBlendVertex_t: [vphysics2.dll]
    m_nWeight0 = 0X000000 // uint16
    m_nIndex0 = 0X000002 // uint16
    m_nWeight1 = 0X000004 // uint16
    m_nIndex1 = 0X000006 // uint16
    m_nWeight2 = 0X000008 // uint16
    m_nIndex2 = 0X00000A // uint16
    m_nFlags = 0X00000C // uint16
    m_nTargetIndex = 0X00000E // uint16

 CastSphereSATParams_t: [vphysics2.dll]
    m_vRayStart = 0X000000 // Vector
    m_vRayDelta = 0X00000C // Vector
    m_flRadius = 0X000018 // float32
    m_flMaxFraction = 0X00001C // float32
    m_flScale = 0X000020 // float32
    m_pHull = 0X000028 // RnHull_t*

 VertexPositionNormal_t: [vphysics2.dll]
    m_vPosition = 0X000000 // Vector
    m_vNormal = 0X00000C // Vector

 VertexPositionColor_t: [vphysics2.dll]
    m_vPosition = 0X000000 // Vector


meshsystem.dll:
  No schemes classes available | meshsystem.dll


soundsystem.dll:
 CSosGroupActionSchema: [soundsystem.dll]
    m_name = 0X000008 // CUtlString
    m_actionType = 0X000010 // ActionType_t
    m_actionInstanceType = 0X000014 // ActionType_t

 CSosGroupActionLimitSchema: [soundsystem.dll]
    m_nMaxCount = 0X000018 // int32
    m_nStopType = 0X00001C // SosActionStopType_t
    m_nSortType = 0X000020 // SosActionSortType_t

 CSosGroupActionTimeLimitSchema: [soundsystem.dll]
    m_flMaxDuration = 0X000018 // float32

 CSosGroupBranchPattern: [soundsystem.dll]
    m_bMatchEventName = 0X000008 // bool
    m_bMatchEventSubString = 0X000009 // bool
    m_bMatchEntIndex = 0X00000A // bool
    m_bMatchOpvar = 0X00000B // bool

 CSosGroupMatchPattern: [soundsystem.dll]
    m_matchSoundEventName = 0X000010 // CUtlString
    m_matchSoundEventSubString = 0X000018 // CUtlString
    m_flEntIndex = 0X000020 // float32
    m_flOpvar = 0X000024 // float32

 CSosSoundEventGroupSchema: [soundsystem.dll]
    m_name = 0X000000 // CUtlString
    m_nType = 0X000008 // SosGroupType_t
    m_bIsBlocking = 0X00000C // bool
    m_nBlockMaxCount = 0X000010 // int32
    m_bInvertMatch = 0X000014 // bool
    m_matchPattern = 0X000018 // CSosGroupMatchPattern
    m_branchPattern = 0X000040 // CSosGroupBranchPattern
    m_vActions = 0X0000B0 // CSosGroupActionSchema*[4]

 CSosSoundEventGroupListSchema: [soundsystem.dll]
    m_groupList = 0X000000 // CUtlVector< CSosSoundEventGroupSchema >

 SosEditItemInfo_t: [soundsystem.dll]
    itemType = 0X000000 // SosEditItemType_t
    itemName = 0X000008 // CUtlString
    itemTypeName = 0X000010 // CUtlString
    itemKVString = 0X000020 // CUtlString
    itemPos = 0X000028 // Vector2D

 SelectedEditItemInfo_t: [soundsystem.dll]
    m_EditItems = 0X000000 // CUtlVector< SosEditItemInfo_t >

 CSoundEventMetaData: [soundsystem.dll]
    m_soundEventVMix = 0X000000 // CStrongHandle< InfoForResourceTypeCVMixListResource >

 CDSPMixgroupModifier: [soundsystem.dll]
    m_mixgroup = 0X000000 // CUtlString
    m_flModifier = 0X000008 // float32
    m_flModifierMin = 0X00000C // float32
    m_flSourceModifier = 0X000010 // float32
    m_flSourceModifierMin = 0X000014 // float32
    m_flListenerReverbModifierWhenSourceReverbIsActive = 0X000018 // float32

 CDspPresetModifierList: [soundsystem.dll]
    m_dspName = 0X000000 // CUtlString
    m_modifiers = 0X000008 // CUtlVector< CDSPMixgroupModifier >

 CDSPPresetMixgroupModifierTable: [soundsystem.dll]
    m_table = 0X000000 // CUtlVector< CDspPresetModifierList >

 VMixFilterDesc_t: [soundsystem.dll]
    m_nFilterType = 0X000000 // VMixFilterType_t
    m_nFilterSlope = 0X000002 // VMixFilterSlope_t
    m_bEnabled = 0X000003 // bool
    m_fldbGain = 0X000004 // float32
    m_flCutoffFreq = 0X000008 // float32
    m_flQ = 0X00000C // float32

 VMixEQ8Desc_t: [soundsystem.dll]
    m_stages = 0X000000 // VMixFilterDesc_t[8]

 VMixDelayDesc_t: [soundsystem.dll]
    m_feedbackFilter = 0X000000 // VMixFilterDesc_t
    m_bEnableFilter = 0X000010 // bool
    m_flDelay = 0X000014 // float32
    m_flDirectGain = 0X000018 // float32
    m_flDelayGain = 0X00001C // float32
    m_flFeedbackGain = 0X000020 // float32
    m_flWidth = 0X000024 // float32

 VMixPannerDesc_t: [soundsystem.dll]
    m_type = 0X000000 // VMixPannerType_t
    m_flStrength = 0X000004 // float32

 VMixModDelayDesc_t: [soundsystem.dll]
    m_feedbackFilter = 0X000000 // VMixFilterDesc_t
    m_bPhaseInvert = 0X000010 // bool
    m_flGlideTime = 0X000014 // float32
    m_flDelay = 0X000018 // float32
    m_flOutputGain = 0X00001C // float32
    m_flFeedbackGain = 0X000020 // float32
    m_flModRate = 0X000024 // float32
    m_flModDepth = 0X000028 // float32
    m_bApplyAntialiasing = 0X00002C // bool

 VMixDiffusorDesc_t: [soundsystem.dll]
    m_flSize = 0X000000 // float32
    m_flComplexity = 0X000004 // float32
    m_flFeedback = 0X000008 // float32
    m_flOutputGain = 0X00000C // float32

 VMixBoxverbDesc_t: [soundsystem.dll]
    m_flSizeMax = 0X000000 // float32
    m_flSizeMin = 0X000004 // float32
    m_flComplexity = 0X000008 // float32
    m_flDiffusion = 0X00000C // float32
    m_flModDepth = 0X000010 // float32
    m_flModRate = 0X000014 // float32
    m_bParallel = 0X000018 // bool
    m_filterType = 0X00001C // VMixFilterDesc_t
    m_flWidth = 0X00002C // float32
    m_flHeight = 0X000030 // float32
    m_flDepth = 0X000034 // float32
    m_flFeedbackScale = 0X000038 // float32
    m_flFeedbackWidth = 0X00003C // float32
    m_flFeedbackHeight = 0X000040 // float32
    m_flFeedbackDepth = 0X000044 // float32
    m_flOutputGain = 0X000048 // float32
    m_flTaps = 0X00004C // float32

 VMixFreeverbDesc_t: [soundsystem.dll]
    m_flRoomSize = 0X000000 // float32
    m_flDamp = 0X000004 // float32
    m_flWidth = 0X000008 // float32
    m_flLateReflections = 0X00000C // float32

 VMixPlateverbDesc_t: [soundsystem.dll]
    m_flPrefilter = 0X000000 // float32
    m_flInputDiffusion1 = 0X000004 // float32
    m_flInputDiffusion2 = 0X000008 // float32
    m_flDecay = 0X00000C // float32
    m_flDamp = 0X000010 // float32
    m_flFeedbackDiffusion1 = 0X000014 // float32
    m_flFeedbackDiffusion2 = 0X000018 // float32

 VMixDynamicsDesc_t: [soundsystem.dll]
    m_fldbGain = 0X000000 // float32
    m_fldbNoiseGateThreshold = 0X000004 // float32
    m_fldbCompressionThreshold = 0X000008 // float32
    m_fldbLimiterThreshold = 0X00000C // float32
    m_fldbKneeWidth = 0X000010 // float32
    m_flRatio = 0X000014 // float32
    m_flLimiterRatio = 0X000018 // float32
    m_flAttackTimeMS = 0X00001C // float32
    m_flReleaseTimeMS = 0X000020 // float32
    m_flRMSTimeMS = 0X000024 // float32
    m_flWetMix = 0X000028 // float32
    m_bPeakMode = 0X00002C // bool

 VMixDynamicsCompressorDesc_t: [soundsystem.dll]
    m_fldbOutputGain = 0X000000 // float32
    m_fldbCompressionThreshold = 0X000004 // float32
    m_fldbKneeWidth = 0X000008 // float32
    m_flCompressionRatio = 0X00000C // float32
    m_flAttackTimeMS = 0X000010 // float32
    m_flReleaseTimeMS = 0X000014 // float32
    m_flRMSTimeMS = 0X000018 // float32
    m_flWetMix = 0X00001C // float32
    m_bPeakMode = 0X000020 // bool

 VMixDynamicsBand_t: [soundsystem.dll]
    m_fldbGainInput = 0X000000 // float32
    m_fldbGainOutput = 0X000004 // float32
    m_fldbThresholdBelow = 0X000008 // float32
    m_fldbThresholdAbove = 0X00000C // float32
    m_flRatioBelow = 0X000010 // float32
    m_flRatioAbove = 0X000014 // float32
    m_flAttackTimeMS = 0X000018 // float32
    m_flReleaseTimeMS = 0X00001C // float32
    m_bEnable = 0X000020 // bool
    m_bSolo = 0X000021 // bool

 VMixDynamics3BandDesc_t: [soundsystem.dll]
    m_fldbGainOutput = 0X000000 // float32
    m_flRMSTimeMS = 0X000004 // float32
    m_fldbKneeWidth = 0X000008 // float32
    m_flDepth = 0X00000C // float32
    m_flWetMix = 0X000010 // float32
    m_flTimeScale = 0X000014 // float32
    m_flLowCutoffFreq = 0X000018 // float32
    m_flHighCutoffFreq = 0X00001C // float32
    m_bPeakMode = 0X000020 // bool
    m_bandDesc = 0X000024 // VMixDynamicsBand_t[3]

 VMixEnvelopeDesc_t: [soundsystem.dll]
    m_flAttackTimeMS = 0X000000 // float32
    m_flHoldTimeMS = 0X000004 // float32
    m_flReleaseTimeMS = 0X000008 // float32

 VMixPitchShiftDesc_t: [soundsystem.dll]
    m_nGrainSampleCount = 0X000000 // int32
    m_flPitchShift = 0X000004 // float32
    m_nQuality = 0X000008 // int32
    m_nProcType = 0X00000C // int32

 VMixConvolutionDesc_t: [soundsystem.dll]
    m_fldbGain = 0X000000 // float32
    m_flPreDelayMS = 0X000004 // float32
    m_flWetMix = 0X000008 // float32
    m_fldbLow = 0X00000C // float32
    m_fldbMid = 0X000010 // float32
    m_fldbHigh = 0X000014 // float32
    m_flLowCutoffFreq = 0X000018 // float32
    m_flHighCutoffFreq = 0X00001C // float32

 VMixVocoderDesc_t: [soundsystem.dll]
    m_nBandCount = 0X000000 // int32
    m_flBandwidth = 0X000004 // float32
    m_fldBModGain = 0X000008 // float32
    m_flFreqRangeStart = 0X00000C // float32
    m_flFreqRangeEnd = 0X000010 // float32
    m_fldBUnvoicedGain = 0X000014 // float32
    m_flAttackTimeMS = 0X000018 // float32
    m_flReleaseTimeMS = 0X00001C // float32
    m_nDebugBand = 0X000020 // int32
    m_bPeakMode = 0X000024 // bool

 VMixShaperDesc_t: [soundsystem.dll]
    m_nShape = 0X000000 // int32
    m_fldbDrive = 0X000004 // float32
    m_fldbOutputGain = 0X000008 // float32
    m_flWetMix = 0X00000C // float32
    m_nOversampleFactor = 0X000010 // int32

 VMixUtilityDesc_t: [soundsystem.dll]
    m_nOp = 0X000000 // VMixChannelOperation_t
    m_flInputPan = 0X000004 // float32
    m_flOutputBalance = 0X000008 // float32
    m_fldbOutputGain = 0X00000C // float32
    m_bBassMono = 0X000010 // bool
    m_flBassFreq = 0X000014 // float32

 VMixAutoFilterDesc_t: [soundsystem.dll]
    m_flEnvelopeAmount = 0X000000 // float32
    m_flAttackTimeMS = 0X000004 // float32
    m_flReleaseTimeMS = 0X000008 // float32
    m_filter = 0X00000C // VMixFilterDesc_t
    m_flLFOAmount = 0X00001C // float32
    m_flLFORate = 0X000020 // float32
    m_flPhase = 0X000024 // float32
    m_nLFOShape = 0X000028 // VMixLFOShape_t

 VMixOscDesc_t: [soundsystem.dll]
    oscType = 0X000000 // VMixLFOShape_t
    m_freq = 0X000004 // float32
    m_flPhase = 0X000008 // float32

 VMixEffectChainDesc_t: [soundsystem.dll]
    m_flCrossfadeTime = 0X000000 // float32

 VMixSubgraphSwitchDesc_t: [soundsystem.dll]
    m_interpolationMode = 0X000000 // VMixSubgraphSwitchInterpolationType_t
    m_bOnlyTailsOnFadeOut = 0X000004 // bool
    m_flInterpolationTime = 0X000008 // float32


scenesystem.dll:
 CSSDSEndFrameViewInfo: [scenesystem.dll]
    m_nViewId = 0X000000 // uint64
    m_ViewName = 0X000008 // CUtlString

 CSSDSMsg_EndFrame: [scenesystem.dll]
    m_Views = 0X000000 // CUtlVector< CSSDSEndFrameViewInfo >

 SceneViewId_t: [scenesystem.dll]
    m_nViewId = 0X000000 // uint64
    m_nFrameCount = 0X000008 // uint64

 CSSDSMsg_ViewRender: [scenesystem.dll]
    m_viewId = 0X000000 // SceneViewId_t
    m_ViewName = 0X000010 // CUtlString

 CSSDSMsg_LayerBase: [scenesystem.dll]
    m_viewId = 0X000000 // SceneViewId_t
    m_ViewName = 0X000010 // CUtlString
    m_nLayerIndex = 0X000018 // int32
    m_nLayerId = 0X000020 // uint64
    m_LayerName = 0X000028 // CUtlString
    m_displayText = 0X000030 // CUtlString

 CSSDSMsg_ViewTarget: [scenesystem.dll]
    m_Name = 0X000000 // CUtlString
    m_TextureId = 0X000008 // uint64
    m_nWidth = 0X000010 // int32
    m_nHeight = 0X000014 // int32
    m_nRequestedWidth = 0X000018 // int32
    m_nRequestedHeight = 0X00001C // int32
    m_nNumMipLevels = 0X000020 // int32
    m_nDepth = 0X000024 // int32
    m_nMultisampleNumSamples = 0X000028 // int32
    m_nFormat = 0X00002C // int32

 CSSDSMsg_ViewTargetList: [scenesystem.dll]
    m_viewId = 0X000000 // SceneViewId_t
    m_ViewName = 0X000010 // CUtlString
    m_Targets = 0X000018 // CUtlVector< CSSDSMsg_ViewTarget >

 CSSDSMsg_PreLayer: [scenesystem.dll]
    No schemes available

 CSSDSMsg_PostLayer: [scenesystem.dll]
    No schemes available


worldrenderer.dll:
 EntityIOConnectionData_t: [worldrenderer.dll]
    m_outputName = 0X000000 // CUtlString
    m_targetType = 0X000008 // uint32
    m_targetName = 0X000010 // CUtlString
    m_inputName = 0X000018 // CUtlString
    m_overrideParam = 0X000020 // CUtlString
    m_flDelay = 0X000028 // float32
    m_nTimesToFire = 0X00002C // int32

 EntityKeyValueData_t: [worldrenderer.dll]
    m_keyValuesData = 0X000000 // CUtlBinaryBlock
    m_connections = 0X000018 // CUtlVector< EntityIOConnectionData_t >

 PermEntityLumpData_t: [worldrenderer.dll]
    m_name = 0X000000 // CUtlString
    m_hammerUniqueId = 0X000008 // CUtlString
    m_childLumps = 0X000010 // CUtlVector< CStrongHandleCopyable< InfoForResourceTypeCEntityLump > >
    m_entityKeyValues = 0X000028 // CUtlVector< EntityKeyValueData_t >

 SceneObject_t: [worldrenderer.dll]
    m_nObjectID = 0X000000 // uint32
    m_vTransform = 0X000004 // Vector4D[3]
    m_flFadeStartDistance = 0X000034 // float32
    m_flFadeEndDistance = 0X000038 // float32
    m_vTintColor = 0X00003C // Vector4D
    m_skin = 0X000050 // CUtlString
    m_nObjectTypeFlags = 0X000058 // ObjectTypeFlags_t
    m_vLightingOrigin = 0X00005C // Vector
    m_nLightGroup = 0X000068 // uint32
    m_nOverlayRenderOrder = 0X00006C // int16
    m_nLODOverride = 0X00006E // int16
    m_nCubeMapPrecomputedHandshake = 0X000070 // int32
    m_nLightProbeVolumePrecomputedHandshake = 0X000074 // int32
    m_renderableModel = 0X000080 // CStrongHandle< InfoForResourceTypeCModel >
    m_renderable = 0X000088 // CStrongHandle< InfoForResourceTypeCRenderMesh >

 BaseSceneObjectOverride_t: [worldrenderer.dll]
    m_nSceneObjectIndex = 0X000000 // uint32

 ExtraVertexStreamOverride_t: [worldrenderer.dll]
    m_nSubSceneObject = 0X000004 // uint32
    m_nDrawCallIndex = 0X000008 // uint32
    m_nAdditionalMeshDrawPrimitiveFlags = 0X00000C // MeshDrawPrimitiveFlags_t
    m_extraBufferBinding = 0X000010 // CRenderBufferBinding

 MaterialOverride_t: [worldrenderer.dll]
    m_nSubSceneObject = 0X000004 // uint32
    m_nDrawCallIndex = 0X000008 // uint32
    m_pMaterial = 0X000010 // CStrongHandle< InfoForResourceTypeIMaterial2 >

 InfoOverlayData_t: [worldrenderer.dll]
    m_transform = 0X000000 // matrix3x4_t
    m_flWidth = 0X000030 // float32
    m_flHeight = 0X000034 // float32
    m_flDepth = 0X000038 // float32
    m_vUVStart = 0X00003C // Vector2D
    m_vUVEnd = 0X000044 // Vector2D
    m_pMaterial = 0X000050 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_nRenderOrder = 0X000058 // int32
    m_vTintColor = 0X00005C // Vector4D
    m_nSequenceOverride = 0X00006C // int32

 BakedLightingInfo_t: [worldrenderer.dll]
    m_nLightmapVersionNumber = 0X000000 // uint32
    m_nLightmapGameVersionNumber = 0X000004 // uint32
    m_vLightmapUvScale = 0X000008 // Vector2D
    m_bHasLightmaps = 0X000010 // bool
    m_lightMaps = 0X000018 // CUtlVector< CStrongHandle< InfoForResourceTypeCTextureBase > >

 WorldNodeOnDiskBufferData_t: [worldrenderer.dll]
    m_nElementCount = 0X000000 // int32
    m_nElementSizeInBytes = 0X000004 // int32
    m_inputLayoutFields = 0X000008 // CUtlVector< RenderInputLayoutField_t >
    m_pData = 0X000020 // CUtlVector< uint8 >

 AggregateMeshInfo_t: [worldrenderer.dll]
    m_nVisClusterMemberOffset = 0X000000 // uint32
    m_nVisClusterMemberCount = 0X000004 // uint8
    m_bHasTransform = 0X000005 // bool
    m_nDrawCallIndex = 0X000006 // int16
    m_nLODSetupIndex = 0X000008 // int16
    m_nLODGroupMask = 0X00000A // uint8
    m_vTintColor = 0X00000B // Color
    m_objectFlags = 0X000010 // ObjectTypeFlags_t
    m_nLightProbeVolumePrecomputedHandshake = 0X000014 // int32
    m_vLODOrigin = 0X000018 // Vector
    m_fLODStartDrawDistance = 0X000024 // float32
    m_fLODEndDrawDistance = 0X000028 // float32
    m_fMaxObjectScale = 0X00002C // float32

 AggregateLODSetup_t: [worldrenderer.dll]
    m_vLODOrigin = 0X000000 // Vector
    m_fMaxObjectScale = 0X00000C // float32
    m_nLODMask = 0X000010 // uint8
    m_fSwitchDistances = 0X000018 // CUtlVectorFixedGrowable< float32 >

 AggregateSceneObject_t: [worldrenderer.dll]
    m_allFlags = 0X000000 // ObjectTypeFlags_t
    m_anyFlags = 0X000004 // ObjectTypeFlags_t
    m_nLayer = 0X000008 // int16
    m_aggregateMeshes = 0X000010 // CUtlVector< AggregateMeshInfo_t >
    m_lodSetups = 0X000028 // CUtlVector< AggregateLODSetup_t >
    m_visClusterMembership = 0X000040 // CUtlVector< uint16 >
    m_fragmentTransforms = 0X000058 // CUtlVector< matrix3x4_t >
    m_renderableModel = 0X000070 // CStrongHandle< InfoForResourceTypeCModel >

 WorldNode_t: [worldrenderer.dll]
    m_sceneObjects = 0X000000 // CUtlVector< SceneObject_t >
    m_infoOverlays = 0X000018 // CUtlVector< InfoOverlayData_t >
    m_visClusterMembership = 0X000030 // CUtlVector< uint16 >
    m_aggregateSceneObjects = 0X000048 // CUtlVector< AggregateSceneObject_t >
    m_extraVertexStreamOverrides = 0X000060 // CUtlVector< ExtraVertexStreamOverride_t >
    m_materialOverrides = 0X000078 // CUtlVector< MaterialOverride_t >
    m_extraVertexStreams = 0X000090 // CUtlVector< WorldNodeOnDiskBufferData_t >
    m_layerNames = 0X0000A8 // CUtlVector< CUtlString >
    m_sceneObjectLayerIndices = 0X0000C0 // CUtlVector< uint8 >
    m_overlayLayerIndices = 0X0000D8 // CUtlVector< uint8 >
    m_grassFileName = 0X0000F0 // CUtlString
    m_nodeLightingInfo = 0X0000F8 // BakedLightingInfo_t

 WorldBuilderParams_t: [worldrenderer.dll]
    m_flMinDrawVolumeSize = 0X000000 // float32
    m_bBuildBakedLighting = 0X000004 // bool
    m_vLightmapUvScale = 0X000008 // Vector2D
    m_nCompileTimestamp = 0X000010 // uint64
    m_nCompileFingerprint = 0X000018 // uint64

 NodeData_t: [worldrenderer.dll]
    m_nParent = 0X000000 // int32
    m_vOrigin = 0X000004 // Vector
    m_vMinBounds = 0X000010 // Vector
    m_vMaxBounds = 0X00001C // Vector
    m_flMinimumDistance = 0X000028 // float32
    m_ChildNodeIndices = 0X000030 // CUtlVector< int32 >
    m_worldNodePrefix = 0X000048 // CUtlString

 World_t: [worldrenderer.dll]
    m_builderParams = 0X000000 // WorldBuilderParams_t
    m_worldNodes = 0X000020 // CUtlVector< NodeData_t >
    m_worldLightingInfo = 0X000038 // BakedLightingInfo_t
    m_entityLumps = 0X000068 // CUtlVector< CStrongHandleCopyable< InfoForResourceTypeCEntityLump > >

 VoxelVisBlockOffset_t: [worldrenderer.dll]
    m_nOffset = 0X000000 // uint32
    m_nElementCount = 0X000004 // uint32

 CVoxelVisibility: [worldrenderer.dll]
    m_nBaseClusterCount = 0X000040 // uint32
    m_nPVSBytesPerCluster = 0X000044 // uint32
    m_vMinBounds = 0X000048 // Vector
    m_vMaxBounds = 0X000054 // Vector
    m_flGridSize = 0X000060 // float32
    m_nSkyVisibilityCluster = 0X000064 // uint32
    m_nSunVisibilityCluster = 0X000068 // uint32
    m_NodeBlock = 0X00006C // VoxelVisBlockOffset_t
    m_RegionBlock = 0X000074 // VoxelVisBlockOffset_t
    m_EnclosedClusterListBlock = 0X00007C // VoxelVisBlockOffset_t
    m_EnclosedClustersBlock = 0X000084 // VoxelVisBlockOffset_t
    m_MasksBlock = 0X00008C // VoxelVisBlockOffset_t
    m_nVisBlocks = 0X000094 // VoxelVisBlockOffset_t

 VMapResourceData_t: [worldrenderer.dll]
    No schemes available

 InfoForResourceTypeVMapResourceData_t: [worldrenderer.dll]
    No schemes available

 CEntityIdentity: [worldrenderer.dll]
    m_nameStringableIndex = 0X000014 // int32
    m_name = 0X000018 // CUtlSymbolLarge
    m_designerName = 0X000020 // CUtlSymbolLarge
    m_flags = 0X000030 // uint32
    m_worldGroupId = 0X000038 // WorldGroupId_t
    m_fDataObjectTypes = 0X00003C // uint32
    m_PathIndex = 0X000040 // ChangeAccessorFieldPathIndex_t
    m_pPrev = 0X000058 // CEntityIdentity*
    m_pNext = 0X000060 // CEntityIdentity*
    m_pPrevByClass = 0X000068 // CEntityIdentity*
    m_pNextByClass = 0X000070 // CEntityIdentity*

 CEntityInstance: [worldrenderer.dll]
    m_iszPrivateVScripts = 0X000008 // CUtlSymbolLarge
    m_pEntity = 0X000010 // CEntityIdentity*
    m_CScriptComponent = 0X000028 // CScriptComponent*

 CScriptComponent: [worldrenderer.dll]
    m_scriptClassName = 0X000030 // CUtlSymbolLarge


particles.dll:
 CRandomNumberGeneratorParameters: [particles.dll]
    m_bDistributeEvenly = 0X000000 // bool
    m_nSeed = 0X000004 // int32

 MaterialVariable_t: [particles.dll]
    m_strVariable = 0X000000 // CUtlString
    m_nVariableField = 0X000008 // ParticleAttributeIndex_t
    m_flScale = 0X00000C // float32

 ParticleAttributeIndex_t: [particles.dll]
    m_Value = 0X000000 // int32

 ParticlePreviewBodyGroup_t: [particles.dll]
    m_bodyGroupName = 0X000000 // CUtlString
    m_nValue = 0X000008 // int32

 ParticlePreviewState_t: [particles.dll]
    m_previewModel = 0X000000 // CUtlString
    m_nModSpecificData = 0X000008 // uint32
    m_groundType = 0X00000C // PetGroundType_t
    m_sequenceName = 0X000010 // CUtlString
    m_nFireParticleOnSequenceFrame = 0X000018 // int32
    m_hitboxSetName = 0X000020 // CUtlString
    m_materialGroupName = 0X000028 // CUtlString
    m_vecBodyGroups = 0X000030 // CUtlVector< ParticlePreviewBodyGroup_t >
    m_flPlaybackSpeed = 0X000048 // float32
    m_flParticleSimulationRate = 0X00004C // float32
    m_bShouldDrawHitboxes = 0X000050 // bool
    m_bShouldDrawAttachments = 0X000051 // bool
    m_bShouldDrawAttachmentNames = 0X000052 // bool
    m_bShouldDrawControlPointAxes = 0X000053 // bool
    m_bAnimationNonLooping = 0X000054 // bool

 ParticleControlPointDriver_t: [particles.dll]
    m_iControlPoint = 0X000000 // int32
    m_iAttachType = 0X000004 // ParticleAttachment_t
    m_attachmentName = 0X000008 // CUtlString
    m_vecOffset = 0X000010 // Vector
    m_angOffset = 0X00001C // QAngle
    m_entityName = 0X000028 // CUtlString

 ParticleControlPointConfiguration_t: [particles.dll]
    m_name = 0X000000 // CUtlString
    m_drivers = 0X000008 // CUtlVector< ParticleControlPointDriver_t >
    m_previewState = 0X000020 // ParticlePreviewState_t

 IParticleCollection: [particles.dll]
    No schemes available

 IControlPointEditorData: [particles.dll]
    No schemes available

 IParticleSystemDefinition: [particles.dll]
    No schemes available

 CParticleVisibilityInputs: [particles.dll]
    m_flCameraBias = 0X000000 // float32
    m_nCPin = 0X000004 // int32
    m_flProxyRadius = 0X000008 // float32
    m_flInputMin = 0X00000C // float32
    m_flInputMax = 0X000010 // float32
    m_flNoPixelVisibilityFallback = 0X000014 // float32
    m_flDistanceInputMin = 0X000018 // float32
    m_flDistanceInputMax = 0X00001C // float32
    m_flDotInputMin = 0X000020 // float32
    m_flDotInputMax = 0X000024 // float32
    m_bDotCPAngles = 0X000028 // bool
    m_bDotCameraAngles = 0X000029 // bool
    m_flAlphaScaleMin = 0X00002C // float32
    m_flAlphaScaleMax = 0X000030 // float32
    m_flRadiusScaleMin = 0X000034 // float32
    m_flRadiusScaleMax = 0X000038 // float32
    m_flRadiusScaleFOVBase = 0X00003C // float32
    m_bRightEye = 0X000040 // bool

 CPathParameters: [particles.dll]
    m_nStartControlPointNumber = 0X000000 // int32
    m_nEndControlPointNumber = 0X000004 // int32
    m_nBulgeControl = 0X000008 // int32
    m_flBulge = 0X00000C // float32
    m_flMidPoint = 0X000010 // float32
    m_vStartPointOffset = 0X000014 // Vector
    m_vMidPointOffset = 0X000020 // Vector
    m_vEndOffset = 0X00002C // Vector

 ParticleChildrenInfo_t: [particles.dll]
    m_ChildRef = 0X000000 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_flDelay = 0X000008 // float32
    m_bEndCap = 0X00000C // bool
    m_bDisableChild = 0X00000D // bool
    m_nDetailLevel = 0X000010 // ParticleDetailLevel_t

 ControlPointReference_t: [particles.dll]
    m_controlPointNameString = 0X000000 // int32
    m_vOffsetFromControlPoint = 0X000004 // Vector
    m_bOffsetInLocalSpace = 0X000010 // bool

 ModelReference_t: [particles.dll]
    m_model = 0X000000 // CStrongHandle< InfoForResourceTypeCModel >
    m_flRelativeProbabilityOfSpawn = 0X000008 // float32

 SequenceWeightedList_t: [particles.dll]
    m_nSequence = 0X000000 // int32
    m_flRelativeWeight = 0X000004 // float32

 CollisionGroupContext_t: [particles.dll]
    m_nCollisionGroupNumber = 0X000000 // int32

 PointDefinition_t: [particles.dll]
    m_nControlPoint = 0X000000 // int32
    m_bLocalCoords = 0X000004 // bool
    m_vOffset = 0X000008 // Vector

 PointDefinitionWithTimeValues_t: [particles.dll]
    m_flTimeDuration = 0X000014 // float32

 ParticleNamedValueSource_t: [particles.dll]
    m_Name = 0X000000 // CUtlString
    m_Type = 0X000008 // PulseValueType_t
    m_IsPublic = 0X00000C // bool

 CParticleSystemDefinition: [particles.dll]
    m_nBehaviorVersion = 0X000008 // int32
    m_PreEmissionOperators = 0X000010 // CUtlVector< CParticleFunctionPreEmission* >
    m_Emitters = 0X000028 // CUtlVector< CParticleFunctionEmitter* >
    m_Initializers = 0X000040 // CUtlVector< CParticleFunctionInitializer* >
    m_Operators = 0X000058 // CUtlVector< CParticleFunctionOperator* >
    m_ForceGenerators = 0X000070 // CUtlVector< CParticleFunctionForce* >
    m_Constraints = 0X000088 // CUtlVector< CParticleFunctionConstraint* >
    m_Renderers = 0X0000A0 // CUtlVector< CParticleFunctionRenderer* >
    m_Children = 0X0000B8 // CUtlVector< ParticleChildrenInfo_t >
    m_nFirstMultipleOverride_BackwardCompat = 0X000178 // int32
    m_nInitialParticles = 0X000210 // int32
    m_nMaxParticles = 0X000214 // int32
    m_nGroupID = 0X000218 // int32
    m_BoundingBoxMin = 0X00021C // Vector
    m_BoundingBoxMax = 0X000228 // Vector
    m_flDepthSortBias = 0X000234 // float32
    m_nSortOverridePositionCP = 0X000238 // int32
    m_bInfiniteBounds = 0X00023C // bool
    m_bEnableNamedValues = 0X00023D // bool
    m_NamedValueDomain = 0X000240 // CUtlString
    m_NamedValueLocals = 0X000248 // CUtlVector< ParticleNamedValueSource_t >
    m_ConstantColor = 0X000260 // Color
    m_ConstantNormal = 0X000264 // Vector
    m_flConstantRadius = 0X000270 // float32
    m_flConstantRotation = 0X000274 // float32
    m_flConstantRotationSpeed = 0X000278 // float32
    m_flConstantLifespan = 0X00027C // float32
    m_nConstantSequenceNumber = 0X000280 // int32
    m_nConstantSequenceNumber1 = 0X000284 // int32
    m_nSnapshotControlPoint = 0X000288 // int32
    m_hSnapshot = 0X000290 // CStrongHandle< InfoForResourceTypeIParticleSnapshot >
    m_pszCullReplacementName = 0X000298 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_flCullRadius = 0X0002A0 // float32
    m_flCullFillCost = 0X0002A4 // float32
    m_nCullControlPoint = 0X0002A8 // int32
    m_hFallback = 0X0002B0 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_nFallbackMaxCount = 0X0002B8 // int32
    m_hLowViolenceDef = 0X0002C0 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_hReferenceReplacement = 0X0002C8 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_flPreSimulationTime = 0X0002D0 // float32
    m_flStopSimulationAfterTime = 0X0002D4 // float32
    m_flMaximumTimeStep = 0X0002D8 // float32
    m_flMaximumSimTime = 0X0002DC // float32
    m_flMinimumSimTime = 0X0002E0 // float32
    m_flMinimumTimeStep = 0X0002E4 // float32
    m_nMinimumFrames = 0X0002E8 // int32
    m_nMinCPULevel = 0X0002EC // int32
    m_nMinGPULevel = 0X0002F0 // int32
    m_flNoDrawTimeToGoToSleep = 0X0002F4 // float32
    m_flMaxDrawDistance = 0X0002F8 // float32
    m_flStartFadeDistance = 0X0002FC // float32
    m_flMaxCreationDistance = 0X000300 // float32
    m_nAggregationMinAvailableParticles = 0X000304 // int32
    m_flAggregateRadius = 0X000308 // float32
    m_bShouldBatch = 0X00030C // bool
    m_bShouldHitboxesFallbackToRenderBounds = 0X00030D // bool
    m_nViewModelEffect = 0X000310 // InheritableBoolType_t
    m_bScreenSpaceEffect = 0X000314 // bool
    m_pszTargetLayerID = 0X000318 // CUtlSymbolLarge
    m_nSkipRenderControlPoint = 0X000320 // int32
    m_nAllowRenderControlPoint = 0X000324 // int32
    m_bShouldSort = 0X000328 // bool
    m_controlPointConfigurations = 0X000368 // CUtlVector< ParticleControlPointConfiguration_t >

 CParticleFunction: [particles.dll]
    m_flOpStrength = 0X000008 // CParticleCollectionFloatInput
    m_nOpEndCapState = 0X000148 // ParticleEndcapMode_t
    m_flOpStartFadeInTime = 0X00014C // float32
    m_flOpEndFadeInTime = 0X000150 // float32
    m_flOpStartFadeOutTime = 0X000154 // float32
    m_flOpEndFadeOutTime = 0X000158 // float32
    m_flOpFadeOscillatePeriod = 0X00015C // float32
    m_bNormalizeToStopTime = 0X000160 // bool
    m_flOpTimeOffsetMin = 0X000164 // float32
    m_flOpTimeOffsetMax = 0X000168 // float32
    m_nOpTimeOffsetSeed = 0X00016C // int32
    m_nOpTimeScaleSeed = 0X000170 // int32
    m_flOpTimeScaleMin = 0X000174 // float32
    m_flOpTimeScaleMax = 0X000178 // float32
    m_bDisableOperator = 0X00017D // bool
    m_Notes = 0X000180 // CUtlString

 CParticleFunctionInitializer: [particles.dll]
    m_nAssociatedEmitterIndex = 0X000210 // int32

 CParticleFunctionEmitter: [particles.dll]
    m_nEmitterIndex = 0X000210 // int32

 CParticleFunctionConstraint: [particles.dll]
    No schemes available

 CParticleFunctionForce: [particles.dll]
    No schemes available

 CParticleFunctionOperator: [particles.dll]
    No schemes available

 CParticleFunctionPreEmission: [particles.dll]
    m_bRunOnce = 0X000210 // bool

 CParticleFunctionRenderer: [particles.dll]
    VisibilityInputs = 0X000210 // CParticleVisibilityInputs
    m_bCannotBeRefracted = 0X000254 // bool
    m_bSkipRenderingOnMobile = 0X000255 // bool

 TextureControls_t: [particles.dll]
    m_flFinalTextureScaleU = 0X000000 // CParticleCollectionRendererFloatInput
    m_flFinalTextureScaleV = 0X000140 // CParticleCollectionRendererFloatInput
    m_flFinalTextureOffsetU = 0X000280 // CParticleCollectionRendererFloatInput
    m_flFinalTextureOffsetV = 0X0003C0 // CParticleCollectionRendererFloatInput
    m_flFinalTextureUVRotation = 0X000500 // CParticleCollectionRendererFloatInput
    m_flZoomScale = 0X000640 // CParticleCollectionRendererFloatInput
    m_flDistortion = 0X000780 // CParticleCollectionRendererFloatInput
    m_bRandomizeOffsets = 0X0008C0 // bool
    m_bClampUVs = 0X0008C1 // bool
    m_nPerParticleBlend = 0X0008C4 // SpriteCardPerParticleScale_t
    m_nPerParticleScale = 0X0008C8 // SpriteCardPerParticleScale_t
    m_nPerParticleOffsetU = 0X0008CC // SpriteCardPerParticleScale_t
    m_nPerParticleOffsetV = 0X0008D0 // SpriteCardPerParticleScale_t
    m_nPerParticleRotation = 0X0008D4 // SpriteCardPerParticleScale_t
    m_nPerParticleZoom = 0X0008D8 // SpriteCardPerParticleScale_t
    m_nPerParticleDistortion = 0X0008DC // SpriteCardPerParticleScale_t

 TextureGroup_t: [particles.dll]
    m_bEnabled = 0X000000 // bool
    m_bReplaceTextureWithGradient = 0X000001 // bool
    m_hTexture = 0X000008 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_Gradient = 0X000010 // CColorGradient
    m_nTextureType = 0X000028 // SpriteCardTextureType_t
    m_nTextureChannels = 0X00002C // SpriteCardTextureChannel_t
    m_nTextureBlendMode = 0X000030 // ParticleTextureLayerBlendType_t
    m_flTextureBlend = 0X000038 // CParticleCollectionRendererFloatInput
    m_TextureControls = 0X000178 // TextureControls_t

 CBaseRendererSource2: [particles.dll]
    m_flRadiusScale = 0X000260 // CParticleCollectionRendererFloatInput
    m_flAlphaScale = 0X0003A0 // CParticleCollectionRendererFloatInput
    m_flRollScale = 0X0004E0 // CParticleCollectionRendererFloatInput
    m_nAlpha2Field = 0X000620 // ParticleAttributeIndex_t
    m_vecColorScale = 0X000628 // CParticleCollectionRendererVecInput
    m_nColorBlendType = 0X000C10 // ParticleColorBlendType_t
    m_nShaderType = 0X000C14 // SpriteCardShaderType_t
    m_strShaderOverride = 0X000C18 // CUtlString
    m_flCenterXOffset = 0X000C20 // CParticleCollectionRendererFloatInput
    m_flCenterYOffset = 0X000D60 // CParticleCollectionRendererFloatInput
    m_flBumpStrength = 0X000EA0 // float32
    m_nCropTextureOverride = 0X000EA4 // ParticleSequenceCropOverride_t
    m_vecTexturesInput = 0X000EA8 // CUtlVector< TextureGroup_t >
    m_flAnimationRate = 0X000EC0 // float32
    m_nAnimationType = 0X000EC4 // AnimationType_t
    m_bAnimateInFPS = 0X000EC8 // bool
    m_flSelfIllumAmount = 0X000ED0 // CParticleCollectionRendererFloatInput
    m_flDiffuseAmount = 0X001010 // CParticleCollectionRendererFloatInput
    m_nLightingControlPoint = 0X001150 // int32
    m_nSelfIllumPerParticle = 0X001154 // ParticleAttributeIndex_t
    m_nOutputBlendMode = 0X001158 // ParticleOutputBlendMode_t
    m_bGammaCorrectVertexColors = 0X00115C // bool
    m_bSaturateColorPreAlphaBlend = 0X00115D // bool
    m_flAddSelfAmount = 0X001160 // CParticleCollectionRendererFloatInput
    m_flDesaturation = 0X0012A0 // CParticleCollectionRendererFloatInput
    m_flOverbrightFactor = 0X0013E0 // CParticleCollectionRendererFloatInput
    m_nHSVShiftControlPoint = 0X001520 // int32
    m_nFogType = 0X001524 // ParticleFogType_t
    m_flFogAmount = 0X001528 // CParticleCollectionRendererFloatInput
    m_bTintByFOW = 0X001668 // bool
    m_bTintByGlobalLight = 0X001669 // bool
    m_nPerParticleAlphaReference = 0X00166C // SpriteCardPerParticleScale_t
    m_nPerParticleAlphaRefWindow = 0X001670 // SpriteCardPerParticleScale_t
    m_nAlphaReferenceType = 0X001674 // ParticleAlphaReferenceType_t
    m_flAlphaReferenceSoftness = 0X001678 // CParticleCollectionRendererFloatInput
    m_flSourceAlphaValueToMapToZero = 0X0017B8 // CParticleCollectionRendererFloatInput
    m_flSourceAlphaValueToMapToOne = 0X0018F8 // CParticleCollectionRendererFloatInput
    m_bRefract = 0X001A38 // bool
    m_bRefractSolid = 0X001A39 // bool
    m_flRefractAmount = 0X001A40 // CParticleCollectionRendererFloatInput
    m_nRefractBlurRadius = 0X001B80 // int32
    m_nRefractBlurType = 0X001B84 // BlurFilterType_t
    m_bOnlyRenderInEffectsBloomPass = 0X001B88 // bool
    m_bOnlyRenderInEffectsWaterPass = 0X001B89 // bool
    m_bUseMixedResolutionRendering = 0X001B8A // bool
    m_bOnlyRenderInEffecsGameOverlay = 0X001B8B // bool
    m_stencilTestID = 0X001B8C // char[128]
    m_bStencilTestExclude = 0X001C0C // bool
    m_stencilWriteID = 0X001C0D // char[128]
    m_bWriteStencilOnDepthPass = 0X001C8D // bool
    m_bWriteStencilOnDepthFail = 0X001C8E // bool
    m_bReverseZBuffering = 0X001C8F // bool
    m_bDisableZBuffering = 0X001C90 // bool
    m_nFeatheringMode = 0X001C94 // ParticleDepthFeatheringMode_t
    m_flFeatheringMinDist = 0X001C98 // CParticleCollectionRendererFloatInput
    m_flFeatheringMaxDist = 0X001DD8 // CParticleCollectionRendererFloatInput
    m_flFeatheringFilter = 0X001F18 // CParticleCollectionRendererFloatInput
    m_flDepthBias = 0X002058 // float32
    m_nSortMethod = 0X00205C // ParticleSortingChoiceList_t
    m_bBlendFramesSeq0 = 0X002060 // bool
    m_bMaxLuminanceBlendingSequence0 = 0X002061 // bool

 C_OP_RenderSprites: [particles.dll]
    m_nSequenceOverride = 0X002270 // CParticleCollectionRendererFloatInput
    m_nOrientationType = 0X0023B0 // ParticleOrientationChoiceList_t
    m_nOrientationControlPoint = 0X0023B4 // int32
    m_bUseYawWithNormalAligned = 0X0023B8 // bool
    m_flMinSize = 0X0023BC // float32
    m_flMaxSize = 0X0023C0 // float32
    m_flAlphaAdjustWithSizeAdjust = 0X0023C4 // float32
    m_flStartFadeSize = 0X0023C8 // CParticleCollectionRendererFloatInput
    m_flEndFadeSize = 0X002508 // CParticleCollectionRendererFloatInput
    m_flStartFadeDot = 0X002648 // float32
    m_flEndFadeDot = 0X00264C // float32
    m_bDistanceAlpha = 0X002650 // bool
    m_bSoftEdges = 0X002651 // bool
    m_flEdgeSoftnessStart = 0X002654 // float32
    m_flEdgeSoftnessEnd = 0X002658 // float32
    m_bOutline = 0X00265C // bool
    m_OutlineColor = 0X00265D // Color
    m_nOutlineAlpha = 0X002664 // int32
    m_flOutlineStart0 = 0X002668 // float32
    m_flOutlineStart1 = 0X00266C // float32
    m_flOutlineEnd0 = 0X002670 // float32
    m_flOutlineEnd1 = 0X002674 // float32
    m_nLightingMode = 0X002678 // ParticleLightingQuality_t
    m_flLightingTessellation = 0X002680 // CParticleCollectionRendererFloatInput
    m_flLightingDirectionality = 0X0027C0 // CParticleCollectionRendererFloatInput
    m_bParticleShadows = 0X002900 // bool
    m_flShadowDensity = 0X002904 // float32

 FloatInputMaterialVariable_t: [particles.dll]
    m_strVariable = 0X000000 // CUtlString
    m_flInput = 0X000008 // CParticleCollectionFloatInput

 VecInputMaterialVariable_t: [particles.dll]
    m_strVariable = 0X000000 // CUtlString
    m_vecInput = 0X000008 // CParticleCollectionVecInput

 C_OP_RenderCables: [particles.dll]
    m_flRadiusScale = 0X000260 // CParticleCollectionFloatInput
    m_flAlphaScale = 0X0003A0 // CParticleCollectionFloatInput
    m_vecColorScale = 0X0004E0 // CParticleCollectionVecInput
    m_nColorBlendType = 0X000AC8 // ParticleColorBlendType_t
    m_hMaterial = 0X000AD0 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_nTextureRepetitionMode = 0X000AD8 // TextureRepetitionMode_t
    m_flTextureRepeatsPerSegment = 0X000AE0 // CParticleCollectionFloatInput
    m_flTextureRepeatsCircumference = 0X000C20 // CParticleCollectionFloatInput
    m_flColorMapOffsetV = 0X000D60 // CParticleCollectionFloatInput
    m_flColorMapOffsetU = 0X000EA0 // CParticleCollectionFloatInput
    m_flNormalMapOffsetV = 0X000FE0 // CParticleCollectionFloatInput
    m_flNormalMapOffsetU = 0X001120 // CParticleCollectionFloatInput
    m_bDrawCableCaps = 0X001260 // bool
    m_flCapRoundness = 0X001264 // float32
    m_flCapOffsetAmount = 0X001268 // float32
    m_flTessScale = 0X00126C // float32
    m_nMinTesselation = 0X001270 // int32
    m_nMaxTesselation = 0X001274 // int32
    m_nRoundness = 0X001278 // int32
    m_LightingTransform = 0X001280 // CParticleTransformInput
    m_MaterialFloatVars = 0X0012D0 // CUtlVector< FloatInputMaterialVariable_t >
    m_MaterialVecVars = 0X001300 // CUtlVector< VecInputMaterialVariable_t >

 CPulse_RegisterInfo: [particles.dll]
    m_nReg = 0X000000 // PulseRuntimeRegisterIndex_t
    m_Type = 0X000008 // CPulseValueFullType
    m_OriginName = 0X000018 // CKV3MemberNameWithStorage
    m_nWrittenByInstruction = 0X000050 // int32
    m_nLastReadByInstruction = 0X000054 // int32

 CPulse_Chunk: [particles.dll]
    m_Instructions = 0X000000 // CUtlLeanVector< PGDInstruction_t >
    m_Registers = 0X000010 // CUtlLeanVector< CPulse_RegisterInfo >
    m_InstructionEditorIDs = 0X000020 // CUtlLeanVector< PulseDocNodeID_t >

 CPulse_Variable: [particles.dll]
    m_Name = 0X000000 // CUtlSymbolLarge
    m_Description = 0X000008 // CUtlString
    m_Type = 0X000010 // CPulseValueFullType
    m_DefaultValue = 0X000020 // KeyValues3
    m_bIsPublic = 0X000032 // bool

 CPulse_PublicOutput: [particles.dll]
    m_Name = 0X000000 // CUtlSymbolLarge
    m_Description = 0X000008 // CUtlString

 CPulse_OutputConnection: [particles.dll]
    m_SourceOutput = 0X000000 // CUtlSymbolLarge
    m_TargetEntity = 0X000008 // CUtlSymbolLarge
    m_TargetInput = 0X000010 // CUtlSymbolLarge
    m_Param = 0X000018 // CUtlSymbolLarge

 CPulse_InvokeBinding: [particles.dll]
    m_RegisterMap = 0X000000 // PulseRegisterMap_t
    m_FuncName = 0X000020 // CUtlSymbolLarge
    m_nCellIndex = 0X000028 // PulseRuntimeCellIndex_t

 CPulse_LandingPadInfo: [particles.dll]
    m_PortName = 0X000000 // CUtlSymbolLarge
    m_nEditorNodeID = 0X000008 // PulseDocNodeID_t
    m_nAssociatedChunk = 0X00000C // PulseRuntimeChunkIndex_t
    m_nAssociatedInstruction = 0X000010 // int32

 CPulseGraphDef: [particles.dll]
    m_DomainIdentifier = 0X000008 // CUtlSymbolLarge
    m_ParentMapName = 0X000010 // CUtlSymbolLarge
    m_Chunks = 0X000018 // CUtlVector< CPulse_Chunk* >
    m_Cells = 0X000030 // CUtlVector< CPulseCell_Base* >
    m_Vars = 0X000048 // CUtlVector< CPulse_Variable >
    m_PublicOutputs = 0X000060 // CUtlVector< CPulse_PublicOutput >
    m_InvokeBindings = 0X000078 // CUtlVector< CPulse_InvokeBinding* >
    m_LandingPads = 0X000090 // CUtlVector< CPulse_LandingPadInfo* >
    m_OutputConnections = 0X0000A8 // CUtlVector< CPulse_OutputConnection* >

 CBasePulseGraphInstance: [particles.dll]
    No schemes available

 PulseRuntimeChunkIndex_t: [particles.dll]
    m_Value = 0X000000 // int32

 PulseRuntimeLandingPadIndex_t: [particles.dll]
    m_Value = 0X000000 // int32

 PulseRuntimeVarIndex_t: [particles.dll]
    m_Value = 0X000000 // int32

 PulseRuntimeOutputIndex_t: [particles.dll]
    m_Value = 0X000000 // int32

 PulseRuntimeStateOffset_t: [particles.dll]
    m_Value = 0X000000 // uint16

 PulseRuntimeRegisterIndex_t: [particles.dll]
    m_Value = 0X000000 // int16

 PulseRuntimeCellIndex_t: [particles.dll]
    m_Value = 0X000000 // int32

 PulseRuntimeInvokeIndex_t: [particles.dll]
    m_Value = 0X000000 // int32

 PulseDocNodeID_t: [particles.dll]
    m_Value = 0X000000 // int32

 PulseRuntimeEntrypointIndex_t: [particles.dll]
    m_Value = 0X000000 // int32

 PulseRegisterMap_t: [particles.dll]
    m_Inparams = 0X000000 // KeyValues3
    m_Outparams = 0X000010 // KeyValues3

 PGDInstruction_t: [particles.dll]
    m_nCode = 0X000000 // PulseInstructionCode_t
    m_nVar = 0X000004 // PulseRuntimeVarIndex_t
    m_nReg0 = 0X000008 // PulseRuntimeRegisterIndex_t
    m_nReg1 = 0X00000A // PulseRuntimeRegisterIndex_t
    m_nReg2 = 0X00000C // PulseRuntimeRegisterIndex_t
    m_nInvokeBindingIndex = 0X000010 // PulseRuntimeInvokeIndex_t
    m_nChunk = 0X000014 // PulseRuntimeChunkIndex_t
    m_nDestInstruction = 0X000018 // int32
    m_nLandingPadIndex = 0X00001C // PulseRuntimeLandingPadIndex_t
    m_Arg0Name = 0X000020 // CUtlSymbolLarge
    m_Arg1Name = 0X000028 // CUtlSymbolLarge
    m_bLiteralBool = 0X000030 // bool
    m_nLiteralInt = 0X000034 // int32
    m_flLiteralFloat = 0X000038 // float32
    m_LiteralString = 0X000040 // CBufferString
    m_vLiteralVec3 = 0X000050 // Vector

 CPulse_OutflowConnection: [particles.dll]
    m_SourceOutflowName = 0X000000 // CUtlSymbolLarge
    m_nDestChunk = 0X000008 // PulseRuntimeChunkIndex_t
    m_nJumpType = 0X00000C // PulseCursorFlow_t
    m_nInstruction = 0X000010 // int32

 CPulse_ResumePoint: [particles.dll]
    No schemes available

 CPulseCell_Base: [particles.dll]
    m_nEditorNodeID = 0X000008 // PulseDocNodeID_t

 CPulseCell_BaseFlow: [particles.dll]
    No schemes available

 CPulseCell_Inflow_BaseEntrypoint: [particles.dll]
    m_EntryChunk = 0X000048 // PulseRuntimeChunkIndex_t
    m_RegisterMap = 0X000050 // PulseRegisterMap_t

 CPulseCell_Inflow_Method: [particles.dll]
    m_MethodName = 0X000070 // CUtlSymbolLarge
    m_Description = 0X000078 // CUtlString
    m_bIsPublic = 0X000080 // bool
    m_ReturnType = 0X000088 // CPulseValueFullType
    m_Arg0Name = 0X000098 // CKV3MemberNameWithStorage
    m_Arg0Description = 0X0000D0 // CUtlString
    m_Arg0Type = 0X0000D8 // CPulseValueFullType
    m_Arg1Name = 0X0000E8 // CKV3MemberNameWithStorage
    m_Arg1Description = 0X000120 // CUtlString
    m_Arg1Type = 0X000128 // CPulseValueFullType

 CPulseCell_Inflow_EventHandler: [particles.dll]
    m_EventName = 0X000070 // CUtlSymbolLarge

 CPulseCell_Inflow_GraphHook: [particles.dll]
    m_HookName = 0X000070 // CUtlSymbolLarge

 CPulseCell_Inflow_EntOutputHandler: [particles.dll]
    m_SourceEntity = 0X000070 // CUtlSymbolLarge
    m_SourceOutput = 0X000078 // CUtlSymbolLarge
    m_TargetInput = 0X000080 // CUtlSymbolLarge
    m_ExpectedParamType = 0X000088 // CPulseValueFullType

 CPulseCell_BaseYieldingInflow: [particles.dll]
    No schemes available

 CPulseCell_BaseValue: [particles.dll]
    No schemes available

 CPulseCell_Value_Expression: [particles.dll]
    No schemes available

 CPulseCell_Step_PublicOutput: [particles.dll]
    m_OutputIndex = 0X000048 // PulseRuntimeOutputIndex_t

 CPulseCell_Inflow_Yield: [particles.dll]
    m_UnyieldResume = 0X000048 // CPulse_ResumePoint

 CPulseCell_Inflow_Wait: [particles.dll]
    m_WakeResume = 0X000048 // CPulse_ResumePoint

 CPulseCell_Outflow_StringSwitch: [particles.dll]
    m_DefaultCaseOutflow = 0X000048 // CPulse_OutflowConnection
    m_CaseOutflows = 0X000060 // CUtlVector< CPulse_OutflowConnection >

 CPulseCell_Outflow_IntSwitch: [particles.dll]
    m_DefaultCaseOutflow = 0X000048 // CPulse_OutflowConnection
    m_CaseOutflows = 0X000060 // CUtlVector< CPulse_OutflowConnection >

 CPulseCell_Outflow_CycleOrdered: [particles.dll]
    m_Outputs = 0X000048 // CUtlVector< CPulse_OutflowConnection >

 CPulseCell_Outflow_CycleOrdered::InstanceState_t: [particles.dll]
    m_nNextIndex = 0X000000 // int32

 CPulseCell_Outflow_CycleRandom: [particles.dll]
    m_Outputs = 0X000048 // CUtlVector< CPulse_OutflowConnection >

 CPulseCell_Outflow_CycleShuffled: [particles.dll]
    m_Outputs = 0X000048 // CUtlVector< CPulse_OutflowConnection >

 CPulseCell_Outflow_CycleShuffled::InstanceState_t: [particles.dll]
    m_Shuffle = 0X000000 // CUtlVectorFixedGrowable< uint8 >
    m_nNextShuffle = 0X000020 // int32

 CPulseCell_Outflow_SimultaneousParallel: [particles.dll]
    m_Outputs = 0X000048 // CUtlVector< CPulse_OutflowConnection >

 CPulseCell_Outflow_TestRandomYesNo: [particles.dll]
    m_Yes = 0X000048 // CPulse_OutflowConnection
    m_No = 0X000060 // CPulse_OutflowConnection

 CPulseCell_Value_TestValue50: [particles.dll]
    No schemes available

 CPulseCell_Value_RandomInt: [particles.dll]
    No schemes available

 CPulseCell_Step_DebugLog: [particles.dll]
    No schemes available

 CPulseCell_Step_BaseCallMethod: [particles.dll]
    m_MethodName = 0X000048 // CUtlSymbolLarge
    m_Arg0Name = 0X000050 // CKV3MemberNameWithStorage
    m_Arg1Name = 0X000088 // CKV3MemberNameWithStorage

 CPulseCell_Step_CallMethod: [particles.dll]
    No schemes available

 CPulseCell_Step_CallExternalMethod: [particles.dll]
    No schemes available

 PulseTestEHandle_t: [particles.dll]
    m_Value = 0X000000 // int32

 CPulseGraphInstance_TestDomain: [particles.dll]
    m_bIsRunningUnitTests = 0X0000D0 // bool
    m_bExplicitTimeStepping = 0X0000D1 // bool
    m_bExpectingToDestroyWithYieldedCursors = 0X0000D2 // bool
    m_nNextValidateIndex = 0X0000D4 // int32
    m_Tracepoints = 0X0000D8 // CUtlVector< CUtlString >

 CPulseCell_Step_TestDomainTracepoint: [particles.dll]
    No schemes available

 CPulseCell_Step_TestDomainCreateFakeEntity: [particles.dll]
    No schemes available

 CPulseCell_Step_TestDomainDestroyFakeEntity: [particles.dll]
    No schemes available

 CPulseCell_Step_TestDomainEntFire: [particles.dll]
    m_Input = 0X000048 // CUtlString

 CPulseCell_Val_TestDomainGetEntityName: [particles.dll]
    No schemes available

 CPulseCell_Val_TestDomainFindEntityByName: [particles.dll]
    No schemes available

 CPulseGraphInstance_TestDomain_Derived: [particles.dll]
    No schemes available

 CPulseTestFuncs_DerivedDomain: [particles.dll]
    No schemes available

 CPulseCell_Test_NoInflow: [particles.dll]
    No schemes available

 CPulseCell_Test_MultiInflow_WithDefault: [particles.dll]
    No schemes available

 CPulseCell_Test_MultiInflow_NoDefault: [particles.dll]
    No schemes available

 CPulseGraphInstance_TurtleGraphics: [particles.dll]
    No schemes available

 CPulseTurtleGraphicsLib: [particles.dll]
    No schemes available

 CParticleFloatInput: [particles.dll]
    m_nType = 0X000000 // ParticleFloatType_t
    m_nMapType = 0X000004 // ParticleFloatMapType_t
    m_flLiteralValue = 0X000008 // float32
    m_NamedValue = 0X000010 // CKV3MemberNameWithStorage
    m_nControlPoint = 0X000048 // int32
    m_nScalarAttribute = 0X00004C // ParticleAttributeIndex_t
    m_nVectorAttribute = 0X000050 // ParticleAttributeIndex_t
    m_nVectorComponent = 0X000054 // int32
    m_flRandomMin = 0X000058 // float32
    m_flRandomMax = 0X00005C // float32
    m_bHasRandomSignFlip = 0X000060 // bool
    m_nRandomMode = 0X000064 // ParticleFloatRandomMode_t
    m_flLOD0 = 0X00006C // float32
    m_flLOD1 = 0X000070 // float32
    m_flLOD2 = 0X000074 // float32
    m_flLOD3 = 0X000078 // float32
    m_nNoiseInputVectorAttribute = 0X00007C // ParticleAttributeIndex_t
    m_flNoiseOutputMin = 0X000080 // float32
    m_flNoiseOutputMax = 0X000084 // float32
    m_flNoiseScale = 0X000088 // float32
    m_vecNoiseOffsetRate = 0X00008C // Vector
    m_flNoiseOffset = 0X000098 // float32
    m_nNoiseOctaves = 0X00009C // int32
    m_nNoiseTurbulence = 0X0000A0 // PFNoiseTurbulence_t
    m_nNoiseType = 0X0000A4 // PFNoiseType_t
    m_nNoiseModifier = 0X0000A8 // PFNoiseModifier_t
    m_flNoiseTurbulenceScale = 0X0000AC // float32
    m_flNoiseTurbulenceMix = 0X0000B0 // float32
    m_flNoiseImgPreviewScale = 0X0000B4 // float32
    m_bNoiseImgPreviewLive = 0X0000B8 // bool
    m_bUseBoundsCenter = 0X0000C1 // bool
    m_nInputMode = 0X0000C4 // ParticleFloatInputMode_t
    m_flMultFactor = 0X0000C8 // float32
    m_flInput0 = 0X0000CC // float32
    m_flInput1 = 0X0000D0 // float32
    m_flOutput0 = 0X0000D4 // float32
    m_flOutput1 = 0X0000D8 // float32
    m_flNotchedRangeMin = 0X0000DC // float32
    m_flNotchedRangeMax = 0X0000E0 // float32
    m_flNotchedOutputOutside = 0X0000E4 // float32
    m_flNotchedOutputInside = 0X0000E8 // float32
    m_nBiasType = 0X0000EC // ParticleFloatBiasType_t
    m_flBiasParameter = 0X0000F0 // float32
    m_Curve = 0X0000F8 // CPiecewiseCurve

 CPerParticleFloatInput: [particles.dll]
    No schemes available

 CParticleCollectionFloatInput: [particles.dll]
    No schemes available

 CParticleCollectionRendererFloatInput: [particles.dll]
    No schemes available

 CParticleRemapFloatInput: [particles.dll]
    No schemes available

 CParticleTransformInput: [particles.dll]
    m_nType = 0X000004 // ParticleTransformType_t
    m_NamedValue = 0X000008 // CKV3MemberNameWithStorage
    m_bFollowNamedValue = 0X000040 // bool
    m_bSupportsDisabled = 0X000041 // bool
    m_bUseOrientation = 0X000042 // bool
    m_nControlPoint = 0X000044 // int32
    m_nControlPointRangeMax = 0X000048 // int32
    m_flEndCPGrowthTime = 0X00004C // float32

 CParticleModelInput: [particles.dll]
    m_nType = 0X000004 // ParticleModelType_t
    m_NamedValue = 0X000008 // CKV3MemberNameWithStorage
    m_nControlPoint = 0X000040 // int32

 CParticleVecInput: [particles.dll]
    m_nType = 0X000000 // ParticleVecType_t
    m_vLiteralValue = 0X000004 // Vector
    m_LiteralColor = 0X000010 // Color
    m_NamedValue = 0X000018 // CKV3MemberNameWithStorage
    m_bFollowNamedValue = 0X000050 // bool
    m_nVectorAttribute = 0X000054 // ParticleAttributeIndex_t
    m_vVectorAttributeScale = 0X000058 // Vector
    m_nControlPoint = 0X000064 // int32
    m_vCPValueScale = 0X000068 // Vector
    m_vCPRelativePosition = 0X000074 // Vector
    m_vCPRelativeDir = 0X000080 // Vector
    m_FloatComponentX = 0X000090 // CParticleFloatInput
    m_FloatComponentY = 0X0001D0 // CParticleFloatInput
    m_FloatComponentZ = 0X000310 // CParticleFloatInput
    m_FloatInterp = 0X000450 // CParticleFloatInput
    m_flInterpInput0 = 0X000590 // float32
    m_flInterpInput1 = 0X000594 // float32
    m_vInterpOutput0 = 0X000598 // Vector
    m_vInterpOutput1 = 0X0005A4 // Vector
    m_Gradient = 0X0005B0 // CColorGradient
    m_vRandomMin = 0X0005C8 // Vector
    m_vRandomMax = 0X0005D4 // Vector

 CPerParticleVecInput: [particles.dll]
    No schemes available

 CParticleCollectionVecInput: [particles.dll]
    No schemes available

 CParticleCollectionRendererVecInput: [particles.dll]
    No schemes available

 PARTICLE_EHANDLE__: [particles.dll]
    unused = 0X000000 // int32

 PARTICLE_WORLD_HANDLE__: [particles.dll]
    unused = 0X000000 // int32

 IParticleEffect: [particles.dll]
    No schemes available

 CParticleCollectionBindingInstance: [particles.dll]
    No schemes available

 CParticleProperty: [particles.dll]
    No schemes available

 CNewParticleEffect: [particles.dll]
    m_pNext = 0X000010 // CNewParticleEffect*
    m_pPrev = 0X000018 // CNewParticleEffect*
    m_pParticles = 0X000020 // IParticleCollection*
    m_pDebugName = 0X000028 // char*
    m_bDontRemove = 0X000000 // bitfield:1
    m_bRemove = 0X000000 // bitfield:1
    m_bNeedsBBoxUpdate = 0X000000 // bitfield:1
    m_bIsFirstFrame = 0X000000 // bitfield:1
    m_bAutoUpdateBBox = 0X000000 // bitfield:1
    m_bAllocated = 0X000000 // bitfield:1
    m_bSimulate = 0X000000 // bitfield:1
    m_bShouldPerformCullCheck = 0X000000 // bitfield:1
    m_bForceNoDraw = 0X000000 // bitfield:1
    m_bShouldSave = 0X000000 // bitfield:1
    m_bDisableAggregation = 0X000000 // bitfield:1
    m_bShouldSimulateDuringGamePaused = 0X000000 // bitfield:1
    m_bShouldCheckFoW = 0X000000 // bitfield:1
    m_vSortOrigin = 0X000040 // Vector
    m_flScale = 0X00004C // float32
    m_hOwner = 0X000050 // PARTICLE_EHANDLE__*
    m_pOwningParticleProperty = 0X000058 // CParticleProperty*
    m_flFreezeTransitionStart = 0X000070 // float32
    m_flFreezeTransitionDuration = 0X000074 // float32
    m_flFreezeTransitionOverride = 0X000078 // float32
    m_bFreezeTransitionActive = 0X00007C // bool
    m_bFreezeTargetState = 0X00007D // bool
    m_bCanFreeze = 0X00007E // bool
    m_LastMin = 0X000080 // Vector
    m_LastMax = 0X00008C // Vector
    m_nSplitScreenUser = 0X000098 // CSplitScreenSlot
    m_vecAggregationCenter = 0X00009C // Vector
    m_RefCount = 0X0000C0 // int32

 C_OP_ConstrainDistance: [particles.dll]
    m_fMinDistance = 0X000210 // CParticleCollectionFloatInput
    m_fMaxDistance = 0X000350 // CParticleCollectionFloatInput
    m_nControlPointNumber = 0X000490 // int32
    m_CenterOffset = 0X000494 // Vector
    m_bGlobalCenter = 0X0004A0 // bool

 C_OP_CollideWithSelf: [particles.dll]
    m_flRadiusScale = 0X000210 // CPerParticleFloatInput
    m_flMinimumSpeed = 0X000350 // CPerParticleFloatInput

 C_OP_CollideWithParentParticles: [particles.dll]
    m_flParentRadiusScale = 0X000210 // CPerParticleFloatInput
    m_flRadiusScale = 0X000350 // CPerParticleFloatInput

 C_OP_ConstrainDistanceToPath: [particles.dll]
    m_fMinDistance = 0X000210 // float32
    m_flMaxDistance0 = 0X000214 // float32
    m_flMaxDistanceMid = 0X000218 // float32
    m_flMaxDistance1 = 0X00021C // float32
    m_PathParameters = 0X000220 // CPathParameters
    m_flTravelTime = 0X000260 // float32
    m_nFieldScale = 0X000264 // ParticleAttributeIndex_t
    m_nManualTField = 0X000268 // ParticleAttributeIndex_t

 C_OP_ConstrainDistanceToUserSpecifiedPath: [particles.dll]
    m_fMinDistance = 0X000210 // float32
    m_flMaxDistance = 0X000214 // float32
    m_flTimeScale = 0X000218 // float32
    m_bLoopedPath = 0X00021C // bool
    m_pointList = 0X000220 // CUtlVector< PointDefinitionWithTimeValues_t >

 C_OP_PlanarConstraint: [particles.dll]
    m_PointOnPlane = 0X000210 // Vector
    m_PlaneNormal = 0X00021C // Vector
    m_nControlPointNumber = 0X000228 // int32
    m_bGlobalOrigin = 0X00022C // bool
    m_bGlobalNormal = 0X00022D // bool
    m_flRadiusScale = 0X000230 // CPerParticleFloatInput
    m_flMaximumDistanceToCP = 0X000370 // CParticleCollectionFloatInput

 C_OP_WorldCollideConstraint: [particles.dll]
    No schemes available

 C_OP_WorldTraceConstraint: [particles.dll]
    m_nCP = 0X000210 // int32
    m_vecCpOffset = 0X000214 // Vector
    m_nCollisionMode = 0X000220 // ParticleCollisionMode_t
    m_nCollisionModeMin = 0X000224 // ParticleCollisionMode_t
    m_nTraceSet = 0X000228 // ParticleTraceSet_t
    m_CollisionGroupName = 0X00022C // char[128]
    m_bWorldOnly = 0X0002AC // bool
    m_bBrushOnly = 0X0002AD // bool
    m_bIncludeWater = 0X0002AE // bool
    m_nIgnoreCP = 0X0002B0 // int32
    m_flCpMovementTolerance = 0X0002B4 // float32
    m_flRetestRate = 0X0002B8 // float32
    m_flTraceTolerance = 0X0002BC // float32
    m_flCollisionConfirmationSpeed = 0X0002C0 // float32
    m_nMaxTracesPerFrame = 0X0002C4 // float32
    m_flRadiusScale = 0X0002C8 // CPerParticleFloatInput
    m_flBounceAmount = 0X000408 // CPerParticleFloatInput
    m_flSlideAmount = 0X000548 // CPerParticleFloatInput
    m_flRandomDirScale = 0X000688 // CPerParticleFloatInput
    m_bDecayBounce = 0X0007C8 // bool
    m_bKillonContact = 0X0007C9 // bool
    m_flMinSpeed = 0X0007CC // float32
    m_bSetNormal = 0X0007D0 // bool
    m_nStickOnCollisionField = 0X0007D4 // ParticleAttributeIndex_t
    m_flStopSpeed = 0X0007D8 // CPerParticleFloatInput
    m_nEntityStickDataField = 0X000918 // ParticleAttributeIndex_t

 C_OP_BoxConstraint: [particles.dll]
    m_vecMin = 0X000210 // Vector
    m_vecMax = 0X00021C // Vector
    m_nCP = 0X000228 // int32
    m_bLocalSpace = 0X00022C // bool

 C_OP_RopeSpringConstraint: [particles.dll]
    m_flRestLength = 0X000210 // CParticleCollectionFloatInput
    m_flMinDistance = 0X000350 // CParticleCollectionFloatInput
    m_flMaxDistance = 0X000490 // CParticleCollectionFloatInput
    m_flAdjustmentScale = 0X0005D0 // float32
    m_flInitialRestingLength = 0X0005D8 // CParticleCollectionFloatInput

 C_OP_SpringToVectorConstraint: [particles.dll]
    m_flRestLength = 0X000210 // CPerParticleFloatInput
    m_flMinDistance = 0X000350 // CPerParticleFloatInput
    m_flMaxDistance = 0X000490 // CPerParticleFloatInput
    m_flRestingLength = 0X0005D0 // CPerParticleFloatInput
    m_vecAnchorVector = 0X000710 // CPerParticleVecInput

 C_OP_ConstrainLineLength: [particles.dll]
    m_flMinDistance = 0X000210 // float32
    m_flMaxDistance = 0X000214 // float32

 C_INIT_RingWave: [particles.dll]
    m_TransformInput = 0X000220 // CParticleTransformInput
    m_flParticlesPerOrbit = 0X000270 // CParticleCollectionFloatInput
    m_flInitialRadius = 0X0003B0 // CPerParticleFloatInput
    m_flThickness = 0X0004F0 // CPerParticleFloatInput
    m_flInitialSpeedMin = 0X000630 // CPerParticleFloatInput
    m_flInitialSpeedMax = 0X000770 // CPerParticleFloatInput
    m_flRoll = 0X0008B0 // CPerParticleFloatInput
    m_flPitch = 0X0009F0 // CPerParticleFloatInput
    m_flYaw = 0X000B30 // CPerParticleFloatInput
    m_bEvenDistribution = 0X000C70 // bool
    m_bXYVelocityOnly = 0X000C71 // bool

 C_INIT_CreateSpiralSphere: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nOverrideCP = 0X000224 // int32
    m_nDensity = 0X000228 // int32
    m_flInitialRadius = 0X00022C // float32
    m_flInitialSpeedMin = 0X000230 // float32
    m_flInitialSpeedMax = 0X000234 // float32
    m_bUseParticleCount = 0X000238 // bool

 C_INIT_CreateInEpitrochoid: [particles.dll]
    m_nComponent1 = 0X000220 // int32
    m_nComponent2 = 0X000224 // int32
    m_TransformInput = 0X000228 // CParticleTransformInput
    m_flParticleDensity = 0X000278 // CPerParticleFloatInput
    m_flOffset = 0X0003B8 // CPerParticleFloatInput
    m_flRadius1 = 0X0004F8 // CPerParticleFloatInput
    m_flRadius2 = 0X000638 // CPerParticleFloatInput
    m_bUseCount = 0X000778 // bool
    m_bUseLocalCoords = 0X000779 // bool
    m_bOffsetExistingPos = 0X00077A // bool

 C_INIT_CreatePhyllotaxis: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nScaleCP = 0X000224 // int32
    m_nComponent = 0X000228 // int32
    m_fRadCentCore = 0X00022C // float32
    m_fRadPerPoint = 0X000230 // float32
    m_fRadPerPointTo = 0X000234 // float32
    m_fpointAngle = 0X000238 // float32
    m_fsizeOverall = 0X00023C // float32
    m_fRadBias = 0X000240 // float32
    m_fMinRad = 0X000244 // float32
    m_fDistBias = 0X000248 // float32
    m_bUseLocalCoords = 0X00024C // bool
    m_bUseWithContEmit = 0X00024D // bool
    m_bUseOrigRadius = 0X00024E // bool

 C_INIT_CreateOnModel: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nForceInModel = 0X000224 // int32
    m_nDesiredHitbox = 0X000228 // int32
    m_nHitboxValueFromControlPointIndex = 0X00022C // int32
    m_vecHitBoxScale = 0X000230 // CParticleCollectionVecInput
    m_flBoneVelocity = 0X000818 // float32
    m_flMaxBoneVelocity = 0X00081C // float32
    m_vecDirectionBias = 0X000820 // CParticleCollectionVecInput
    m_HitboxSetName = 0X000E08 // char[128]
    m_bLocalCoords = 0X000E88 // bool
    m_bUseBones = 0X000E89 // bool
    m_flShellSize = 0X000E90 // CParticleCollectionFloatInput

 C_INIT_CreateOnModelAtHeight: [particles.dll]
    m_bUseBones = 0X000220 // bool
    m_bForceZ = 0X000221 // bool
    m_nControlPointNumber = 0X000224 // int32
    m_nHeightCP = 0X000228 // int32
    m_bUseWaterHeight = 0X00022C // bool
    m_flDesiredHeight = 0X000230 // CParticleCollectionFloatInput
    m_vecHitBoxScale = 0X000370 // CParticleCollectionVecInput
    m_vecDirectionBias = 0X000958 // CParticleCollectionVecInput
    m_nBiasType = 0X000F40 // ParticleHitboxBiasType_t
    m_bLocalCoords = 0X000F44 // bool
    m_bPreferMovingBoxes = 0X000F45 // bool
    m_HitboxSetName = 0X000F46 // char[128]
    m_flHitboxVelocityScale = 0X000FC8 // CParticleCollectionFloatInput
    m_flMaxBoneVelocity = 0X001108 // CParticleCollectionFloatInput

 C_INIT_SetHitboxToClosest: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nDesiredHitbox = 0X000224 // int32
    m_vecHitBoxScale = 0X000228 // CParticleCollectionVecInput
    m_HitboxSetName = 0X000810 // char[128]
    m_bUseBones = 0X000890 // bool
    m_bUseClosestPointOnHitbox = 0X000891 // bool
    m_nTestType = 0X000894 // ClosestPointTestType_t
    m_flHybridRatio = 0X000898 // CParticleCollectionFloatInput
    m_bUpdatePosition = 0X0009D8 // bool

 C_INIT_SetHitboxToModel: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nForceInModel = 0X000224 // int32
    m_nDesiredHitbox = 0X000228 // int32
    m_vecHitBoxScale = 0X000230 // CParticleCollectionVecInput
    m_vecDirectionBias = 0X000818 // Vector
    m_bMaintainHitbox = 0X000824 // bool
    m_bUseBones = 0X000825 // bool
    m_HitboxSetName = 0X000826 // char[128]
    m_flShellSize = 0X0008A8 // CParticleCollectionFloatInput

 C_INIT_CreateWithinSphereTransform: [particles.dll]
    m_fRadiusMin = 0X000220 // CPerParticleFloatInput
    m_fRadiusMax = 0X000360 // CPerParticleFloatInput
    m_vecDistanceBias = 0X0004A0 // CPerParticleVecInput
    m_vecDistanceBiasAbs = 0X000A88 // Vector
    m_TransformInput = 0X000A98 // CParticleTransformInput
    m_fSpeedMin = 0X000AE8 // CPerParticleFloatInput
    m_fSpeedMax = 0X000C28 // CPerParticleFloatInput
    m_fSpeedRandExp = 0X000D68 // float32
    m_bLocalCoords = 0X000D6C // bool
    m_flEndCPGrowthTime = 0X000D70 // float32
    m_LocalCoordinateSystemSpeedMin = 0X000D78 // CPerParticleVecInput
    m_LocalCoordinateSystemSpeedMax = 0X001360 // CPerParticleVecInput
    m_nFieldOutput = 0X001948 // ParticleAttributeIndex_t
    m_nFieldVelocity = 0X00194C // ParticleAttributeIndex_t

 C_INIT_CreateWithinBox: [particles.dll]
    m_vecMin = 0X000220 // CPerParticleVecInput
    m_vecMax = 0X000808 // CPerParticleVecInput
    m_nControlPointNumber = 0X000DF0 // int32
    m_bLocalSpace = 0X000DF4 // bool
    m_randomnessParameters = 0X000DF8 // CRandomNumberGeneratorParameters

 C_INIT_CreateOnGrid: [particles.dll]
    m_nXCount = 0X000220 // CParticleCollectionFloatInput
    m_nYCount = 0X000360 // CParticleCollectionFloatInput
    m_nZCount = 0X0004A0 // CParticleCollectionFloatInput
    m_nXSpacing = 0X0005E0 // CParticleCollectionFloatInput
    m_nYSpacing = 0X000720 // CParticleCollectionFloatInput
    m_nZSpacing = 0X000860 // CParticleCollectionFloatInput
    m_nControlPointNumber = 0X0009A0 // int32
    m_bLocalSpace = 0X0009A4 // bool
    m_bCenter = 0X0009A5 // bool
    m_bHollow = 0X0009A6 // bool

 C_INIT_PositionOffset: [particles.dll]
    m_OffsetMin = 0X000220 // CPerParticleVecInput
    m_OffsetMax = 0X000808 // CPerParticleVecInput
    m_TransformInput = 0X000DF0 // CParticleTransformInput
    m_bLocalCoords = 0X000E40 // bool
    m_bProportional = 0X000E41 // bool
    m_randomnessParameters = 0X000E44 // CRandomNumberGeneratorParameters

 C_INIT_PositionOffsetToCP: [particles.dll]
    m_nControlPointNumberStart = 0X000220 // int32
    m_nControlPointNumberEnd = 0X000224 // int32
    m_bLocalCoords = 0X000228 // bool

 C_INIT_PositionPlaceOnGround: [particles.dll]
    m_flOffset = 0X000220 // CPerParticleFloatInput
    m_flMaxTraceLength = 0X000360 // CPerParticleFloatInput
    m_CollisionGroupName = 0X0004A0 // char[128]
    m_nTraceSet = 0X000520 // ParticleTraceSet_t
    m_nTraceMissBehavior = 0X000530 // ParticleTraceMissBehavior_t
    m_bIncludeWater = 0X000534 // bool
    m_bSetNormal = 0X000535 // bool
    m_bSetPXYZOnly = 0X000536 // bool
    m_bTraceAlongNormal = 0X000537 // bool
    m_bOffsetonColOnly = 0X000538 // bool
    m_flOffsetByRadiusFactor = 0X00053C // float32
    m_nPreserveOffsetCP = 0X000540 // int32
    m_nIgnoreCP = 0X000544 // int32

 C_INIT_VelocityFromNormal: [particles.dll]
    m_fSpeedMin = 0X000220 // float32
    m_fSpeedMax = 0X000224 // float32
    m_bIgnoreDt = 0X000228 // bool

 C_INIT_VelocityRandom: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_fSpeedMin = 0X000228 // CPerParticleFloatInput
    m_fSpeedMax = 0X000368 // CPerParticleFloatInput
    m_LocalCoordinateSystemSpeedMin = 0X0004A8 // CPerParticleVecInput
    m_LocalCoordinateSystemSpeedMax = 0X000A90 // CPerParticleVecInput
    m_bIgnoreDT = 0X001078 // bool
    m_randomnessParameters = 0X00107C // CRandomNumberGeneratorParameters

 C_INIT_InitialVelocityNoise: [particles.dll]
    m_vecAbsVal = 0X000220 // Vector
    m_vecAbsValInv = 0X00022C // Vector
    m_vecOffsetLoc = 0X000238 // CPerParticleVecInput
    m_flOffset = 0X000820 // CPerParticleFloatInput
    m_vecOutputMin = 0X000960 // CPerParticleVecInput
    m_vecOutputMax = 0X000F48 // CPerParticleVecInput
    m_flNoiseScale = 0X001530 // CPerParticleFloatInput
    m_flNoiseScaleLoc = 0X001670 // CPerParticleFloatInput
    m_TransformInput = 0X0017B0 // CParticleTransformInput
    m_bIgnoreDt = 0X001800 // bool

 C_INIT_InitialVelocityFromHitbox: [particles.dll]
    m_flVelocityMin = 0X000220 // float32
    m_flVelocityMax = 0X000224 // float32
    m_nControlPointNumber = 0X000228 // int32
    m_HitboxSetName = 0X00022C // char[128]
    m_bUseBones = 0X0002AC // bool

 C_INIT_VelocityRadialRandom: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_fSpeedMin = 0X000224 // float32
    m_fSpeedMax = 0X000228 // float32
    m_vecLocalCoordinateSystemSpeedScale = 0X00022C // Vector
    m_bIgnoreDelta = 0X000239 // bool

 C_INIT_RandomLifeTime: [particles.dll]
    m_fLifetimeMin = 0X000220 // float32
    m_fLifetimeMax = 0X000224 // float32
    m_fLifetimeRandExponent = 0X000228 // float32

 C_INIT_RandomScalar: [particles.dll]
    m_flMin = 0X000220 // float32
    m_flMax = 0X000224 // float32
    m_flExponent = 0X000228 // float32
    m_nFieldOutput = 0X00022C // ParticleAttributeIndex_t

 C_INIT_RandomVector: [particles.dll]
    m_vecMin = 0X000220 // Vector
    m_vecMax = 0X00022C // Vector
    m_nFieldOutput = 0X000238 // ParticleAttributeIndex_t
    m_randomnessParameters = 0X00023C // CRandomNumberGeneratorParameters

 C_INIT_RandomVectorComponent: [particles.dll]
    m_flMin = 0X000220 // float32
    m_flMax = 0X000224 // float32
    m_nFieldOutput = 0X000228 // ParticleAttributeIndex_t
    m_nComponent = 0X00022C // int32

 C_INIT_AddVectorToVector: [particles.dll]
    m_vecScale = 0X000220 // Vector
    m_nFieldOutput = 0X00022C // ParticleAttributeIndex_t
    m_nFieldInput = 0X000230 // ParticleAttributeIndex_t
    m_vOffsetMin = 0X000234 // Vector
    m_vOffsetMax = 0X000240 // Vector
    m_randomnessParameters = 0X00024C // CRandomNumberGeneratorParameters

 C_INIT_RandomAlphaWindowThreshold: [particles.dll]
    m_flMin = 0X000220 // float32
    m_flMax = 0X000224 // float32
    m_flExponent = 0X000228 // float32

 C_INIT_RandomRadius: [particles.dll]
    m_flRadiusMin = 0X000220 // float32
    m_flRadiusMax = 0X000224 // float32
    m_flRadiusRandExponent = 0X000228 // float32

 C_INIT_RandomAlpha: [particles.dll]
    m_nFieldOutput = 0X000220 // ParticleAttributeIndex_t
    m_nAlphaMin = 0X000224 // int32
    m_nAlphaMax = 0X000228 // int32
    m_flAlphaRandExponent = 0X000234 // float32

 CGeneralRandomRotation: [particles.dll]
    m_nFieldOutput = 0X000220 // ParticleAttributeIndex_t
    m_flDegrees = 0X000224 // float32
    m_flDegreesMin = 0X000228 // float32
    m_flDegreesMax = 0X00022C // float32
    m_flRotationRandExponent = 0X000230 // float32
    m_bRandomlyFlipDirection = 0X000234 // bool

 C_INIT_RandomRotation: [particles.dll]
    No schemes available

 C_INIT_Orient2DRelToCP: [particles.dll]
    m_nCP = 0X000220 // int32
    m_nFieldOutput = 0X000224 // ParticleAttributeIndex_t
    m_flRotOffset = 0X000228 // float32

 C_INIT_RandomRotationSpeed: [particles.dll]
    No schemes available

 C_INIT_RandomYaw: [particles.dll]
    No schemes available

 C_INIT_RandomColor: [particles.dll]
    m_ColorMin = 0X00023C // Color
    m_ColorMax = 0X000240 // Color
    m_TintMin = 0X000244 // Color
    m_TintMax = 0X000248 // Color
    m_flTintPerc = 0X00024C // float32
    m_flUpdateThreshold = 0X000250 // float32
    m_nTintCP = 0X000254 // int32
    m_nFieldOutput = 0X000258 // ParticleAttributeIndex_t
    m_nTintBlendMode = 0X00025C // ParticleColorBlendMode_t
    m_flLightAmplification = 0X000260 // float32

 C_INIT_ColorLitPerParticle: [particles.dll]
    m_ColorMin = 0X000238 // Color
    m_ColorMax = 0X00023C // Color
    m_TintMin = 0X000240 // Color
    m_TintMax = 0X000244 // Color
    m_flTintPerc = 0X000248 // float32
    m_nTintBlendMode = 0X00024C // ParticleColorBlendMode_t
    m_flLightAmplification = 0X000250 // float32

 C_INIT_RandomTrailLength: [particles.dll]
    m_flMinLength = 0X000220 // float32
    m_flMaxLength = 0X000224 // float32
    m_flLengthRandExponent = 0X000228 // float32

 C_INIT_RandomSequence: [particles.dll]
    m_nSequenceMin = 0X000220 // int32
    m_nSequenceMax = 0X000224 // int32
    m_bShuffle = 0X000228 // bool
    m_bLinear = 0X000229 // bool
    m_WeightedList = 0X000230 // CUtlVector< SequenceWeightedList_t >

 C_INIT_SequenceFromCP: [particles.dll]
    m_bKillUnused = 0X000220 // bool
    m_bRadiusScale = 0X000221 // bool
    m_nCP = 0X000224 // int32
    m_vecOffset = 0X000228 // Vector

 C_INIT_RandomModelSequence: [particles.dll]
    m_ActivityName = 0X000220 // char[256]
    m_SequenceName = 0X000320 // char[256]
    m_hModel = 0X000420 // CStrongHandle< InfoForResourceTypeCModel >

 C_INIT_ScaleVelocity: [particles.dll]
    m_vecScale = 0X000220 // CParticleCollectionVecInput

 C_INIT_PositionWarp: [particles.dll]
    m_vecWarpMin = 0X000220 // CParticleCollectionVecInput
    m_vecWarpMax = 0X000808 // CParticleCollectionVecInput
    m_nScaleControlPointNumber = 0X000DF0 // int32
    m_nControlPointNumber = 0X000DF4 // int32
    m_nRadiusComponent = 0X000DF8 // int32
    m_flWarpTime = 0X000DFC // float32
    m_flWarpStartTime = 0X000E00 // float32
    m_flPrevPosScale = 0X000E04 // float32
    m_bInvertWarp = 0X000E08 // bool
    m_bUseCount = 0X000E09 // bool

 C_INIT_PositionWarpScalar: [particles.dll]
    m_vecWarpMin = 0X000220 // Vector
    m_vecWarpMax = 0X00022C // Vector
    m_InputValue = 0X000238 // CPerParticleFloatInput
    m_flPrevPosScale = 0X000378 // float32
    m_nScaleControlPointNumber = 0X00037C // int32
    m_nControlPointNumber = 0X000380 // int32

 C_INIT_CreationNoise: [particles.dll]
    m_nFieldOutput = 0X000220 // ParticleAttributeIndex_t
    m_bAbsVal = 0X000224 // bool
    m_bAbsValInv = 0X000225 // bool
    m_flOffset = 0X000228 // float32
    m_flOutputMin = 0X00022C // float32
    m_flOutputMax = 0X000230 // float32
    m_flNoiseScale = 0X000234 // float32
    m_flNoiseScaleLoc = 0X000238 // float32
    m_vecOffsetLoc = 0X00023C // Vector
    m_flWorldTimeScale = 0X000248 // float32

 C_INIT_CreateAlongPath: [particles.dll]
    m_fMaxDistance = 0X000220 // float32
    m_PathParams = 0X000230 // CPathParameters
    m_bUseRandomCPs = 0X000270 // bool
    m_vEndOffset = 0X000274 // Vector
    m_bSaveOffset = 0X000280 // bool

 C_INIT_MoveBetweenPoints: [particles.dll]
    m_flSpeedMin = 0X000220 // CPerParticleFloatInput
    m_flSpeedMax = 0X000360 // CPerParticleFloatInput
    m_flEndSpread = 0X0004A0 // CPerParticleFloatInput
    m_flStartOffset = 0X0005E0 // CPerParticleFloatInput
    m_flEndOffset = 0X000720 // CPerParticleFloatInput
    m_nEndControlPointNumber = 0X000860 // int32
    m_bTrailBias = 0X000864 // bool

 C_INIT_RemapScalar: [particles.dll]
    m_nFieldInput = 0X000220 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000224 // ParticleAttributeIndex_t
    m_flInputMin = 0X000228 // float32
    m_flInputMax = 0X00022C // float32
    m_flOutputMin = 0X000230 // float32
    m_flOutputMax = 0X000234 // float32
    m_flStartTime = 0X000238 // float32
    m_flEndTime = 0X00023C // float32
    m_nSetMethod = 0X000240 // ParticleSetMethod_t
    m_bActiveRange = 0X000244 // bool
    m_flRemapBias = 0X000248 // float32

 C_INIT_RemapParticleCountToScalar: [particles.dll]
    m_nFieldOutput = 0X000220 // ParticleAttributeIndex_t
    m_nInputMin = 0X000224 // int32
    m_nInputMax = 0X000228 // int32
    m_nScaleControlPoint = 0X00022C // int32
    m_nScaleControlPointField = 0X000230 // int32
    m_flOutputMin = 0X000234 // float32
    m_flOutputMax = 0X000238 // float32
    m_nSetMethod = 0X00023C // ParticleSetMethod_t
    m_bActiveRange = 0X000240 // bool
    m_bInvert = 0X000241 // bool
    m_bWrap = 0X000242 // bool
    m_flRemapBias = 0X000244 // float32

 C_INIT_RemapParticleCountToNamedModelElementScalar: [particles.dll]
    m_hModel = 0X000250 // CStrongHandle< InfoForResourceTypeCModel >
    m_outputMinName = 0X000258 // CUtlString
    m_outputMaxName = 0X000260 // CUtlString
    m_bModelFromRenderer = 0X000268 // bool

 C_INIT_RemapParticleCountToNamedModelSequenceScalar: [particles.dll]
    No schemes available

 C_INIT_RemapParticleCountToNamedModelBodyPartScalar: [particles.dll]
    No schemes available

 C_INIT_RemapParticleCountToNamedModelMeshGroupScalar: [particles.dll]
    No schemes available

 C_INIT_InheritVelocity: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_flVelocityScale = 0X000224 // float32

 C_INIT_VelocityFromCP: [particles.dll]
    m_nControlPoint = 0X000220 // int32
    m_nControlPointCompare = 0X000224 // int32
    m_nControlPointLocal = 0X000228 // int32
    m_flVelocityScale = 0X00022C // float32
    m_bDirectionOnly = 0X000230 // bool

 C_INIT_AgeNoise: [particles.dll]
    m_bAbsVal = 0X000220 // bool
    m_bAbsValInv = 0X000221 // bool
    m_flOffset = 0X000224 // float32
    m_flAgeMin = 0X000228 // float32
    m_flAgeMax = 0X00022C // float32
    m_flNoiseScale = 0X000230 // float32
    m_flNoiseScaleLoc = 0X000234 // float32
    m_vecOffsetLoc = 0X000238 // Vector

 C_INIT_SequenceLifeTime: [particles.dll]
    m_flFramerate = 0X000220 // float32

 C_INIT_RemapScalarToVector: [particles.dll]
    m_nFieldInput = 0X000220 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000224 // ParticleAttributeIndex_t
    m_flInputMin = 0X000228 // float32
    m_flInputMax = 0X00022C // float32
    m_vecOutputMin = 0X000230 // Vector
    m_vecOutputMax = 0X00023C // Vector
    m_flStartTime = 0X000248 // float32
    m_flEndTime = 0X00024C // float32
    m_nSetMethod = 0X000250 // ParticleSetMethod_t
    m_nControlPointNumber = 0X000254 // int32
    m_bLocalCoords = 0X000258 // bool
    m_flRemapBias = 0X00025C // float32

 C_INIT_OffsetVectorToVector: [particles.dll]
    m_nFieldInput = 0X000220 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000224 // ParticleAttributeIndex_t
    m_vecOutputMin = 0X000228 // Vector
    m_vecOutputMax = 0X000234 // Vector
    m_randomnessParameters = 0X000240 // CRandomNumberGeneratorParameters

 C_INIT_CreateSequentialPathV2: [particles.dll]
    m_fMaxDistance = 0X000220 // CPerParticleFloatInput
    m_flNumToAssign = 0X000360 // CParticleCollectionFloatInput
    m_bLoop = 0X0004A0 // bool
    m_bCPPairs = 0X0004A1 // bool
    m_bSaveOffset = 0X0004A2 // bool
    m_PathParams = 0X0004B0 // CPathParameters

 C_INIT_CreateSequentialPath: [particles.dll]
    m_fMaxDistance = 0X000220 // float32
    m_flNumToAssign = 0X000224 // float32
    m_bLoop = 0X000228 // bool
    m_bCPPairs = 0X000229 // bool
    m_bSaveOffset = 0X00022A // bool
    m_PathParams = 0X000230 // CPathParameters

 C_INIT_InitialRepulsionVelocity: [particles.dll]
    m_CollisionGroupName = 0X000220 // char[128]
    m_nTraceSet = 0X0002A0 // ParticleTraceSet_t
    m_vecOutputMin = 0X0002A4 // Vector
    m_vecOutputMax = 0X0002B0 // Vector
    m_nControlPointNumber = 0X0002BC // int32
    m_bPerParticle = 0X0002C0 // bool
    m_bTranslate = 0X0002C1 // bool
    m_bProportional = 0X0002C2 // bool
    m_flTraceLength = 0X0002C4 // float32
    m_bPerParticleTR = 0X0002C8 // bool
    m_bInherit = 0X0002C9 // bool
    m_nChildCP = 0X0002CC // int32
    m_nChildGroupID = 0X0002D0 // int32

 C_INIT_RandomYawFlip: [particles.dll]
    m_flPercent = 0X000220 // float32

 C_INIT_RandomSecondSequence: [particles.dll]
    m_nSequenceMin = 0X000220 // int32
    m_nSequenceMax = 0X000224 // int32

 C_INIT_RemapCPtoScalar: [particles.dll]
    m_nCPInput = 0X000220 // int32
    m_nFieldOutput = 0X000224 // ParticleAttributeIndex_t
    m_nField = 0X000228 // int32
    m_flInputMin = 0X00022C // float32
    m_flInputMax = 0X000230 // float32
    m_flOutputMin = 0X000234 // float32
    m_flOutputMax = 0X000238 // float32
    m_flStartTime = 0X00023C // float32
    m_flEndTime = 0X000240 // float32
    m_nSetMethod = 0X000244 // ParticleSetMethod_t
    m_flRemapBias = 0X000248 // float32

 C_INIT_RemapTransformToVector: [particles.dll]
    m_nFieldOutput = 0X000220 // ParticleAttributeIndex_t
    m_vInputMin = 0X000224 // Vector
    m_vInputMax = 0X000230 // Vector
    m_vOutputMin = 0X00023C // Vector
    m_vOutputMax = 0X000248 // Vector
    m_TransformInput = 0X000258 // CParticleTransformInput
    m_LocalSpaceTransform = 0X0002A8 // CParticleTransformInput
    m_flStartTime = 0X0002F8 // float32
    m_flEndTime = 0X0002FC // float32
    m_nSetMethod = 0X000300 // ParticleSetMethod_t
    m_bOffset = 0X000304 // bool
    m_bAccelerate = 0X000305 // bool
    m_flRemapBias = 0X000308 // float32

 C_INIT_ChaoticAttractor: [particles.dll]
    m_flAParm = 0X000220 // float32
    m_flBParm = 0X000224 // float32
    m_flCParm = 0X000228 // float32
    m_flDParm = 0X00022C // float32
    m_flScale = 0X000230 // float32
    m_flSpeedMin = 0X000234 // float32
    m_flSpeedMax = 0X000238 // float32
    m_nBaseCP = 0X00023C // int32
    m_bUniformSpeed = 0X000240 // bool

 C_INIT_CreateFromParentParticles: [particles.dll]
    m_flVelocityScale = 0X000220 // float32
    m_flIncrement = 0X000224 // float32
    m_bRandomDistribution = 0X000228 // bool
    m_nRandomSeed = 0X00022C // int32
    m_bSubFrame = 0X000230 // bool

 C_INIT_InheritFromParentParticles: [particles.dll]
    m_flScale = 0X000220 // float32
    m_nFieldOutput = 0X000224 // ParticleAttributeIndex_t
    m_nIncrement = 0X000228 // int32
    m_bRandomDistribution = 0X00022C // bool
    m_nRandomSeed = 0X000230 // int32

 C_INIT_CreateFromCPs: [particles.dll]
    m_nIncrement = 0X000220 // int32
    m_nMinCP = 0X000224 // int32
    m_nMaxCP = 0X000228 // int32
    m_nDynamicCPCount = 0X000230 // CParticleCollectionFloatInput

 C_INIT_DistanceToCPInit: [particles.dll]
    m_nFieldOutput = 0X000220 // ParticleAttributeIndex_t
    m_flInputMin = 0X000228 // CPerParticleFloatInput
    m_flInputMax = 0X000368 // CPerParticleFloatInput
    m_flOutputMin = 0X0004A8 // CPerParticleFloatInput
    m_flOutputMax = 0X0005E8 // CPerParticleFloatInput
    m_nStartCP = 0X000728 // int32
    m_bLOS = 0X00072C // bool
    m_CollisionGroupName = 0X00072D // char[128]
    m_nTraceSet = 0X0007B0 // ParticleTraceSet_t
    m_flMaxTraceLength = 0X0007B8 // CPerParticleFloatInput
    m_flLOSScale = 0X0008F8 // float32
    m_nSetMethod = 0X0008FC // ParticleSetMethod_t
    m_bActiveRange = 0X000900 // bool
    m_vecDistanceScale = 0X000904 // Vector
    m_flRemapBias = 0X000910 // float32

 C_INIT_LifespanFromVelocity: [particles.dll]
    m_vecComponentScale = 0X000220 // Vector
    m_flTraceOffset = 0X00022C // float32
    m_flMaxTraceLength = 0X000230 // float32
    m_flTraceTolerance = 0X000234 // float32
    m_nMaxPlanes = 0X000238 // int32
    m_CollisionGroupName = 0X000240 // char[128]
    m_nTraceSet = 0X0002C0 // ParticleTraceSet_t
    m_bIncludeWater = 0X0002D0 // bool

 C_INIT_CreateFromPlaneCache: [particles.dll]
    m_vecOffsetMin = 0X000220 // Vector
    m_vecOffsetMax = 0X00022C // Vector
    m_bUseNormal = 0X000239 // bool

 C_INIT_ModelCull: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_bBoundBox = 0X000224 // bool
    m_bCullOutside = 0X000225 // bool
    m_bUseBones = 0X000226 // bool
    m_HitboxSetName = 0X000227 // char[128]

 C_INIT_DistanceCull: [particles.dll]
    m_nControlPoint = 0X000220 // int32
    m_flDistance = 0X000228 // CParticleCollectionFloatInput
    m_bCullInside = 0X000368 // bool

 C_INIT_PlaneCull: [particles.dll]
    m_nControlPoint = 0X000220 // int32
    m_flDistance = 0X000228 // CParticleCollectionFloatInput
    m_bCullInside = 0X000368 // bool

 C_INIT_DistanceToNeighborCull: [particles.dll]
    m_flDistance = 0X000220 // CPerParticleFloatInput

 C_INIT_RtEnvCull: [particles.dll]
    m_vecTestDir = 0X000220 // Vector
    m_vecTestNormal = 0X00022C // Vector
    m_bUseVelocity = 0X000238 // bool
    m_bCullOnMiss = 0X000239 // bool
    m_bLifeAdjust = 0X00023A // bool
    m_RtEnvName = 0X00023B // char[128]
    m_nRTEnvCP = 0X0002BC // int32
    m_nComponent = 0X0002C0 // int32

 C_INIT_NormalAlignToCP: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nControlPointAxis = 0X000224 // ParticleControlPointAxis_t

 C_INIT_NormalOffset: [particles.dll]
    m_OffsetMin = 0X000220 // Vector
    m_OffsetMax = 0X00022C // Vector
    m_nControlPointNumber = 0X000238 // int32
    m_bLocalCoords = 0X00023C // bool
    m_bNormalize = 0X00023D // bool

 C_INIT_RemapSpeedToScalar: [particles.dll]
    m_nFieldOutput = 0X000220 // ParticleAttributeIndex_t
    m_nControlPointNumber = 0X000224 // int32
    m_flStartTime = 0X000228 // float32
    m_flEndTime = 0X00022C // float32
    m_flInputMin = 0X000230 // float32
    m_flInputMax = 0X000234 // float32
    m_flOutputMin = 0X000238 // float32
    m_flOutputMax = 0X00023C // float32
    m_nSetMethod = 0X000240 // ParticleSetMethod_t
    m_bPerParticle = 0X000244 // bool

 C_INIT_InitFromCPSnapshot: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nAttributeToRead = 0X000224 // ParticleAttributeIndex_t
    m_nAttributeToWrite = 0X000228 // ParticleAttributeIndex_t
    m_nLocalSpaceCP = 0X00022C // int32
    m_bRandom = 0X000230 // bool
    m_bReverse = 0X000231 // bool
    m_nSnapShotIncrement = 0X000238 // CParticleCollectionFloatInput
    m_nRandomSeed = 0X000378 // int32
    m_bLocalSpaceAngles = 0X00037C // bool

 C_INIT_InitSkinnedPositionFromCPSnapshot: [particles.dll]
    m_nSnapshotControlPointNumber = 0X000220 // int32
    m_nControlPointNumber = 0X000224 // int32
    m_bRandom = 0X000228 // bool
    m_nRandomSeed = 0X00022C // int32
    m_bRigid = 0X000230 // bool
    m_bSetNormal = 0X000231 // bool
    m_bIgnoreDt = 0X000232 // bool
    m_flMinNormalVelocity = 0X000234 // float32
    m_flMaxNormalVelocity = 0X000238 // float32
    m_flIncrement = 0X00023C // float32
    m_nFullLoopIncrement = 0X000240 // int32
    m_nSnapShotStartPoint = 0X000244 // int32
    m_flBoneVelocity = 0X000248 // float32
    m_flBoneVelocityMax = 0X00024C // float32
    m_bCopyColor = 0X000250 // bool
    m_bCopyAlpha = 0X000251 // bool
    m_bSetRadius = 0X000252 // bool

 C_INIT_InitFromParentKilled: [particles.dll]
    m_nAttributeToCopy = 0X000220 // ParticleAttributeIndex_t

 C_INIT_InitFromVectorFieldSnapshot: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nLocalSpaceCP = 0X000224 // int32
    m_nWeightUpdateCP = 0X000228 // int32
    m_bUseVerticalVelocity = 0X00022C // bool
    m_vecScale = 0X000230 // CPerParticleVecInput

 C_INIT_RemapInitialDirectionToTransformToVector: [particles.dll]
    m_TransformInput = 0X000220 // CParticleTransformInput
    m_nFieldOutput = 0X000270 // ParticleAttributeIndex_t
    m_flScale = 0X000274 // float32
    m_flOffsetRot = 0X000278 // float32
    m_vecOffsetAxis = 0X00027C // Vector
    m_bNormalize = 0X000288 // bool

 C_INIT_RemapInitialTransformDirectionToRotation: [particles.dll]
    m_TransformInput = 0X000220 // CParticleTransformInput
    m_nFieldOutput = 0X000270 // ParticleAttributeIndex_t
    m_flOffsetRot = 0X000274 // float32
    m_nComponent = 0X000278 // int32

 C_INIT_RemapQAnglesToRotation: [particles.dll]
    m_TransformInput = 0X000220 // CParticleTransformInput

 C_INIT_RemapTransformOrientationToRotations: [particles.dll]
    m_TransformInput = 0X000220 // CParticleTransformInput
    m_vecRotation = 0X000270 // Vector
    m_bUseQuat = 0X00027C // bool
    m_bWriteNormal = 0X00027D // bool

 C_INIT_SetRigidAttachment: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nFieldInput = 0X000224 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000228 // ParticleAttributeIndex_t
    m_bLocalSpace = 0X00022C // bool

 C_INIT_RemapInitialVisibilityScalar: [particles.dll]
    m_nFieldOutput = 0X000224 // ParticleAttributeIndex_t
    m_flInputMin = 0X000228 // float32
    m_flInputMax = 0X00022C // float32
    m_flOutputMin = 0X000230 // float32
    m_flOutputMax = 0X000234 // float32

 C_INIT_RadiusFromCPObject: [particles.dll]
    m_nControlPoint = 0X000220 // int32

 C_INIT_InitialSequenceFromModel: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_nFieldOutput = 0X000224 // ParticleAttributeIndex_t
    m_nFieldOutputAnim = 0X000228 // ParticleAttributeIndex_t
    m_flInputMin = 0X00022C // float32
    m_flInputMax = 0X000230 // float32
    m_flOutputMin = 0X000234 // float32
    m_flOutputMax = 0X000238 // float32
    m_nSetMethod = 0X00023C // ParticleSetMethod_t

 C_INIT_GlobalScale: [particles.dll]
    m_flScale = 0X000220 // float32
    m_nScaleControlPointNumber = 0X000224 // int32
    m_nControlPointNumber = 0X000228 // int32
    m_bScaleRadius = 0X00022C // bool
    m_bScalePosition = 0X00022D // bool
    m_bScaleVelocity = 0X00022E // bool

 C_INIT_PointList: [particles.dll]
    m_nFieldOutput = 0X000220 // ParticleAttributeIndex_t
    m_pointList = 0X000228 // CUtlVector< PointDefinition_t >
    m_bPlaceAlongPath = 0X000240 // bool
    m_bClosedLoop = 0X000241 // bool
    m_nNumPointsAlongPath = 0X000244 // int32

 C_INIT_RandomNamedModelElement: [particles.dll]
    m_hModel = 0X000220 // CStrongHandle< InfoForResourceTypeCModel >
    m_names = 0X000228 // CUtlVector< CUtlString >
    m_bShuffle = 0X000240 // bool
    m_bLinear = 0X000241 // bool
    m_bModelFromRenderer = 0X000242 // bool
    m_nFieldOutput = 0X000244 // ParticleAttributeIndex_t

 C_INIT_RandomNamedModelSequence: [particles.dll]
    No schemes available

 C_INIT_RandomNamedModelBodyPart: [particles.dll]
    No schemes available

 C_INIT_RandomNamedModelMeshGroup: [particles.dll]
    No schemes available

 C_INIT_RemapNamedModelElementToScalar: [particles.dll]
    m_hModel = 0X000220 // CStrongHandle< InfoForResourceTypeCModel >
    m_names = 0X000228 // CUtlVector< CUtlString >
    m_values = 0X000240 // CUtlVector< float32 >
    m_nFieldInput = 0X000258 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X00025C // ParticleAttributeIndex_t
    m_nSetMethod = 0X000260 // ParticleSetMethod_t
    m_bModelFromRenderer = 0X000264 // bool

 C_INIT_RemapNamedModelSequenceToScalar: [particles.dll]
    No schemes available

 C_INIT_RemapNamedModelBodyPartToScalar: [particles.dll]
    No schemes available

 C_INIT_RemapNamedModelMeshGroupToScalar: [particles.dll]
    No schemes available

 C_INIT_StatusEffect: [particles.dll]
    m_nDetail2Combo = 0X000220 // Detail2Combo_t
    m_flDetail2Rotation = 0X000224 // float32
    m_flDetail2Scale = 0X000228 // float32
    m_flDetail2BlendFactor = 0X00022C // float32
    m_flColorWarpIntensity = 0X000230 // float32
    m_flDiffuseWarpBlendToFull = 0X000234 // float32
    m_flEnvMapIntensity = 0X000238 // float32
    m_flAmbientScale = 0X00023C // float32
    m_specularColor = 0X000240 // Color
    m_flSpecularScale = 0X000244 // float32
    m_flSpecularExponent = 0X000248 // float32
    m_flSpecularExponentBlendToFull = 0X00024C // float32
    m_flSpecularBlendToFull = 0X000250 // float32
    m_rimLightColor = 0X000254 // Color
    m_flRimLightScale = 0X000258 // float32
    m_flReflectionsTintByBaseBlendToNone = 0X00025C // float32
    m_flMetalnessBlendToFull = 0X000260 // float32
    m_flSelfIllumBlendToFull = 0X000264 // float32

 C_INIT_StatusEffectCitadel: [particles.dll]
    m_flSFXColorWarpAmount = 0X000220 // float32
    m_flSFXNormalAmount = 0X000224 // float32
    m_flSFXMetalnessAmount = 0X000228 // float32
    m_flSFXRoughnessAmount = 0X00022C // float32
    m_flSFXSelfIllumAmount = 0X000230 // float32
    m_flSFXSScale = 0X000234 // float32
    m_flSFXSScrollX = 0X000238 // float32
    m_flSFXSScrollY = 0X00023C // float32
    m_flSFXSScrollZ = 0X000240 // float32
    m_flSFXSOffsetX = 0X000244 // float32
    m_flSFXSOffsetY = 0X000248 // float32
    m_flSFXSOffsetZ = 0X00024C // float32
    m_nDetailCombo = 0X000250 // DetailCombo_t
    m_flSFXSDetailAmount = 0X000254 // float32
    m_flSFXSDetailScale = 0X000258 // float32
    m_flSFXSDetailScrollX = 0X00025C // float32
    m_flSFXSDetailScrollY = 0X000260 // float32
    m_flSFXSDetailScrollZ = 0X000264 // float32
    m_flSFXSUseModelUVs = 0X000268 // float32

 C_INIT_CreateParticleImpulse: [particles.dll]
    m_InputRadius = 0X000220 // CPerParticleFloatInput
    m_InputMagnitude = 0X000360 // CPerParticleFloatInput
    m_nFalloffFunction = 0X0004A0 // ParticleFalloffFunction_t
    m_InputFalloffExp = 0X0004A8 // CPerParticleFloatInput
    m_nImpulseType = 0X0005E8 // ParticleImpulseType_t

 C_INIT_QuantizeFloat: [particles.dll]
    m_InputValue = 0X000220 // CPerParticleFloatInput
    m_nOutputField = 0X000360 // ParticleAttributeIndex_t

 C_INIT_SetVectorAttributeToVectorExpression: [particles.dll]
    m_nExpression = 0X000220 // VectorExpressionType_t
    m_vInput1 = 0X000228 // CPerParticleVecInput
    m_vInput2 = 0X000810 // CPerParticleVecInput
    m_nOutputField = 0X000DF8 // ParticleAttributeIndex_t
    m_nSetMethod = 0X000DFC // ParticleSetMethod_t
    m_bNormalizedOutput = 0X000E00 // bool

 C_INIT_InitFloatCollection: [particles.dll]
    m_InputValue = 0X000220 // CParticleCollectionFloatInput
    m_nOutputField = 0X000360 // ParticleAttributeIndex_t

 C_INIT_InitFloat: [particles.dll]
    m_InputValue = 0X000220 // CPerParticleFloatInput
    m_nOutputField = 0X000360 // ParticleAttributeIndex_t
    m_nSetMethod = 0X000364 // ParticleSetMethod_t
    m_InputStrength = 0X000368 // CPerParticleFloatInput

 C_INIT_InitVecCollection: [particles.dll]
    m_InputValue = 0X000220 // CParticleCollectionVecInput
    m_nOutputField = 0X000808 // ParticleAttributeIndex_t

 C_INIT_InitVec: [particles.dll]
    m_InputValue = 0X000220 // CPerParticleVecInput
    m_nOutputField = 0X000808 // ParticleAttributeIndex_t
    m_nSetMethod = 0X00080C // ParticleSetMethod_t
    m_bNormalizedOutput = 0X000810 // bool
    m_bWritePreviousPosition = 0X000811 // bool

 C_OP_InstantaneousEmitter: [particles.dll]
    m_nParticlesToEmit = 0X000220 // CParticleCollectionFloatInput
    m_flStartTime = 0X000360 // CParticleCollectionFloatInput
    m_flInitFromKilledParentParticles = 0X0004A0 // float32
    m_nMaxEmittedPerFrame = 0X0004A4 // int32
    m_nSnapshotControlPoint = 0X0004A8 // int32

 C_OP_ContinuousEmitter: [particles.dll]
    m_flEmissionDuration = 0X000220 // CParticleCollectionFloatInput
    m_flStartTime = 0X000360 // CParticleCollectionFloatInput
    m_flEmitRate = 0X0004A0 // CParticleCollectionFloatInput
    m_flEmissionScale = 0X0005E0 // float32
    m_flScalePerParentParticle = 0X0005E4 // float32
    m_bInitFromKilledParentParticles = 0X0005E8 // bool
    m_nSnapshotControlPoint = 0X0005EC // int32
    m_nLimitPerUpdate = 0X0005F0 // int32
    m_bForceEmitOnFirstUpdate = 0X0005F4 // bool
    m_bForceEmitOnLastUpdate = 0X0005F5 // bool

 C_OP_NoiseEmitter: [particles.dll]
    m_flEmissionDuration = 0X000220 // float32
    m_flStartTime = 0X000224 // float32
    m_flEmissionScale = 0X000228 // float32
    m_nScaleControlPoint = 0X00022C // int32
    m_nScaleControlPointField = 0X000230 // int32
    m_nWorldNoisePoint = 0X000234 // int32
    m_bAbsVal = 0X000238 // bool
    m_bAbsValInv = 0X000239 // bool
    m_flOffset = 0X00023C // float32
    m_flOutputMin = 0X000240 // float32
    m_flOutputMax = 0X000244 // float32
    m_flNoiseScale = 0X000248 // float32
    m_flWorldNoiseScale = 0X00024C // float32
    m_vecOffsetLoc = 0X000250 // Vector
    m_flWorldTimeScale = 0X00025C // float32

 C_OP_MaintainEmitter: [particles.dll]
    m_nParticlesToMaintain = 0X000220 // int32
    m_flStartTime = 0X000224 // float32
    m_flEmissionDuration = 0X000228 // CParticleCollectionFloatInput
    m_flEmissionRate = 0X000368 // float32
    m_nSnapshotControlPoint = 0X00036C // int32
    m_bEmitInstantaneously = 0X000370 // bool
    m_bFinalEmitOnStop = 0X000371 // bool
    m_flScale = 0X000378 // CParticleCollectionFloatInput

 C_OP_RandomForce: [particles.dll]
    m_MinForce = 0X000210 // Vector
    m_MaxForce = 0X00021C // Vector

 C_OP_CPVelocityForce: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_flScale = 0X000218 // CPerParticleFloatInput

 C_OP_ParentVortices: [particles.dll]
    m_flForceScale = 0X000210 // float32
    m_vecTwistAxis = 0X000214 // Vector
    m_bFlipBasedOnYaw = 0X000220 // bool

 C_OP_TwistAroundAxis: [particles.dll]
    m_fForceAmount = 0X000210 // float32
    m_TwistAxis = 0X000214 // Vector
    m_bLocalSpace = 0X000220 // bool
    m_nControlPointNumber = 0X000224 // int32

 C_OP_AttractToControlPoint: [particles.dll]
    m_vecComponentScale = 0X000210 // Vector
    m_fForceAmount = 0X000220 // CPerParticleFloatInput
    m_fFalloffPower = 0X000360 // float32
    m_TransformInput = 0X000368 // CParticleTransformInput
    m_fForceAmountMin = 0X0003B8 // CPerParticleFloatInput
    m_bApplyMinForce = 0X0004F8 // bool

 C_OP_ForceBasedOnDistanceToPlane: [particles.dll]
    m_flMinDist = 0X000210 // float32
    m_vecForceAtMinDist = 0X000214 // Vector
    m_flMaxDist = 0X000220 // float32
    m_vecForceAtMaxDist = 0X000224 // Vector
    m_vecPlaneNormal = 0X000230 // Vector
    m_nControlPointNumber = 0X00023C // int32
    m_flExponent = 0X000240 // float32

 C_OP_TimeVaryingForce: [particles.dll]
    m_flStartLerpTime = 0X000210 // float32
    m_StartingForce = 0X000214 // Vector
    m_flEndLerpTime = 0X000220 // float32
    m_EndingForce = 0X000224 // Vector

 C_OP_TurbulenceForce: [particles.dll]
    m_flNoiseCoordScale0 = 0X000210 // float32
    m_flNoiseCoordScale1 = 0X000214 // float32
    m_flNoiseCoordScale2 = 0X000218 // float32
    m_flNoiseCoordScale3 = 0X00021C // float32
    m_vecNoiseAmount0 = 0X000220 // Vector
    m_vecNoiseAmount1 = 0X00022C // Vector
    m_vecNoiseAmount2 = 0X000238 // Vector
    m_vecNoiseAmount3 = 0X000244 // Vector

 C_OP_CurlNoiseForce: [particles.dll]
    m_nNoiseType = 0X000210 // ParticleDirectionNoiseType_t
    m_vecNoiseFreq = 0X000218 // CPerParticleVecInput
    m_vecNoiseScale = 0X000800 // CPerParticleVecInput
    m_vecOffsetRate = 0X000DE8 // CPerParticleVecInput
    m_flWorleySeed = 0X0013D0 // CPerParticleFloatInput
    m_flWorleyJitter = 0X001510 // CPerParticleFloatInput

 C_OP_PerParticleForce: [particles.dll]
    m_flForceScale = 0X000210 // CPerParticleFloatInput
    m_vForce = 0X000350 // CPerParticleVecInput
    m_nCP = 0X000938 // int32

 C_OP_WindForce: [particles.dll]
    m_vForce = 0X000210 // Vector

 C_OP_ExternalWindForce: [particles.dll]
    m_vecSamplePosition = 0X000210 // CPerParticleVecInput
    m_vecScale = 0X0007F8 // CPerParticleVecInput
    m_bSampleWind = 0X000DE0 // bool
    m_bSampleWater = 0X000DE1 // bool

 C_OP_ExternalGameImpulseForce: [particles.dll]
    m_flForceScale = 0X000210 // CPerParticleFloatInput
    m_bRopes = 0X000350 // bool
    m_bRopesZOnly = 0X000351 // bool
    m_bExplosions = 0X000352 // bool
    m_bParticles = 0X000353 // bool

 C_OP_LocalAccelerationForce: [particles.dll]
    m_nCP = 0X000210 // int32
    m_nScaleCP = 0X000214 // int32
    m_vecAccel = 0X000218 // CParticleCollectionVecInput

 C_OP_ScreenForceFromPlayerView: [particles.dll]
    m_flAccel = 0X000210 // float32

 C_OP_ExternalGenericForce: [particles.dll]
    m_flStrength = 0X000210 // float32
    m_flCurlStrength = 0X000214 // float32
    m_flLinearStrength = 0X000218 // float32
    m_flRadialStrength = 0X00021C // float32
    m_flRotationStrength = 0X000220 // float32

 C_OP_DensityForce: [particles.dll]
    m_flRadiusScale = 0X000210 // float32
    m_flForceScale = 0X000214 // float32

 C_OP_BasicMovement: [particles.dll]
    m_Gravity = 0X000210 // Vector
    m_fDrag = 0X00021C // float32
    m_nMaxConstraintPasses = 0X000220 // int32

 C_OP_FadeAndKill: [particles.dll]
    m_flStartFadeInTime = 0X000210 // float32
    m_flEndFadeInTime = 0X000214 // float32
    m_flStartFadeOutTime = 0X000218 // float32
    m_flEndFadeOutTime = 0X00021C // float32
    m_flStartAlpha = 0X000220 // float32
    m_flEndAlpha = 0X000224 // float32
    m_bForcePreserveParticleOrder = 0X000228 // bool

 C_OP_FadeAndKillForTracers: [particles.dll]
    m_flStartFadeInTime = 0X000210 // float32
    m_flEndFadeInTime = 0X000214 // float32
    m_flStartFadeOutTime = 0X000218 // float32
    m_flEndFadeOutTime = 0X00021C // float32
    m_flStartAlpha = 0X000220 // float32
    m_flEndAlpha = 0X000224 // float32

 C_OP_FadeIn: [particles.dll]
    m_flFadeInTimeMin = 0X000210 // float32
    m_flFadeInTimeMax = 0X000214 // float32
    m_flFadeInTimeExp = 0X000218 // float32
    m_bProportional = 0X00021C // bool

 C_OP_FadeOut: [particles.dll]
    m_flFadeOutTimeMin = 0X000210 // float32
    m_flFadeOutTimeMax = 0X000214 // float32
    m_flFadeOutTimeExp = 0X000218 // float32
    m_flFadeBias = 0X00021C // float32
    m_bProportional = 0X000250 // bool
    m_bEaseInAndOut = 0X000251 // bool

 C_OP_FadeInSimple: [particles.dll]
    m_flFadeInTime = 0X000210 // float32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t

 C_OP_FadeOutSimple: [particles.dll]
    m_flFadeOutTime = 0X000210 // float32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t

 C_OP_ClampScalar: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flOutputMin = 0X000218 // CPerParticleFloatInput
    m_flOutputMax = 0X000358 // CPerParticleFloatInput

 C_OP_ClampVector: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_vecOutputMin = 0X000218 // CPerParticleVecInput
    m_vecOutputMax = 0X000800 // CPerParticleVecInput

 C_OP_OscillateScalar: [particles.dll]
    m_RateMin = 0X000210 // float32
    m_RateMax = 0X000214 // float32
    m_FrequencyMin = 0X000218 // float32
    m_FrequencyMax = 0X00021C // float32
    m_nField = 0X000220 // ParticleAttributeIndex_t
    m_bProportional = 0X000224 // bool
    m_bProportionalOp = 0X000225 // bool
    m_flStartTime_min = 0X000228 // float32
    m_flStartTime_max = 0X00022C // float32
    m_flEndTime_min = 0X000230 // float32
    m_flEndTime_max = 0X000234 // float32
    m_flOscMult = 0X000238 // float32
    m_flOscAdd = 0X00023C // float32

 C_OP_OscillateScalarSimple: [particles.dll]
    m_Rate = 0X000210 // float32
    m_Frequency = 0X000214 // float32
    m_nField = 0X000218 // ParticleAttributeIndex_t
    m_flOscMult = 0X00021C // float32
    m_flOscAdd = 0X000220 // float32

 C_OP_OscillateVector: [particles.dll]
    m_RateMin = 0X000210 // Vector
    m_RateMax = 0X00021C // Vector
    m_FrequencyMin = 0X000228 // Vector
    m_FrequencyMax = 0X000234 // Vector
    m_nField = 0X000240 // ParticleAttributeIndex_t
    m_bProportional = 0X000244 // bool
    m_bProportionalOp = 0X000245 // bool
    m_bOffset = 0X000246 // bool
    m_flStartTime_min = 0X000248 // float32
    m_flStartTime_max = 0X00024C // float32
    m_flEndTime_min = 0X000250 // float32
    m_flEndTime_max = 0X000254 // float32
    m_flOscMult = 0X000258 // CPerParticleFloatInput
    m_flOscAdd = 0X000398 // CPerParticleFloatInput
    m_flRateScale = 0X0004D8 // CPerParticleFloatInput

 C_OP_OscillateVectorSimple: [particles.dll]
    m_Rate = 0X000210 // Vector
    m_Frequency = 0X00021C // Vector
    m_nField = 0X000228 // ParticleAttributeIndex_t
    m_flOscMult = 0X00022C // float32
    m_flOscAdd = 0X000230 // float32
    m_bOffset = 0X000234 // bool

 C_OP_DifferencePreviousParticle: [particles.dll]
    m_nFieldInput = 0X000210 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_flInputMin = 0X000218 // float32
    m_flInputMax = 0X00021C // float32
    m_flOutputMin = 0X000220 // float32
    m_flOutputMax = 0X000224 // float32
    m_nSetMethod = 0X000228 // ParticleSetMethod_t
    m_bActiveRange = 0X00022C // bool
    m_bSetPreviousParticle = 0X00022D // bool

 C_OP_PointVectorAtNextParticle: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flInterpolation = 0X000218 // CPerParticleFloatInput

 C_OP_RemapScalar: [particles.dll]
    m_nFieldInput = 0X000210 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_flInputMin = 0X000218 // float32
    m_flInputMax = 0X00021C // float32
    m_flOutputMin = 0X000220 // float32
    m_flOutputMax = 0X000224 // float32

 C_OP_RemapDensityToVector: [particles.dll]
    m_flRadiusScale = 0X000210 // float32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_flDensityMin = 0X000218 // float32
    m_flDensityMax = 0X00021C // float32
    m_vecOutputMin = 0X000220 // Vector
    m_vecOutputMax = 0X00022C // Vector

 C_OP_RemapScalarEndCap: [particles.dll]
    m_nFieldInput = 0X000210 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_flInputMin = 0X000218 // float32
    m_flInputMax = 0X00021C // float32
    m_flOutputMin = 0X000220 // float32
    m_flOutputMax = 0X000224 // float32

 C_OP_ReinitializeScalarEndCap: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flOutputMin = 0X000214 // float32
    m_flOutputMax = 0X000218 // float32

 C_OP_RemapScalarOnceTimed: [particles.dll]
    m_bProportional = 0X000210 // bool
    m_nFieldInput = 0X000214 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000218 // ParticleAttributeIndex_t
    m_flInputMin = 0X00021C // float32
    m_flInputMax = 0X000220 // float32
    m_flOutputMin = 0X000224 // float32
    m_flOutputMax = 0X000228 // float32
    m_flRemapTime = 0X00022C // float32

 C_OP_RemapParticleCountOnScalarEndCap: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_nInputMin = 0X000214 // int32
    m_nInputMax = 0X000218 // int32
    m_flOutputMin = 0X00021C // float32
    m_flOutputMax = 0X000220 // float32
    m_bBackwards = 0X000224 // bool
    m_nSetMethod = 0X000228 // ParticleSetMethod_t

 C_OP_RemapParticleCountToScalar: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_nInputMin = 0X000218 // CParticleCollectionFloatInput
    m_nInputMax = 0X000358 // CParticleCollectionFloatInput
    m_flOutputMin = 0X000498 // CParticleCollectionFloatInput
    m_flOutputMax = 0X0005D8 // CParticleCollectionFloatInput
    m_bActiveRange = 0X000718 // bool
    m_nSetMethod = 0X00071C // ParticleSetMethod_t

 C_OP_RemapVisibilityScalar: [particles.dll]
    m_nFieldInput = 0X000210 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_flInputMin = 0X000218 // float32
    m_flInputMax = 0X00021C // float32
    m_flOutputMin = 0X000220 // float32
    m_flOutputMax = 0X000224 // float32
    m_flRadiusScale = 0X000228 // float32

 C_OP_RemapTransformVisibilityToScalar: [particles.dll]
    m_nSetMethod = 0X000210 // ParticleSetMethod_t
    m_TransformInput = 0X000218 // CParticleTransformInput
    m_nFieldOutput = 0X000268 // ParticleAttributeIndex_t
    m_flInputMin = 0X00026C // float32
    m_flInputMax = 0X000270 // float32
    m_flOutputMin = 0X000274 // float32
    m_flOutputMax = 0X000278 // float32
    m_flRadius = 0X00027C // float32

 C_OP_RemapTransformVisibilityToVector: [particles.dll]
    m_nSetMethod = 0X000210 // ParticleSetMethod_t
    m_TransformInput = 0X000218 // CParticleTransformInput
    m_nFieldOutput = 0X000268 // ParticleAttributeIndex_t
    m_flInputMin = 0X00026C // float32
    m_flInputMax = 0X000270 // float32
    m_vecOutputMin = 0X000274 // Vector
    m_vecOutputMax = 0X000280 // Vector
    m_flRadius = 0X00028C // float32

 C_OP_LerpScalar: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flOutput = 0X000218 // CPerParticleFloatInput
    m_flStartTime = 0X000358 // float32
    m_flEndTime = 0X00035C // float32

 C_OP_LerpEndCapScalar: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flOutput = 0X000214 // float32
    m_flLerpTime = 0X000218 // float32

 C_OP_LerpEndCapVector: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_vecOutput = 0X000214 // Vector
    m_flLerpTime = 0X000220 // float32

 C_OP_LerpVector: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_vecOutput = 0X000214 // Vector
    m_flStartTime = 0X000220 // float32
    m_flEndTime = 0X000224 // float32
    m_nSetMethod = 0X000228 // ParticleSetMethod_t

 C_OP_LerpToOtherAttribute: [particles.dll]
    m_flInterpolation = 0X000210 // CPerParticleFloatInput
    m_nFieldInputFrom = 0X000350 // ParticleAttributeIndex_t
    m_nFieldInput = 0X000354 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000358 // ParticleAttributeIndex_t

 C_OP_RemapSpeed: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flInputMin = 0X000214 // float32
    m_flInputMax = 0X000218 // float32
    m_flOutputMin = 0X00021C // float32
    m_flOutputMax = 0X000220 // float32
    m_nSetMethod = 0X000224 // ParticleSetMethod_t
    m_bIgnoreDelta = 0X000228 // bool

 C_OP_RemapVectortoCP: [particles.dll]
    m_nOutControlPointNumber = 0X000210 // int32
    m_nFieldInput = 0X000214 // ParticleAttributeIndex_t
    m_nParticleNumber = 0X000218 // int32

 C_OP_RampScalarLinear: [particles.dll]
    m_RateMin = 0X000210 // float32
    m_RateMax = 0X000214 // float32
    m_flStartTime_min = 0X000218 // float32
    m_flStartTime_max = 0X00021C // float32
    m_flEndTime_min = 0X000220 // float32
    m_flEndTime_max = 0X000224 // float32
    m_nField = 0X000250 // ParticleAttributeIndex_t
    m_bProportionalOp = 0X000254 // bool

 C_OP_RampScalarSpline: [particles.dll]
    m_RateMin = 0X000210 // float32
    m_RateMax = 0X000214 // float32
    m_flStartTime_min = 0X000218 // float32
    m_flStartTime_max = 0X00021C // float32
    m_flEndTime_min = 0X000220 // float32
    m_flEndTime_max = 0X000224 // float32
    m_flBias = 0X000228 // float32
    m_nField = 0X000250 // ParticleAttributeIndex_t
    m_bProportionalOp = 0X000254 // bool
    m_bEaseOut = 0X000255 // bool

 C_OP_RampScalarLinearSimple: [particles.dll]
    m_Rate = 0X000210 // float32
    m_flStartTime = 0X000214 // float32
    m_flEndTime = 0X000218 // float32
    m_nField = 0X000240 // ParticleAttributeIndex_t

 C_OP_RampScalarSplineSimple: [particles.dll]
    m_Rate = 0X000210 // float32
    m_flStartTime = 0X000214 // float32
    m_flEndTime = 0X000218 // float32
    m_nField = 0X000240 // ParticleAttributeIndex_t
    m_bEaseOut = 0X000244 // bool

 C_OP_ChladniWave: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flInputMin = 0X000218 // CPerParticleFloatInput
    m_flInputMax = 0X000358 // CPerParticleFloatInput
    m_flOutputMin = 0X000498 // CPerParticleFloatInput
    m_flOutputMax = 0X0005D8 // CPerParticleFloatInput
    m_vecWaveLength = 0X000718 // CPerParticleVecInput
    m_vecHarmonics = 0X000D00 // CPerParticleVecInput
    m_nSetMethod = 0X0012E8 // ParticleSetMethod_t
    m_nLocalSpaceControlPoint = 0X0012EC // int32
    m_b3D = 0X0012F0 // bool

 C_OP_Noise: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flOutputMin = 0X000214 // float32
    m_flOutputMax = 0X000218 // float32
    m_fl4NoiseScale = 0X00021C // float32
    m_bAdditive = 0X000220 // bool
    m_flNoiseAnimationTimeScale = 0X000224 // float32

 C_OP_VectorNoise: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_vecOutputMin = 0X000214 // Vector
    m_vecOutputMax = 0X000220 // Vector
    m_fl4NoiseScale = 0X00022C // float32
    m_bAdditive = 0X000230 // bool
    m_bOffset = 0X000231 // bool
    m_flNoiseAnimationTimeScale = 0X000234 // float32

 C_OP_Decay: [particles.dll]
    m_bRopeDecay = 0X000210 // bool
    m_bForcePreserveParticleOrder = 0X000211 // bool

 C_OP_DecayOffscreen: [particles.dll]
    m_flOffscreenTime = 0X000210 // CParticleCollectionFloatInput

 C_OP_EndCapTimedFreeze: [particles.dll]
    m_flFreezeTime = 0X000210 // CParticleCollectionFloatInput

 C_OP_EndCapTimedDecay: [particles.dll]
    m_flDecayTime = 0X000210 // float32

 C_OP_EndCapDecay: [particles.dll]
    No schemes available

 C_OP_VelocityDecay: [particles.dll]
    m_flMinVelocity = 0X000210 // float32

 C_OP_AlphaDecay: [particles.dll]
    m_flMinAlpha = 0X000210 // float32

 C_OP_RadiusDecay: [particles.dll]
    m_flMinRadius = 0X000210 // float32

 C_OP_DecayMaintainCount: [particles.dll]
    m_nParticlesToMaintain = 0X000210 // int32
    m_flDecayDelay = 0X000214 // float32
    m_nSnapshotControlPoint = 0X000218 // int32
    m_bLifespanDecay = 0X00021C // bool
    m_flScale = 0X000220 // CParticleCollectionFloatInput
    m_bKillNewest = 0X000360 // bool

 C_OP_DecayClampCount: [particles.dll]
    m_nCount = 0X000210 // CParticleCollectionFloatInput

 C_OP_Cull: [particles.dll]
    m_flCullPerc = 0X000210 // float32
    m_flCullStart = 0X000214 // float32
    m_flCullEnd = 0X000218 // float32
    m_flCullExp = 0X00021C // float32

 CGeneralSpin: [particles.dll]
    m_nSpinRateDegrees = 0X000210 // int32
    m_nSpinRateMinDegrees = 0X000214 // int32
    m_fSpinRateStopTime = 0X00021C // float32

 CSpinUpdateBase: [particles.dll]
    No schemes available

 C_OP_Spin: [particles.dll]
    No schemes available

 C_OP_SpinUpdate: [particles.dll]
    No schemes available

 C_OP_SpinYaw: [particles.dll]
    No schemes available

 C_OP_InterpolateRadius: [particles.dll]
    m_flStartTime = 0X000210 // float32
    m_flEndTime = 0X000214 // float32
    m_flStartScale = 0X000218 // float32
    m_flEndScale = 0X00021C // float32
    m_bEaseInAndOut = 0X000220 // bool
    m_flBias = 0X000224 // float32

 C_OP_ColorInterpolate: [particles.dll]
    m_ColorFade = 0X000210 // Color
    m_flFadeStartTime = 0X000220 // float32
    m_flFadeEndTime = 0X000224 // float32
    m_nFieldOutput = 0X000228 // ParticleAttributeIndex_t
    m_bEaseInOut = 0X00022C // bool

 C_OP_ColorInterpolateRandom: [particles.dll]
    m_ColorFadeMin = 0X000210 // Color
    m_ColorFadeMax = 0X00022C // Color
    m_flFadeStartTime = 0X00023C // float32
    m_flFadeEndTime = 0X000240 // float32
    m_nFieldOutput = 0X000244 // ParticleAttributeIndex_t
    m_bEaseInOut = 0X000248 // bool

 C_OP_PositionLock: [particles.dll]
    m_TransformInput = 0X000210 // CParticleTransformInput
    m_flStartTime_min = 0X000260 // float32
    m_flStartTime_max = 0X000264 // float32
    m_flStartTime_exp = 0X000268 // float32
    m_flEndTime_min = 0X00026C // float32
    m_flEndTime_max = 0X000270 // float32
    m_flEndTime_exp = 0X000274 // float32
    m_flRange = 0X000278 // float32
    m_flRangeBias = 0X000280 // CParticleCollectionFloatInput
    m_flJumpThreshold = 0X0003C0 // float32
    m_flPrevPosScale = 0X0003C4 // float32
    m_bLockRot = 0X0003C8 // bool
    m_vecScale = 0X0003D0 // CParticleCollectionVecInput
    m_nFieldOutput = 0X0009B8 // ParticleAttributeIndex_t
    m_nFieldOutputPrev = 0X0009BC // ParticleAttributeIndex_t

 C_OP_ControlpointLight: [particles.dll]
    m_flScale = 0X000210 // float32
    m_nControlPoint1 = 0X0006E0 // int32
    m_nControlPoint2 = 0X0006E4 // int32
    m_nControlPoint3 = 0X0006E8 // int32
    m_nControlPoint4 = 0X0006EC // int32
    m_vecCPOffset1 = 0X0006F0 // Vector
    m_vecCPOffset2 = 0X0006FC // Vector
    m_vecCPOffset3 = 0X000708 // Vector
    m_vecCPOffset4 = 0X000714 // Vector
    m_LightFiftyDist1 = 0X000720 // float32
    m_LightZeroDist1 = 0X000724 // float32
    m_LightFiftyDist2 = 0X000728 // float32
    m_LightZeroDist2 = 0X00072C // float32
    m_LightFiftyDist3 = 0X000730 // float32
    m_LightZeroDist3 = 0X000734 // float32
    m_LightFiftyDist4 = 0X000738 // float32
    m_LightZeroDist4 = 0X00073C // float32
    m_LightColor1 = 0X000740 // Color
    m_LightColor2 = 0X000744 // Color
    m_LightColor3 = 0X000748 // Color
    m_LightColor4 = 0X00074C // Color
    m_bLightType1 = 0X000750 // bool
    m_bLightType2 = 0X000751 // bool
    m_bLightType3 = 0X000752 // bool
    m_bLightType4 = 0X000753 // bool
    m_bLightDynamic1 = 0X000754 // bool
    m_bLightDynamic2 = 0X000755 // bool
    m_bLightDynamic3 = 0X000756 // bool
    m_bLightDynamic4 = 0X000757 // bool
    m_bUseNormal = 0X000758 // bool
    m_bUseHLambert = 0X000759 // bool
    m_bClampLowerRange = 0X00075E // bool
    m_bClampUpperRange = 0X00075F // bool

 C_OP_GlobalLight: [particles.dll]
    m_flScale = 0X000210 // float32
    m_bClampLowerRange = 0X000214 // bool
    m_bClampUpperRange = 0X000215 // bool

 C_OP_SetChildControlPoints: [particles.dll]
    m_nChildGroupID = 0X000210 // int32
    m_nFirstControlPoint = 0X000214 // int32
    m_nNumControlPoints = 0X000218 // int32
    m_nFirstSourcePoint = 0X000220 // CParticleCollectionFloatInput
    m_bSetOrientation = 0X000360 // bool

 C_OP_SetControlPointsToParticle: [particles.dll]
    m_nChildGroupID = 0X000210 // int32
    m_nFirstControlPoint = 0X000214 // int32
    m_nNumControlPoints = 0X000218 // int32
    m_nFirstSourcePoint = 0X00021C // int32
    m_bSetOrientation = 0X000220 // bool
    m_nOrientationMode = 0X000224 // ParticleOrientationSetMode_t
    m_nSetParent = 0X000228 // ParticleParentSetMode_t

 C_OP_SetControlPointsToModelParticles: [particles.dll]
    m_HitboxSetName = 0X000210 // char[128]
    m_AttachmentName = 0X000290 // char[128]
    m_nFirstControlPoint = 0X000310 // int32
    m_nNumControlPoints = 0X000314 // int32
    m_nFirstSourcePoint = 0X000318 // int32
    m_bSkin = 0X00031C // bool
    m_bAttachment = 0X00031D // bool

 C_OP_SetPerChildControlPoint: [particles.dll]
    m_nChildGroupID = 0X000210 // int32
    m_nFirstControlPoint = 0X000214 // int32
    m_nNumControlPoints = 0X000218 // int32
    m_nParticleIncrement = 0X000220 // CParticleCollectionFloatInput
    m_nFirstSourcePoint = 0X000360 // CParticleCollectionFloatInput
    m_bSetOrientation = 0X0004A0 // bool
    m_nOrientationField = 0X0004A4 // ParticleAttributeIndex_t
    m_bNumBasedOnParticleCount = 0X0004A8 // bool

 C_OP_SetPerChildControlPointFromAttribute: [particles.dll]
    m_nChildGroupID = 0X000210 // int32
    m_nFirstControlPoint = 0X000214 // int32
    m_nNumControlPoints = 0X000218 // int32
    m_nParticleIncrement = 0X00021C // int32
    m_nFirstSourcePoint = 0X000220 // int32
    m_bNumBasedOnParticleCount = 0X000224 // bool
    m_nAttributeToRead = 0X000228 // ParticleAttributeIndex_t
    m_nCPField = 0X00022C // int32

 C_OP_RemapTransformOrientationToYaw: [particles.dll]
    m_TransformInput = 0X000210 // CParticleTransformInput
    m_nFieldOutput = 0X000260 // ParticleAttributeIndex_t
    m_flRotOffset = 0X000264 // float32
    m_flSpinStrength = 0X000268 // float32

 C_OP_DampenToCP: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_flRange = 0X000214 // float32
    m_flScale = 0X000218 // float32

 C_OP_SetToCP: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_vecOffset = 0X000214 // Vector
    m_bOffsetLocal = 0X000220 // bool

 C_OP_PinParticleToCP: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_vecOffset = 0X000218 // CParticleCollectionVecInput
    m_bOffsetLocal = 0X000800 // bool
    m_nParticleSelection = 0X000804 // ParticleSelection_t
    m_nParticleNumber = 0X000808 // CParticleCollectionFloatInput
    m_nPinBreakType = 0X000948 // ParticlePinDistance_t
    m_flBreakDistance = 0X000950 // CParticleCollectionFloatInput
    m_flBreakSpeed = 0X000A90 // CParticleCollectionFloatInput
    m_flAge = 0X000BD0 // CParticleCollectionFloatInput
    m_nBreakControlPointNumber = 0X000D10 // int32
    m_nBreakControlPointNumber2 = 0X000D14 // int32
    m_flInterpolation = 0X000D18 // CPerParticleFloatInput

 C_OP_MovementRigidAttachToCP: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_nScaleControlPoint = 0X000214 // int32
    m_nScaleCPField = 0X000218 // int32
    m_nFieldInput = 0X00021C // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000220 // ParticleAttributeIndex_t
    m_bOffsetLocal = 0X000224 // bool

 C_OP_LerpToInitialPosition: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_flInterpolation = 0X000218 // CPerParticleFloatInput
    m_nCacheField = 0X000358 // ParticleAttributeIndex_t
    m_flScale = 0X000360 // CParticleCollectionFloatInput
    m_vecScale = 0X0004A0 // CParticleCollectionVecInput

 C_OP_DistanceBetweenTransforms: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_TransformStart = 0X000218 // CParticleTransformInput
    m_TransformEnd = 0X000268 // CParticleTransformInput
    m_flInputMin = 0X0002B8 // CPerParticleFloatInput
    m_flInputMax = 0X0003F8 // CPerParticleFloatInput
    m_flOutputMin = 0X000538 // CPerParticleFloatInput
    m_flOutputMax = 0X000678 // CPerParticleFloatInput
    m_flMaxTraceLength = 0X0007B8 // float32
    m_flLOSScale = 0X0007BC // float32
    m_CollisionGroupName = 0X0007C0 // char[128]
    m_nTraceSet = 0X000840 // ParticleTraceSet_t
    m_bLOS = 0X000844 // bool
    m_nSetMethod = 0X000848 // ParticleSetMethod_t

 C_OP_PercentageBetweenTransforms: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flInputMin = 0X000214 // float32
    m_flInputMax = 0X000218 // float32
    m_flOutputMin = 0X00021C // float32
    m_flOutputMax = 0X000220 // float32
    m_TransformStart = 0X000228 // CParticleTransformInput
    m_TransformEnd = 0X000278 // CParticleTransformInput
    m_nSetMethod = 0X0002C8 // ParticleSetMethod_t
    m_bActiveRange = 0X0002CC // bool
    m_bRadialCheck = 0X0002CD // bool

 C_OP_PercentageBetweenTransformsVector: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flInputMin = 0X000214 // float32
    m_flInputMax = 0X000218 // float32
    m_vecOutputMin = 0X00021C // Vector
    m_vecOutputMax = 0X000228 // Vector
    m_TransformStart = 0X000238 // CParticleTransformInput
    m_TransformEnd = 0X000288 // CParticleTransformInput
    m_nSetMethod = 0X0002D8 // ParticleSetMethod_t
    m_bActiveRange = 0X0002DC // bool
    m_bRadialCheck = 0X0002DD // bool

 C_OP_PercentageBetweenTransformLerpCPs: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flInputMin = 0X000214 // float32
    m_flInputMax = 0X000218 // float32
    m_TransformStart = 0X000220 // CParticleTransformInput
    m_TransformEnd = 0X000270 // CParticleTransformInput
    m_nOutputStartCP = 0X0002C0 // int32
    m_nOutputStartField = 0X0002C4 // int32
    m_nOutputEndCP = 0X0002C8 // int32
    m_nOutputEndField = 0X0002CC // int32
    m_nSetMethod = 0X0002D0 // ParticleSetMethod_t
    m_bActiveRange = 0X0002D4 // bool
    m_bRadialCheck = 0X0002D5 // bool

 C_OP_DistanceBetweenVecs: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_vecPoint1 = 0X000218 // CPerParticleVecInput
    m_vecPoint2 = 0X000800 // CPerParticleVecInput
    m_flInputMin = 0X000DE8 // CPerParticleFloatInput
    m_flInputMax = 0X000F28 // CPerParticleFloatInput
    m_flOutputMin = 0X001068 // CPerParticleFloatInput
    m_flOutputMax = 0X0011A8 // CPerParticleFloatInput
    m_nSetMethod = 0X0012E8 // ParticleSetMethod_t
    m_bDeltaTime = 0X0012EC // bool

 C_OP_DirectionBetweenVecsToVec: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_vecPoint1 = 0X000218 // CPerParticleVecInput
    m_vecPoint2 = 0X000800 // CPerParticleVecInput

 C_OP_DistanceToTransform: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flInputMin = 0X000218 // CPerParticleFloatInput
    m_flInputMax = 0X000358 // CPerParticleFloatInput
    m_flOutputMin = 0X000498 // CPerParticleFloatInput
    m_flOutputMax = 0X0005D8 // CPerParticleFloatInput
    m_TransformStart = 0X000718 // CParticleTransformInput
    m_bLOS = 0X000768 // bool
    m_CollisionGroupName = 0X000769 // char[128]
    m_nTraceSet = 0X0007EC // ParticleTraceSet_t
    m_flMaxTraceLength = 0X0007F0 // float32
    m_flLOSScale = 0X0007F4 // float32
    m_nSetMethod = 0X0007F8 // ParticleSetMethod_t
    m_bActiveRange = 0X0007FC // bool
    m_bAdditive = 0X0007FD // bool
    m_vecComponentScale = 0X000800 // CPerParticleVecInput

 C_OP_CylindricalDistanceToTransform: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flInputMin = 0X000218 // CPerParticleFloatInput
    m_flInputMax = 0X000358 // CPerParticleFloatInput
    m_flOutputMin = 0X000498 // CPerParticleFloatInput
    m_flOutputMax = 0X0005D8 // CPerParticleFloatInput
    m_TransformStart = 0X000718 // CParticleTransformInput
    m_TransformEnd = 0X000768 // CParticleTransformInput
    m_nSetMethod = 0X0007B8 // ParticleSetMethod_t
    m_bActiveRange = 0X0007BC // bool
    m_bAdditive = 0X0007BD // bool
    m_bCapsule = 0X0007BE // bool

 C_OP_RtEnvCull: [particles.dll]
    m_vecTestDir = 0X000210 // Vector
    m_vecTestNormal = 0X00021C // Vector
    m_bCullOnMiss = 0X000228 // bool
    m_bStickInsteadOfCull = 0X000229 // bool
    m_RtEnvName = 0X00022A // char[128]
    m_nRTEnvCP = 0X0002AC // int32
    m_nComponent = 0X0002B0 // int32

 C_OP_MovementLoopInsideSphere: [particles.dll]
    m_nCP = 0X000210 // int32
    m_flDistance = 0X000218 // CParticleCollectionFloatInput
    m_vecScale = 0X000358 // CParticleCollectionVecInput
    m_nDistSqrAttr = 0X000940 // ParticleAttributeIndex_t

 C_OP_MoveToHitbox: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_flLifeTimeLerpStart = 0X000218 // float32
    m_flLifeTimeLerpEnd = 0X00021C // float32
    m_flPrevPosScale = 0X000220 // float32
    m_HitboxSetName = 0X000224 // char[128]
    m_bUseBones = 0X0002A4 // bool
    m_nLerpType = 0X0002A8 // HitboxLerpType_t
    m_flInterpolation = 0X0002B0 // CPerParticleFloatInput

 C_OP_LockToBone: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_flLifeTimeFadeStart = 0X000214 // float32
    m_flLifeTimeFadeEnd = 0X000218 // float32
    m_flJumpThreshold = 0X00021C // float32
    m_flPrevPosScale = 0X000220 // float32
    m_HitboxSetName = 0X000224 // char[128]
    m_bRigid = 0X0002A4 // bool
    m_bUseBones = 0X0002A5 // bool
    m_nFieldOutput = 0X0002A8 // ParticleAttributeIndex_t
    m_nFieldOutputPrev = 0X0002AC // ParticleAttributeIndex_t
    m_nRotationSetType = 0X0002B0 // ParticleRotationLockType_t
    m_bRigidRotationLock = 0X0002B4 // bool
    m_vecRotation = 0X0002B8 // CPerParticleVecInput
    m_flRotLerp = 0X0008A0 // CPerParticleFloatInput

 C_OP_SnapshotRigidSkinToBones: [particles.dll]
    m_bTransformNormals = 0X000210 // bool
    m_bTransformRadii = 0X000211 // bool
    m_nControlPointNumber = 0X000214 // int32

 C_OP_SnapshotSkinToBones: [particles.dll]
    m_bTransformNormals = 0X000210 // bool
    m_bTransformRadii = 0X000211 // bool
    m_nControlPointNumber = 0X000214 // int32
    m_flLifeTimeFadeStart = 0X000218 // float32
    m_flLifeTimeFadeEnd = 0X00021C // float32
    m_flJumpThreshold = 0X000220 // float32
    m_flPrevPosScale = 0X000224 // float32

 C_OP_CPOffsetToPercentageBetweenCPs: [particles.dll]
    m_flInputMin = 0X000210 // float32
    m_flInputMax = 0X000214 // float32
    m_flInputBias = 0X000218 // float32
    m_nStartCP = 0X00021C // int32
    m_nEndCP = 0X000220 // int32
    m_nOffsetCP = 0X000224 // int32
    m_nOuputCP = 0X000228 // int32
    m_nInputCP = 0X00022C // int32
    m_bRadialCheck = 0X000230 // bool
    m_bScaleOffset = 0X000231 // bool
    m_vecOffset = 0X000234 // Vector

 C_OP_PlaneCull: [particles.dll]
    m_nPlaneControlPoint = 0X000210 // int32
    m_vecPlaneDirection = 0X000214 // Vector
    m_bLocalSpace = 0X000220 // bool
    m_flPlaneOffset = 0X000224 // float32

 C_OP_DistanceCull: [particles.dll]
    m_nControlPoint = 0X000210 // int32
    m_vecPointOffset = 0X000214 // Vector
    m_flDistance = 0X000220 // float32
    m_bCullInside = 0X000224 // bool

 C_OP_ModelCull: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_bBoundBox = 0X000214 // bool
    m_bCullOutside = 0X000215 // bool
    m_bUseBones = 0X000216 // bool
    m_HitboxSetName = 0X000217 // char[128]

 C_OP_ModelDampenMovement: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_bBoundBox = 0X000214 // bool
    m_bOutside = 0X000215 // bool
    m_bUseBones = 0X000216 // bool
    m_HitboxSetName = 0X000217 // char[128]
    m_vecPosOffset = 0X000298 // CPerParticleVecInput
    m_fDrag = 0X000880 // float32

 C_OP_SequenceFromModel: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_nFieldOutputAnim = 0X000218 // ParticleAttributeIndex_t
    m_flInputMin = 0X00021C // float32
    m_flInputMax = 0X000220 // float32
    m_flOutputMin = 0X000224 // float32
    m_flOutputMax = 0X000228 // float32
    m_nSetMethod = 0X00022C // ParticleSetMethod_t

 C_OP_VelocityMatchingForce: [particles.dll]
    m_flDirScale = 0X000210 // float32
    m_flSpdScale = 0X000214 // float32
    m_nCPBroadcast = 0X000218 // int32

 C_OP_MovementMaintainOffset: [particles.dll]
    m_vecOffset = 0X000210 // Vector
    m_nCP = 0X00021C // int32
    m_bRadiusScale = 0X000220 // bool

 C_OP_MovementPlaceOnGround: [particles.dll]
    m_flOffset = 0X000210 // CPerParticleFloatInput
    m_flMaxTraceLength = 0X000350 // float32
    m_flTolerance = 0X000354 // float32
    m_flTraceOffset = 0X000358 // float32
    m_flLerpRate = 0X00035C // float32
    m_CollisionGroupName = 0X000360 // char[128]
    m_nTraceSet = 0X0003E0 // ParticleTraceSet_t
    m_nRefCP1 = 0X0003E4 // int32
    m_nRefCP2 = 0X0003E8 // int32
    m_nLerpCP = 0X0003EC // int32
    m_nTraceMissBehavior = 0X0003F8 // ParticleTraceMissBehavior_t
    m_bIncludeShotHull = 0X0003FC // bool
    m_bIncludeWater = 0X0003FD // bool
    m_bSetNormal = 0X000400 // bool
    m_bScaleOffset = 0X000401 // bool
    m_nPreserveOffsetCP = 0X000404 // int32
    m_nIgnoreCP = 0X000408 // int32

 C_OP_InheritFromParentParticles: [particles.dll]
    m_flScale = 0X000210 // float32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_nIncrement = 0X000218 // int32
    m_bRandomDistribution = 0X00021C // bool

 C_OP_InheritFromParentParticlesV2: [particles.dll]
    m_flScale = 0X000210 // float32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_nIncrement = 0X000218 // int32
    m_bRandomDistribution = 0X00021C // bool
    m_nMissingParentBehavior = 0X000220 // MissingParentInheritBehavior_t

 C_OP_ReadFromNeighboringParticle: [particles.dll]
    m_nFieldInput = 0X000210 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_nIncrement = 0X000218 // int32
    m_DistanceCheck = 0X000220 // CPerParticleFloatInput
    m_flInterpolation = 0X000360 // CPerParticleFloatInput

 C_OP_InheritFromPeerSystem: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_nFieldInput = 0X000214 // ParticleAttributeIndex_t
    m_nIncrement = 0X000218 // int32
    m_nGroupID = 0X00021C // int32

 C_OP_RemapVectorComponentToScalar: [particles.dll]
    m_nFieldInput = 0X000210 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_nComponent = 0X000218 // int32

 C_OP_OrientTo2dDirection: [particles.dll]
    m_flRotOffset = 0X000210 // float32
    m_flSpinStrength = 0X000214 // float32
    m_nFieldOutput = 0X000218 // ParticleAttributeIndex_t

 C_OP_RestartAfterDuration: [particles.dll]
    m_flDurationMin = 0X000210 // float32
    m_flDurationMax = 0X000214 // float32
    m_nCP = 0X000218 // int32
    m_nCPField = 0X00021C // int32
    m_nChildGroupID = 0X000220 // int32
    m_bOnlyChildren = 0X000224 // bool

 C_OP_Orient2DRelToCP: [particles.dll]
    m_flRotOffset = 0X000210 // float32
    m_flSpinStrength = 0X000214 // float32
    m_nCP = 0X000218 // int32
    m_nFieldOutput = 0X00021C // ParticleAttributeIndex_t

 C_OP_MovementRotateParticleAroundAxis: [particles.dll]
    m_vecRotAxis = 0X000210 // CParticleCollectionVecInput
    m_flRotRate = 0X0007F8 // CParticleCollectionFloatInput
    m_TransformInput = 0X000938 // CParticleTransformInput
    m_bLocalSpace = 0X000988 // bool

 C_OP_RotateVector: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_vecRotAxisMin = 0X000214 // Vector
    m_vecRotAxisMax = 0X000220 // Vector
    m_flRotRateMin = 0X00022C // float32
    m_flRotRateMax = 0X000230 // float32
    m_bNormalize = 0X000234 // bool
    m_flScale = 0X000238 // CPerParticleFloatInput

 C_OP_MaxVelocity: [particles.dll]
    m_flMaxVelocity = 0X000210 // float32
    m_nOverrideCP = 0X000214 // int32
    m_nOverrideCPField = 0X000218 // int32

 C_OP_LagCompensation: [particles.dll]
    m_nDesiredVelocityCP = 0X000210 // int32
    m_nLatencyCP = 0X000214 // int32
    m_nLatencyCPField = 0X000218 // int32
    m_nDesiredVelocityCPField = 0X00021C // int32

 C_OP_MaintainSequentialPath: [particles.dll]
    m_fMaxDistance = 0X000210 // float32
    m_flNumToAssign = 0X000214 // float32
    m_flCohesionStrength = 0X000218 // float32
    m_flTolerance = 0X00021C // float32
    m_bLoop = 0X000220 // bool
    m_bUseParticleCount = 0X000221 // bool
    m_PathParams = 0X000230 // CPathParameters

 C_OP_LockToSavedSequentialPathV2: [particles.dll]
    m_flFadeStart = 0X000210 // float32
    m_flFadeEnd = 0X000214 // float32
    m_bCPPairs = 0X000218 // bool
    m_PathParams = 0X000220 // CPathParameters

 C_OP_LockToSavedSequentialPath: [particles.dll]
    m_flFadeStart = 0X000214 // float32
    m_flFadeEnd = 0X000218 // float32
    m_bCPPairs = 0X00021C // bool
    m_PathParams = 0X000220 // CPathParameters

 C_OP_RemapDotProductToScalar: [particles.dll]
    m_nInputCP1 = 0X000210 // int32
    m_nInputCP2 = 0X000214 // int32
    m_nFieldOutput = 0X000218 // ParticleAttributeIndex_t
    m_flInputMin = 0X00021C // float32
    m_flInputMax = 0X000220 // float32
    m_flOutputMin = 0X000224 // float32
    m_flOutputMax = 0X000228 // float32
    m_bUseParticleVelocity = 0X00022C // bool
    m_nSetMethod = 0X000230 // ParticleSetMethod_t
    m_bActiveRange = 0X000234 // bool
    m_bUseParticleNormal = 0X000235 // bool

 C_OP_RemapCPtoScalar: [particles.dll]
    m_nCPInput = 0X000210 // int32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_nField = 0X000218 // int32
    m_flInputMin = 0X00021C // float32
    m_flInputMax = 0X000220 // float32
    m_flOutputMin = 0X000224 // float32
    m_flOutputMax = 0X000228 // float32
    m_flStartTime = 0X00022C // float32
    m_flEndTime = 0X000230 // float32
    m_flInterpRate = 0X000234 // float32
    m_nSetMethod = 0X000238 // ParticleSetMethod_t

 C_OP_NormalLock: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32

 C_OP_RemapCPtoVector: [particles.dll]
    m_nCPInput = 0X000210 // int32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_nLocalSpaceCP = 0X000218 // int32
    m_vInputMin = 0X00021C // Vector
    m_vInputMax = 0X000228 // Vector
    m_vOutputMin = 0X000234 // Vector
    m_vOutputMax = 0X000240 // Vector
    m_flStartTime = 0X00024C // float32
    m_flEndTime = 0X000250 // float32
    m_flInterpRate = 0X000254 // float32
    m_nSetMethod = 0X000258 // ParticleSetMethod_t
    m_bOffset = 0X00025C // bool
    m_bAccelerate = 0X00025D // bool

 C_OP_SetCPtoVector: [particles.dll]
    m_nCPInput = 0X000210 // int32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t

 C_OP_RemapTransformToVelocity: [particles.dll]
    m_TransformInput = 0X000210 // CParticleTransformInput

 C_OP_RemapVelocityToVector: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flScale = 0X000214 // float32
    m_bNormalize = 0X000218 // bool

 C_OP_RemapCPVelocityToVector: [particles.dll]
    m_nControlPoint = 0X000210 // int32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_flScale = 0X000218 // float32
    m_bNormalize = 0X00021C // bool

 C_OP_SetCPOrientationToDirection: [particles.dll]
    m_nInputControlPoint = 0X000210 // int32
    m_nOutputControlPoint = 0X000214 // int32

 C_OP_RemapDirectionToCPToVector: [particles.dll]
    m_nCP = 0X000210 // int32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_flScale = 0X000218 // float32
    m_flOffsetRot = 0X00021C // float32
    m_vecOffsetAxis = 0X000220 // Vector
    m_bNormalize = 0X00022C // bool
    m_nFieldStrength = 0X000230 // ParticleAttributeIndex_t

 C_OP_RemapCrossProductOfTwoVectorsToVector: [particles.dll]
    m_InputVec1 = 0X000210 // CPerParticleVecInput
    m_InputVec2 = 0X0007F8 // CPerParticleVecInput
    m_nFieldOutput = 0X000DE0 // ParticleAttributeIndex_t
    m_bNormalize = 0X000DE4 // bool

 C_OP_NormalizeVector: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flScale = 0X000214 // float32

 C_OP_RemapControlPointDirectionToVector: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_flScale = 0X000214 // float32
    m_nControlPointNumber = 0X000218 // int32

 C_OP_SetCPOrientationToGroundNormal: [particles.dll]
    m_flInterpRate = 0X000210 // float32
    m_flMaxTraceLength = 0X000214 // float32
    m_flTolerance = 0X000218 // float32
    m_flTraceOffset = 0X00021C // float32
    m_CollisionGroupName = 0X000220 // char[128]
    m_nTraceSet = 0X0002A0 // ParticleTraceSet_t
    m_nInputCP = 0X0002A4 // int32
    m_nOutputCP = 0X0002A8 // int32
    m_bIncludeWater = 0X0002B8 // bool

 C_OP_RemapTransformOrientationToRotations: [particles.dll]
    m_TransformInput = 0X000210 // CParticleTransformInput
    m_vecRotation = 0X000260 // Vector
    m_bUseQuat = 0X00026C // bool
    m_bWriteNormal = 0X00026D // bool

 C_OP_RemapControlPointOrientationToRotation: [particles.dll]
    m_nCP = 0X000210 // int32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t
    m_flOffsetRot = 0X000218 // float32
    m_nComponent = 0X00021C // int32

 C_OP_LockToPointList: [particles.dll]
    m_nFieldOutput = 0X000210 // ParticleAttributeIndex_t
    m_pointList = 0X000218 // CUtlVector< PointDefinition_t >
    m_bPlaceAlongPath = 0X000230 // bool
    m_bClosedLoop = 0X000231 // bool
    m_nNumPointsAlongPath = 0X000234 // int32

 C_OP_RemapNamedModelElementOnceTimed: [particles.dll]
    m_hModel = 0X000210 // CStrongHandle< InfoForResourceTypeCModel >
    m_inNames = 0X000218 // CUtlVector< CUtlString >
    m_outNames = 0X000230 // CUtlVector< CUtlString >
    m_fallbackNames = 0X000248 // CUtlVector< CUtlString >
    m_bModelFromRenderer = 0X000260 // bool
    m_bProportional = 0X000261 // bool
    m_nFieldInput = 0X000264 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000268 // ParticleAttributeIndex_t
    m_flRemapTime = 0X00026C // float32

 C_OP_RemapNamedModelSequenceOnceTimed: [particles.dll]
    No schemes available

 C_OP_RemapNamedModelBodyPartOnceTimed: [particles.dll]
    No schemes available

 C_OP_RemapNamedModelMeshGroupOnceTimed: [particles.dll]
    No schemes available

 C_OP_RemapNamedModelElementEndCap: [particles.dll]
    m_hModel = 0X000210 // CStrongHandle< InfoForResourceTypeCModel >
    m_inNames = 0X000218 // CUtlVector< CUtlString >
    m_outNames = 0X000230 // CUtlVector< CUtlString >
    m_fallbackNames = 0X000248 // CUtlVector< CUtlString >
    m_bModelFromRenderer = 0X000260 // bool
    m_nFieldInput = 0X000264 // ParticleAttributeIndex_t
    m_nFieldOutput = 0X000268 // ParticleAttributeIndex_t

 C_OP_RemapNamedModelSequenceEndCap: [particles.dll]
    No schemes available

 C_OP_RemapNamedModelBodyPartEndCap: [particles.dll]
    No schemes available

 C_OP_RemapNamedModelMeshGroupEndCap: [particles.dll]
    No schemes available

 C_OP_SetFromCPSnapshot: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_nAttributeToRead = 0X000214 // ParticleAttributeIndex_t
    m_nAttributeToWrite = 0X000218 // ParticleAttributeIndex_t
    m_nLocalSpaceCP = 0X00021C // int32
    m_bRandom = 0X000220 // bool
    m_bReverse = 0X000221 // bool
    m_nRandomSeed = 0X000224 // int32
    m_nSnapShotStartPoint = 0X000228 // CParticleCollectionFloatInput
    m_nSnapShotIncrement = 0X000368 // CParticleCollectionFloatInput
    m_flInterpolation = 0X0004A8 // CPerParticleFloatInput
    m_bSubSample = 0X0005E8 // bool

 C_OP_VectorFieldSnapshot: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_nAttributeToWrite = 0X000214 // ParticleAttributeIndex_t
    m_nLocalSpaceCP = 0X000218 // int32
    m_flInterpolation = 0X000220 // CPerParticleFloatInput
    m_vecScale = 0X000360 // CPerParticleVecInput
    m_flBoundaryDampening = 0X000948 // float32
    m_bSetVelocity = 0X00094C // bool
    m_bLockToSurface = 0X00094D // bool
    m_flGridSpacing = 0X000950 // float32

 C_OP_SetAttributeToScalarExpression: [particles.dll]
    m_nExpression = 0X000210 // ScalarExpressionType_t
    m_flInput1 = 0X000218 // CPerParticleFloatInput
    m_flInput2 = 0X000358 // CPerParticleFloatInput
    m_nOutputField = 0X000498 // ParticleAttributeIndex_t
    m_nSetMethod = 0X00049C // ParticleSetMethod_t

 C_OP_SetVectorAttributeToVectorExpression: [particles.dll]
    m_nExpression = 0X000210 // VectorExpressionType_t
    m_vInput1 = 0X000218 // CPerParticleVecInput
    m_vInput2 = 0X000800 // CPerParticleVecInput
    m_nOutputField = 0X000DE8 // ParticleAttributeIndex_t
    m_nSetMethod = 0X000DEC // ParticleSetMethod_t
    m_bNormalizedOutput = 0X000DF0 // bool

 C_OP_SetFloatAttributeToVectorExpression: [particles.dll]
    m_nExpression = 0X000210 // VectorFloatExpressionType_t
    m_vInput1 = 0X000218 // CPerParticleVecInput
    m_vInput2 = 0X000800 // CPerParticleVecInput
    m_flOutputRemap = 0X000DE8 // CParticleRemapFloatInput
    m_nOutputField = 0X000F28 // ParticleAttributeIndex_t
    m_nSetMethod = 0X000F2C // ParticleSetMethod_t

 C_OP_MovementSkinnedPositionFromCPSnapshot: [particles.dll]
    m_nSnapshotControlPointNumber = 0X000210 // int32
    m_nControlPointNumber = 0X000214 // int32
    m_bRandom = 0X000218 // bool
    m_nRandomSeed = 0X00021C // int32
    m_bSetNormal = 0X000220 // bool
    m_bSetRadius = 0X000221 // bool
    m_flIncrement = 0X000228 // CParticleCollectionFloatInput
    m_nFullLoopIncrement = 0X000368 // CParticleCollectionFloatInput
    m_nSnapShotStartPoint = 0X0004A8 // CParticleCollectionFloatInput
    m_flInterpolation = 0X0005E8 // CPerParticleFloatInput

 C_OP_MovementMoveAlongSkinnedCPSnapshot: [particles.dll]
    m_nControlPointNumber = 0X000210 // int32
    m_nSnapshotControlPointNumber = 0X000214 // int32
    m_bSetNormal = 0X000218 // bool
    m_bSetRadius = 0X000219 // bool
    m_flInterpolation = 0X000220 // CPerParticleFloatInput
    m_flTValue = 0X000360 // CPerParticleFloatInput

 C_OP_QuantizeFloat: [particles.dll]
    m_InputValue = 0X000210 // CPerParticleFloatInput
    m_nOutputField = 0X000350 // ParticleAttributeIndex_t

 C_OP_SetFloatCollection: [particles.dll]
    m_InputValue = 0X000210 // CParticleCollectionFloatInput
    m_nOutputField = 0X000350 // ParticleAttributeIndex_t
    m_nSetMethod = 0X000354 // ParticleSetMethod_t
    m_Lerp = 0X000358 // CParticleCollectionFloatInput

 C_OP_SetFloat: [particles.dll]
    m_InputValue = 0X000210 // CPerParticleFloatInput
    m_nOutputField = 0X000350 // ParticleAttributeIndex_t
    m_nSetMethod = 0X000354 // ParticleSetMethod_t
    m_Lerp = 0X000358 // CPerParticleFloatInput

 C_OP_SetVec: [particles.dll]
    m_InputValue = 0X000210 // CPerParticleVecInput
    m_nOutputField = 0X0007F8 // ParticleAttributeIndex_t
    m_nSetMethod = 0X0007FC // ParticleSetMethod_t
    m_Lerp = 0X000800 // CPerParticleFloatInput
    m_bNormalizedOutput = 0X000940 // bool

 C_OP_RemapDensityGradientToVectorAttribute: [particles.dll]
    m_flRadiusScale = 0X000210 // float32
    m_nFieldOutput = 0X000214 // ParticleAttributeIndex_t

 C_OP_LockPoints: [particles.dll]
    m_nMinCol = 0X000210 // int32
    m_nMaxCol = 0X000214 // int32
    m_nMinRow = 0X000218 // int32
    m_nMaxRow = 0X00021C // int32
    m_nControlPoint = 0X000220 // int32
    m_flBlendValue = 0X000224 // float32

 C_OP_RemapDistanceToLineSegmentBase: [particles.dll]
    m_nCP0 = 0X000210 // int32
    m_nCP1 = 0X000214 // int32
    m_flMinInputValue = 0X000218 // float32
    m_flMaxInputValue = 0X00021C // float32
    m_bInfiniteLine = 0X000220 // bool

 C_OP_RemapDistanceToLineSegmentToScalar: [particles.dll]
    m_nFieldOutput = 0X000230 // ParticleAttributeIndex_t
    m_flMinOutputValue = 0X000234 // float32
    m_flMaxOutputValue = 0X000238 // float32

 C_OP_RemapDistanceToLineSegmentToVector: [particles.dll]
    m_nFieldOutput = 0X000230 // ParticleAttributeIndex_t
    m_vMinOutputValue = 0X000234 // Vector
    m_vMaxOutputValue = 0X000240 // Vector

 C_OP_TeleportBeam: [particles.dll]
    m_nCPPosition = 0X000210 // int32
    m_nCPVelocity = 0X000214 // int32
    m_nCPMisc = 0X000218 // int32
    m_nCPColor = 0X00021C // int32
    m_nCPInvalidColor = 0X000220 // int32
    m_nCPExtraArcData = 0X000224 // int32
    m_vGravity = 0X000228 // Vector
    m_flArcMaxDuration = 0X000234 // float32
    m_flSegmentBreak = 0X000238 // float32
    m_flArcSpeed = 0X00023C // float32
    m_flAlpha = 0X000240 // float32

 C_OP_CycleScalar: [particles.dll]
    m_nDestField = 0X000210 // ParticleAttributeIndex_t
    m_flStartValue = 0X000214 // float32
    m_flEndValue = 0X000218 // float32
    m_flCycleTime = 0X00021C // float32
    m_bDoNotRepeatCycle = 0X000220 // bool
    m_bSynchronizeParticles = 0X000221 // bool
    m_nCPScale = 0X000224 // int32
    m_nCPFieldMin = 0X000228 // int32
    m_nCPFieldMax = 0X00022C // int32
    m_nSetMethod = 0X000230 // ParticleSetMethod_t

 C_OP_CalculateVectorAttribute: [particles.dll]
    m_vStartValue = 0X000210 // Vector
    m_nFieldInput1 = 0X00021C // ParticleAttributeIndex_t
    m_flInputScale1 = 0X000220 // float32
    m_nFieldInput2 = 0X000224 // ParticleAttributeIndex_t
    m_flInputScale2 = 0X000228 // float32
    m_nControlPointInput1 = 0X00022C // ControlPointReference_t
    m_flControlPointScale1 = 0X000240 // float32
    m_nControlPointInput2 = 0X000244 // ControlPointReference_t
    m_flControlPointScale2 = 0X000258 // float32
    m_nFieldOutput = 0X00025C // ParticleAttributeIndex_t
    m_vFinalOutputScale = 0X000260 // Vector

 C_OP_ColorAdjustHSL: [particles.dll]
    m_flHueAdjust = 0X000210 // CPerParticleFloatInput
    m_flSaturationAdjust = 0X000350 // CPerParticleFloatInput
    m_flLightnessAdjust = 0X000490 // CPerParticleFloatInput

 C_OP_ConnectParentParticleToNearest: [particles.dll]
    m_nFirstControlPoint = 0X000210 // int32
    m_nSecondControlPoint = 0X000214 // int32

 C_OP_UpdateLightSource: [particles.dll]
    m_vColorTint = 0X000210 // Color
    m_flBrightnessScale = 0X000214 // float32
    m_flRadiusScale = 0X000218 // float32
    m_flMinimumLightingRadius = 0X00021C // float32
    m_flMaximumLightingRadius = 0X000220 // float32
    m_flPositionDampingConstant = 0X000224 // float32

 C_OP_RemapSpeedtoCP: [particles.dll]
    m_nInControlPointNumber = 0X000220 // int32
    m_nOutControlPointNumber = 0X000224 // int32
    m_nField = 0X000228 // int32
    m_flInputMin = 0X00022C // float32
    m_flInputMax = 0X000230 // float32
    m_flOutputMin = 0X000234 // float32
    m_flOutputMax = 0X000238 // float32
    m_bUseDeltaV = 0X00023C // bool

 C_OP_RemapAverageHitboxSpeedtoCP: [particles.dll]
    m_nInControlPointNumber = 0X000220 // int32
    m_nOutControlPointNumber = 0X000224 // int32
    m_nField = 0X000228 // int32
    m_flInputMin = 0X000230 // CParticleCollectionFloatInput
    m_flInputMax = 0X000370 // CParticleCollectionFloatInput
    m_flOutputMin = 0X0004B0 // CParticleCollectionFloatInput
    m_flOutputMax = 0X0005F0 // CParticleCollectionFloatInput
    m_nHeightControlPointNumber = 0X000730 // int32
    m_vecComparisonVelocity = 0X000738 // CParticleCollectionVecInput
    m_HitboxSetName = 0X000D20 // char[128]

 C_OP_RemapDotProductToCP: [particles.dll]
    m_nInputCP1 = 0X000220 // int32
    m_nInputCP2 = 0X000224 // int32
    m_nOutputCP = 0X000228 // int32
    m_nOutVectorField = 0X00022C // int32
    m_flInputMin = 0X000230 // CParticleCollectionFloatInput
    m_flInputMax = 0X000370 // CParticleCollectionFloatInput
    m_flOutputMin = 0X0004B0 // CParticleCollectionFloatInput
    m_flOutputMax = 0X0005F0 // CParticleCollectionFloatInput

 C_OP_SetControlPointFieldToScalarExpression: [particles.dll]
    m_nExpression = 0X000220 // ScalarExpressionType_t
    m_flInput1 = 0X000228 // CParticleCollectionFloatInput
    m_flInput2 = 0X000368 // CParticleCollectionFloatInput
    m_flOutputRemap = 0X0004A8 // CParticleRemapFloatInput
    m_nOutputCP = 0X0005E8 // int32
    m_nOutVectorField = 0X0005EC // int32

 C_OP_SetControlPointFieldFromVectorExpression: [particles.dll]
    m_nExpression = 0X000220 // VectorFloatExpressionType_t
    m_vecInput1 = 0X000228 // CParticleCollectionVecInput
    m_vecInput2 = 0X000810 // CParticleCollectionVecInput
    m_flOutputRemap = 0X000DF8 // CParticleRemapFloatInput
    m_nOutputCP = 0X000F38 // int32
    m_nOutVectorField = 0X000F3C // int32

 C_OP_SetControlPointToVectorExpression: [particles.dll]
    m_nExpression = 0X000220 // VectorExpressionType_t
    m_nOutputCP = 0X000224 // int32
    m_vInput1 = 0X000228 // CParticleCollectionVecInput
    m_vInput2 = 0X000810 // CParticleCollectionVecInput
    m_bNormalizedOutput = 0X000DF8 // bool

 C_OP_RemapModelVolumetoCP: [particles.dll]
    m_nInControlPointNumber = 0X000220 // int32
    m_nOutControlPointNumber = 0X000224 // int32
    m_nField = 0X000228 // int32
    m_flInputMin = 0X00022C // float32
    m_flInputMax = 0X000230 // float32
    m_flOutputMin = 0X000234 // float32
    m_flOutputMax = 0X000238 // float32

 C_OP_RemapBoundingVolumetoCP: [particles.dll]
    m_nOutControlPointNumber = 0X000220 // int32
    m_flInputMin = 0X000224 // float32
    m_flInputMax = 0X000228 // float32
    m_flOutputMin = 0X00022C // float32
    m_flOutputMax = 0X000230 // float32

 C_OP_RemapAverageScalarValuetoCP: [particles.dll]
    m_nOutControlPointNumber = 0X000220 // int32
    m_nOutVectorField = 0X000224 // int32
    m_nField = 0X000228 // ParticleAttributeIndex_t
    m_flInputMin = 0X00022C // float32
    m_flInputMax = 0X000230 // float32
    m_flOutputMin = 0X000234 // float32
    m_flOutputMax = 0X000238 // float32

 C_OP_RampCPLinearRandom: [particles.dll]
    m_nOutControlPointNumber = 0X000220 // int32
    m_vecRateMin = 0X000224 // Vector
    m_vecRateMax = 0X000230 // Vector

 C_OP_SetParentControlPointsToChildCP: [particles.dll]
    m_nChildGroupID = 0X000220 // int32
    m_nChildControlPoint = 0X000224 // int32
    m_nNumControlPoints = 0X000228 // int32
    m_nFirstSourcePoint = 0X00022C // int32
    m_bSetOrientation = 0X000230 // bool

 C_OP_SetControlPointPositions: [particles.dll]
    m_bUseWorldLocation = 0X000220 // bool
    m_bOrient = 0X000221 // bool
    m_bSetOnce = 0X000222 // bool
    m_nCP1 = 0X000224 // int32
    m_nCP2 = 0X000228 // int32
    m_nCP3 = 0X00022C // int32
    m_nCP4 = 0X000230 // int32
    m_vecCP1Pos = 0X000234 // Vector
    m_vecCP2Pos = 0X000240 // Vector
    m_vecCP3Pos = 0X00024C // Vector
    m_vecCP4Pos = 0X000258 // Vector
    m_nHeadLocation = 0X000264 // int32

 C_OP_SetSingleControlPointPosition: [particles.dll]
    m_bUseWorldLocation = 0X000220 // bool
    m_bSetOnce = 0X000221 // bool
    m_nCP1 = 0X000224 // int32
    m_vecCP1Pos = 0X000228 // CParticleCollectionVecInput
    m_nHeadLocation = 0X000810 // int32

 C_OP_SetControlPointPositionToRandomActiveCP: [particles.dll]
    m_nCP1 = 0X000220 // int32
    m_nHeadLocationMin = 0X000224 // int32
    m_nHeadLocationMax = 0X000228 // int32
    m_flResetRate = 0X000230 // CParticleCollectionFloatInput

 C_OP_SetRandomControlPointPosition: [particles.dll]
    m_bUseWorldLocation = 0X000220 // bool
    m_bOrient = 0X000221 // bool
    m_nCP1 = 0X000224 // int32
    m_nHeadLocation = 0X000228 // int32
    m_flReRandomRate = 0X000230 // CParticleCollectionFloatInput
    m_vecCPMinPos = 0X000370 // Vector
    m_vecCPMaxPos = 0X00037C // Vector
    m_flInterpolation = 0X000388 // CParticleCollectionFloatInput

 C_OP_SetControlPointOrientation: [particles.dll]
    m_bUseWorldLocation = 0X000220 // bool
    m_bRandomize = 0X000222 // bool
    m_bSetOnce = 0X000223 // bool
    m_nCP = 0X000224 // int32
    m_nHeadLocation = 0X000228 // int32
    m_vecRotation = 0X00022C // QAngle
    m_vecRotationB = 0X000238 // QAngle
    m_flInterpolation = 0X000248 // CParticleCollectionFloatInput

 C_OP_SetControlPointFromObjectScale: [particles.dll]
    m_nCPInput = 0X000220 // int32
    m_nCPOutput = 0X000224 // int32

 C_OP_DistanceBetweenCPsToCP: [particles.dll]
    m_nStartCP = 0X000220 // int32
    m_nEndCP = 0X000224 // int32
    m_nOutputCP = 0X000228 // int32
    m_nOutputCPField = 0X00022C // int32
    m_bSetOnce = 0X000230 // bool
    m_flInputMin = 0X000234 // float32
    m_flInputMax = 0X000238 // float32
    m_flOutputMin = 0X00023C // float32
    m_flOutputMax = 0X000240 // float32
    m_flMaxTraceLength = 0X000244 // float32
    m_flLOSScale = 0X000248 // float32
    m_bLOS = 0X00024C // bool
    m_CollisionGroupName = 0X00024D // char[128]
    m_nTraceSet = 0X0002D0 // ParticleTraceSet_t
    m_nSetParent = 0X0002D4 // ParticleParentSetMode_t

 C_OP_SetControlPointToPlayer: [particles.dll]
    m_nCP1 = 0X000220 // int32
    m_vecCP1Pos = 0X000224 // Vector
    m_bOrientToEyes = 0X000230 // bool

 C_OP_SetControlPointToHand: [particles.dll]
    m_nCP1 = 0X000220 // int32
    m_nHand = 0X000224 // int32
    m_vecCP1Pos = 0X000228 // Vector
    m_bOrientToHand = 0X000234 // bool

 C_OP_SetControlPointToHMD: [particles.dll]
    m_nCP1 = 0X000220 // int32
    m_vecCP1Pos = 0X000224 // Vector
    m_bOrientToHMD = 0X000230 // bool

 C_OP_SetControlPointPositionToTimeOfDayValue: [particles.dll]
    m_nControlPointNumber = 0X000220 // int32
    m_pszTimeOfDayParameter = 0X000224 // char[128]
    m_vecDefaultValue = 0X0002A4 // Vector

 C_OP_SetControlPointToCenter: [particles.dll]
    m_nCP1 = 0X000220 // int32
    m_vecCP1Pos = 0X000224 // Vector

 C_OP_SetControlPointToCPVelocity: [particles.dll]
    m_nCPInput = 0X000220 // int32
    m_nCPOutputVel = 0X000224 // int32
    m_bNormalize = 0X000228 // bool
    m_nCPOutputMag = 0X00022C // int32
    m_nCPField = 0X000230 // int32
    m_vecComparisonVelocity = 0X000238 // CParticleCollectionVecInput

 C_OP_SetControlPointOrientationToCPVelocity: [particles.dll]
    m_nCPInput = 0X000220 // int32
    m_nCPOutput = 0X000224 // int32

 C_OP_StopAfterCPDuration: [particles.dll]
    m_flDuration = 0X000220 // CParticleCollectionFloatInput
    m_bDestroyImmediately = 0X000360 // bool
    m_bPlayEndCap = 0X000361 // bool

 C_OP_SetControlPointRotation: [particles.dll]
    m_vecRotAxis = 0X000220 // CParticleCollectionVecInput
    m_flRotRate = 0X000808 // CParticleCollectionFloatInput
    m_nCP = 0X000948 // int32
    m_nLocalCP = 0X00094C // int32

 C_OP_RemapCPtoCP: [particles.dll]
    m_nInputControlPoint = 0X000220 // int32
    m_nOutputControlPoint = 0X000224 // int32
    m_nInputField = 0X000228 // int32
    m_nOutputField = 0X00022C // int32
    m_flInputMin = 0X000230 // float32
    m_flInputMax = 0X000234 // float32
    m_flOutputMin = 0X000238 // float32
    m_flOutputMax = 0X00023C // float32
    m_bDerivative = 0X000240 // bool
    m_flInterpRate = 0X000244 // float32

 C_OP_HSVShiftToCP: [particles.dll]
    m_nColorCP = 0X000220 // int32
    m_nColorGemEnableCP = 0X000224 // int32
    m_nOutputCP = 0X000228 // int32
    m_DefaultHSVColor = 0X00022C // Color

 C_OP_SetControlPointToImpactPoint: [particles.dll]
    m_nCPOut = 0X000220 // int32
    m_nCPIn = 0X000224 // int32
    m_flUpdateRate = 0X000228 // float32
    m_flTraceLength = 0X000230 // CParticleCollectionFloatInput
    m_flStartOffset = 0X000370 // float32
    m_flOffset = 0X000374 // float32
    m_vecTraceDir = 0X000378 // Vector
    m_CollisionGroupName = 0X000384 // char[128]
    m_nTraceSet = 0X000404 // ParticleTraceSet_t
    m_bSetToEndpoint = 0X000408 // bool
    m_bTraceToClosestSurface = 0X000409 // bool

 C_OP_SetCPOrientationToPointAtCP: [particles.dll]
    m_nInputCP = 0X000220 // int32
    m_nOutputCP = 0X000224 // int32
    m_flInterpolation = 0X000228 // CParticleCollectionFloatInput
    m_b2DOrientation = 0X000368 // bool
    m_bAvoidSingularity = 0X000369 // bool
    m_bPointAway = 0X00036A // bool

 C_OP_EnableChildrenFromParentParticleCount: [particles.dll]
    m_nChildGroupID = 0X000220 // int32
    m_nFirstChild = 0X000224 // int32
    m_nNumChildrenToEnable = 0X000228 // CParticleCollectionFloatInput

 C_OP_SelectivelyEnableChildren: [particles.dll]
    m_nChildGroupID = 0X000220 // CParticleCollectionFloatInput
    m_nFirstChild = 0X000360 // CParticleCollectionFloatInput
    m_nNumChildrenToEnable = 0X0004A0 // CParticleCollectionFloatInput
    m_bPlayEndcapOnStop = 0X0005E0 // bool
    m_bDestroyImmediately = 0X0005E1 // bool

 C_OP_PlayEndCapWhenFinished: [particles.dll]
    m_bFireOnEmissionEnd = 0X000220 // bool
    m_bIncludeChildren = 0X000221 // bool

 C_OP_ForceControlPointStub: [particles.dll]
    m_ControlPoint = 0X000220 // int32

 C_OP_DriveCPFromGlobalSoundFloat: [particles.dll]
    m_nOutputControlPoint = 0X000220 // int32
    m_nOutputField = 0X000224 // int32
    m_flInputMin = 0X000228 // float32
    m_flInputMax = 0X00022C // float32
    m_flOutputMin = 0X000230 // float32
    m_flOutputMax = 0X000234 // float32
    m_StackName = 0X000238 // CUtlString
    m_OperatorName = 0X000240 // CUtlString
    m_FieldName = 0X000248 // CUtlString

 C_OP_SetControlPointFieldToWater: [particles.dll]
    m_nSourceCP = 0X000220 // int32
    m_nDestCP = 0X000224 // int32
    m_nCPField = 0X000228 // int32

 C_OP_SetControlPointToWaterSurface: [particles.dll]
    m_nSourceCP = 0X000220 // int32
    m_nDestCP = 0X000224 // int32
    m_nFlowCP = 0X000228 // int32
    m_nActiveCP = 0X00022C // int32
    m_nActiveCPField = 0X000230 // int32
    m_flRetestRate = 0X000238 // CParticleCollectionFloatInput
    m_bAdaptiveThreshold = 0X000378 // bool

 C_OP_RepeatedTriggerChildGroup: [particles.dll]
    m_nChildGroupID = 0X000220 // int32
    m_flClusterRefireTime = 0X000228 // CParticleCollectionFloatInput
    m_flClusterSize = 0X000368 // CParticleCollectionFloatInput
    m_flClusterCooldown = 0X0004A8 // CParticleCollectionFloatInput
    m_bLimitChildCount = 0X0005E8 // bool

 C_OP_ChooseRandomChildrenInGroup: [particles.dll]
    m_nChildGroupID = 0X000220 // int32
    m_flNumberOfChildren = 0X000228 // CParticleCollectionFloatInput

 C_OP_SetSimulationRate: [particles.dll]
    m_flSimulationScale = 0X000220 // CParticleCollectionFloatInput

 C_OP_ControlPointToRadialScreenSpace: [particles.dll]
    m_nCPIn = 0X000220 // int32
    m_vecCP1Pos = 0X000224 // Vector
    m_nCPOut = 0X000230 // int32
    m_nCPOutField = 0X000234 // int32
    m_nCPSSPosOut = 0X000238 // int32

 C_OP_LightningSnapshotGenerator: [particles.dll]
    m_nCPSnapshot = 0X000220 // int32
    m_nCPStartPnt = 0X000224 // int32
    m_nCPEndPnt = 0X000228 // int32
    m_flSegments = 0X000230 // CParticleCollectionFloatInput
    m_flOffset = 0X000370 // CParticleCollectionFloatInput
    m_flOffsetDecay = 0X0004B0 // CParticleCollectionFloatInput
    m_flRecalcRate = 0X0005F0 // CParticleCollectionFloatInput
    m_flUVScale = 0X000730 // CParticleCollectionFloatInput
    m_flUVOffset = 0X000870 // CParticleCollectionFloatInput
    m_flSplitRate = 0X0009B0 // CParticleCollectionFloatInput
    m_flBranchTwist = 0X000AF0 // CParticleCollectionFloatInput
    m_nBranchBehavior = 0X000C30 // ParticleLightnintBranchBehavior_t
    m_flRadiusStart = 0X000C38 // CParticleCollectionFloatInput
    m_flRadiusEnd = 0X000D78 // CParticleCollectionFloatInput
    m_flDedicatedPool = 0X000EB8 // CParticleCollectionFloatInput

 C_OP_RemapExternalWindToCP: [particles.dll]
    m_nCP = 0X000220 // int32
    m_nCPOutput = 0X000224 // int32
    m_vecScale = 0X000228 // CParticleCollectionVecInput
    m_bSetMagnitude = 0X000810 // bool
    m_nOutVectorField = 0X000814 // int32

 C_OP_QuantizeCPComponent: [particles.dll]
    m_flInputValue = 0X000220 // CParticleCollectionFloatInput
    m_nCPOutput = 0X000360 // int32
    m_nOutVectorField = 0X000364 // int32
    m_flQuantizeValue = 0X000368 // CParticleCollectionFloatInput

 C_OP_RenderPoints: [particles.dll]
    m_hMaterial = 0X000260 // CStrongHandle< InfoForResourceTypeIMaterial2 >

 CBaseTrailRenderer: [particles.dll]
    m_nOrientationType = 0X002270 // ParticleOrientationChoiceList_t
    m_nOrientationControlPoint = 0X002274 // int32
    m_flMinSize = 0X002278 // float32
    m_flMaxSize = 0X00227C // float32
    m_flStartFadeSize = 0X002280 // CParticleCollectionRendererFloatInput
    m_flEndFadeSize = 0X0023C0 // CParticleCollectionRendererFloatInput
    m_bClampV = 0X002500 // bool

 C_OP_RenderTrails: [particles.dll]
    m_bEnableFadingAndClamping = 0X002510 // bool
    m_flStartFadeDot = 0X002514 // float32
    m_flEndFadeDot = 0X002518 // float32
    m_nPrevPntSource = 0X00251C // ParticleAttributeIndex_t
    m_flMaxLength = 0X002520 // float32
    m_flMinLength = 0X002524 // float32
    m_bIgnoreDT = 0X002528 // bool
    m_flConstrainRadiusToLengthRatio = 0X00252C // float32
    m_flLengthScale = 0X002530 // float32
    m_flLengthFadeInTime = 0X002534 // float32
    m_flRadiusHeadTaper = 0X002538 // CPerParticleFloatInput
    m_vecHeadColorScale = 0X002678 // CParticleCollectionVecInput
    m_flHeadAlphaScale = 0X002C60 // CPerParticleFloatInput
    m_flRadiusTaper = 0X002DA0 // CPerParticleFloatInput
    m_vecTailColorScale = 0X002EE0 // CParticleCollectionVecInput
    m_flTailAlphaScale = 0X0034C8 // CPerParticleFloatInput
    m_nHorizCropField = 0X003608 // ParticleAttributeIndex_t
    m_nVertCropField = 0X00360C // ParticleAttributeIndex_t
    m_flForwardShift = 0X003610 // float32
    m_bFlipUVBasedOnPitchYaw = 0X003614 // bool

 C_OP_RenderRopes: [particles.dll]
    m_bEnableFadingAndClamping = 0X002270 // bool
    m_flMinSize = 0X002274 // float32
    m_flMaxSize = 0X002278 // float32
    m_flStartFadeSize = 0X00227C // float32
    m_flEndFadeSize = 0X002280 // float32
    m_flStartFadeDot = 0X002284 // float32
    m_flEndFadeDot = 0X002288 // float32
    m_flRadiusTaper = 0X00228C // float32
    m_nMinTesselation = 0X002290 // int32
    m_nMaxTesselation = 0X002294 // int32
    m_flTessScale = 0X002298 // float32
    m_flTextureVWorldSize = 0X0022A0 // CParticleCollectionRendererFloatInput
    m_flTextureVScrollRate = 0X0023E0 // CParticleCollectionRendererFloatInput
    m_flTextureVOffset = 0X002520 // CParticleCollectionRendererFloatInput
    m_nTextureVParamsCP = 0X002660 // int32
    m_bClampV = 0X002664 // bool
    m_nScaleCP1 = 0X002668 // int32
    m_nScaleCP2 = 0X00266C // int32
    m_flScaleVSizeByControlPointDistance = 0X002670 // float32
    m_flScaleVScrollByControlPointDistance = 0X002674 // float32
    m_flScaleVOffsetByControlPointDistance = 0X002678 // float32
    m_bUseScalarForTextureCoordinate = 0X00267D // bool
    m_nScalarFieldForTextureCoordinate = 0X002680 // ParticleAttributeIndex_t
    m_flScalarAttributeTextureCoordScale = 0X002684 // float32
    m_bReverseOrder = 0X002688 // bool
    m_bClosedLoop = 0X002689 // bool
    m_nOrientationType = 0X00268C // ParticleOrientationChoiceList_t
    m_nVectorFieldForOrientation = 0X002690 // ParticleAttributeIndex_t
    m_bDrawAsOpaque = 0X002694 // bool
    m_bGenerateNormals = 0X002695 // bool

 C_OP_RenderAsModels: [particles.dll]
    m_ModelList = 0X000260 // CUtlVector< ModelReference_t >
    m_flModelScale = 0X00027C // float32
    m_bFitToModelSize = 0X000280 // bool
    m_bNonUniformScaling = 0X000281 // bool
    m_nXAxisScalingAttribute = 0X000284 // ParticleAttributeIndex_t
    m_nYAxisScalingAttribute = 0X000288 // ParticleAttributeIndex_t
    m_nZAxisScalingAttribute = 0X00028C // ParticleAttributeIndex_t
    m_nSizeCullBloat = 0X000290 // int32

 C_OP_RenderLights: [particles.dll]
    m_flAnimationRate = 0X000270 // float32
    m_nAnimationType = 0X000274 // AnimationType_t
    m_bAnimateInFPS = 0X000278 // bool
    m_flMinSize = 0X00027C // float32
    m_flMaxSize = 0X000280 // float32
    m_flStartFadeSize = 0X000284 // float32
    m_flEndFadeSize = 0X000288 // float32

 C_OP_RenderBlobs: [particles.dll]
    m_cubeWidth = 0X000260 // CParticleCollectionRendererFloatInput
    m_cutoffRadius = 0X0003A0 // CParticleCollectionRendererFloatInput
    m_renderRadius = 0X0004E0 // CParticleCollectionRendererFloatInput
    m_nScaleCP = 0X000620 // int32
    m_hMaterial = 0X000628 // CStrongHandle< InfoForResourceTypeIMaterial2 >

 C_OP_RenderScreenVelocityRotate: [particles.dll]
    m_flRotateRateDegrees = 0X000260 // float32
    m_flForwardDegrees = 0X000264 // float32

 C_OP_RenderModels: [particles.dll]
    m_bOnlyRenderInEffectsBloomPass = 0X000260 // bool
    m_bOnlyRenderInEffectsWaterPass = 0X000261 // bool
    m_bUseMixedResolutionRendering = 0X000262 // bool
    m_bOnlyRenderInEffecsGameOverlay = 0X000263 // bool
    m_ModelList = 0X000268 // CUtlVector< ModelReference_t >
    m_nBodyGroupField = 0X000284 // ParticleAttributeIndex_t
    m_nSubModelField = 0X000288 // ParticleAttributeIndex_t
    m_bIgnoreNormal = 0X00028C // bool
    m_bOrientZ = 0X00028D // bool
    m_bCenterOffset = 0X00028E // bool
    m_vecLocalOffset = 0X000290 // CPerParticleVecInput
    m_vecLocalRotation = 0X000878 // CPerParticleVecInput
    m_bIgnoreRadius = 0X000E60 // bool
    m_nModelScaleCP = 0X000E64 // int32
    m_vecComponentScale = 0X000E68 // CPerParticleVecInput
    m_bLocalScale = 0X001450 // bool
    m_bAnimated = 0X001451 // bool
    m_flAnimationRate = 0X001454 // float32
    m_bScaleAnimationRate = 0X001458 // bool
    m_bForceLoopingAnimation = 0X001459 // bool
    m_bResetAnimOnStop = 0X00145A // bool
    m_bManualAnimFrame = 0X00145B // bool
    m_nAnimationScaleField = 0X00145C // ParticleAttributeIndex_t
    m_nAnimationField = 0X001460 // ParticleAttributeIndex_t
    m_nManualFrameField = 0X001464 // ParticleAttributeIndex_t
    m_ActivityName = 0X001468 // char[256]
    m_SequenceName = 0X001568 // char[256]
    m_bEnableClothSimulation = 0X001668 // bool
    m_hOverrideMaterial = 0X001670 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_bOverrideTranslucentMaterials = 0X001678 // bool
    m_nSkin = 0X00167C // int32
    m_nSkinCP = 0X001680 // int32
    m_MaterialVars = 0X001688 // CUtlVector< MaterialVariable_t >
    m_modelInput = 0X0016A0 // CParticleModelInput
    m_nLOD = 0X0016E8 // int32
    m_EconSlotName = 0X0016EC // char[256]
    m_bOriginalModel = 0X0017EC // bool
    m_bSuppressTint = 0X0017ED // bool
    m_bUseRawMeshGroup = 0X0017EE // bool
    m_bDisableShadows = 0X0017EF // bool
    m_bForceDrawInterlevedWithSiblings = 0X0017F0 // bool
    m_szRenderAttribute = 0X0017F1 // char[260]
    m_flRadiusScale = 0X0018F8 // CParticleCollectionFloatInput
    m_flAlphaScale = 0X001A38 // CParticleCollectionFloatInput
    m_flRollScale = 0X001B78 // CParticleCollectionFloatInput
    m_nAlpha2Field = 0X001CB8 // ParticleAttributeIndex_t
    m_vecColorScale = 0X001CC0 // CParticleCollectionVecInput
    m_nColorBlendType = 0X0022A8 // ParticleColorBlendType_t

 C_OP_RenderMaterialProxy: [particles.dll]
    m_nMaterialControlPoint = 0X000260 // int32
    m_nProxyType = 0X000264 // MaterialProxyType_t
    m_MaterialVars = 0X000268 // CUtlVector< MaterialVariable_t >
    m_hOverrideMaterial = 0X000280 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_flMaterialOverrideEnabled = 0X000288 // CParticleCollectionFloatInput
    m_vecColorScale = 0X0003C8 // CParticleCollectionVecInput
    m_flAlpha = 0X0009B0 // CPerParticleFloatInput
    m_nColorBlendType = 0X000AF0 // ParticleColorBlendType_t

 C_OP_RenderProjected: [particles.dll]
    m_bProjectCharacter = 0X000260 // bool
    m_bProjectWorld = 0X000261 // bool
    m_bProjectWater = 0X000262 // bool
    m_bFlipHorizontal = 0X000263 // bool
    m_bEnableProjectedDepthControls = 0X000264 // bool
    m_flMinProjectionDepth = 0X000268 // float32
    m_flMaxProjectionDepth = 0X00026C // float32
    m_hProjectedMaterial = 0X000270 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_flAnimationTimeScale = 0X000278 // float32
    m_bOrientToNormal = 0X00027C // bool
    m_MaterialVars = 0X000280 // CUtlVector< MaterialVariable_t >

 C_OP_RenderDeferredLight: [particles.dll]
    m_bUseAlphaTestWindow = 0X000260 // bool
    m_bUseTexture = 0X000261 // bool
    m_flRadiusScale = 0X000264 // float32
    m_flAlphaScale = 0X000268 // float32
    m_nAlpha2Field = 0X00026C // ParticleAttributeIndex_t
    m_vecColorScale = 0X000270 // CParticleCollectionVecInput
    m_nColorBlendType = 0X000858 // ParticleColorBlendType_t
    m_flLightDistance = 0X00085C // float32
    m_flStartFalloff = 0X000860 // float32
    m_flDistanceFalloff = 0X000864 // float32
    m_flSpotFoV = 0X000868 // float32
    m_nAlphaTestPointField = 0X00086C // ParticleAttributeIndex_t
    m_nAlphaTestRangeField = 0X000870 // ParticleAttributeIndex_t
    m_nAlphaTestSharpnessField = 0X000874 // ParticleAttributeIndex_t
    m_hTexture = 0X000878 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_nHSVShiftControlPoint = 0X000880 // int32

 C_OP_RenderStandardLight: [particles.dll]
    m_nLightType = 0X000260 // ParticleLightTypeChoiceList_t
    m_vecColorScale = 0X000268 // CParticleCollectionVecInput
    m_nColorBlendType = 0X000850 // ParticleColorBlendType_t
    m_flIntensity = 0X000858 // CParticleCollectionFloatInput
    m_bCastShadows = 0X000998 // bool
    m_flTheta = 0X0009A0 // CParticleCollectionFloatInput
    m_flPhi = 0X000AE0 // CParticleCollectionFloatInput
    m_flRadiusMultiplier = 0X000C20 // CParticleCollectionFloatInput
    m_nAttenuationStyle = 0X000D60 // StandardLightingAttenuationStyle_t
    m_flFalloffLinearity = 0X000D68 // CParticleCollectionFloatInput
    m_flFiftyPercentFalloff = 0X000EA8 // CParticleCollectionFloatInput
    m_flZeroPercentFalloff = 0X000FE8 // CParticleCollectionFloatInput
    m_bRenderDiffuse = 0X001128 // bool
    m_bRenderSpecular = 0X001129 // bool
    m_lightCookie = 0X001130 // CUtlString
    m_nPriority = 0X001138 // int32
    m_nFogLightingMode = 0X00113C // ParticleLightFogLightingMode_t
    m_flFogContribution = 0X001140 // CParticleCollectionRendererFloatInput
    m_nCapsuleLightBehavior = 0X001280 // ParticleLightBehaviorChoiceList_t
    m_flCapsuleLength = 0X001284 // float32
    m_bReverseOrder = 0X001288 // bool
    m_bClosedLoop = 0X001289 // bool
    m_nPrevPntSource = 0X00128C // ParticleAttributeIndex_t
    m_flMaxLength = 0X001290 // float32
    m_flMinLength = 0X001294 // float32
    m_bIgnoreDT = 0X001298 // bool
    m_flConstrainRadiusToLengthRatio = 0X00129C // float32
    m_flLengthScale = 0X0012A0 // float32
    m_flLengthFadeInTime = 0X0012A4 // float32

 C_OP_RenderOmni2Light: [particles.dll]
    m_nLightType = 0X000260 // ParticleOmni2LightTypeChoiceList_t
    m_vColorBlend = 0X000268 // CParticleCollectionVecInput
    m_nColorBlendType = 0X000850 // ParticleColorBlendType_t
    m_nBrightnessUnit = 0X000854 // ParticleLightUnitChoiceList_t
    m_flBrightnessLumens = 0X000858 // CPerParticleFloatInput
    m_flBrightnessCandelas = 0X000998 // CPerParticleFloatInput
    m_bCastShadows = 0X000AD8 // bool
    m_flLuminaireRadius = 0X000AE0 // CPerParticleFloatInput
    m_flSkirt = 0X000C20 // CPerParticleFloatInput
    m_flRange = 0X000D60 // CPerParticleFloatInput
    m_flInnerConeAngle = 0X000EA0 // CPerParticleFloatInput
    m_flOuterConeAngle = 0X000FE0 // CPerParticleFloatInput
    m_hLightCookie = 0X001120 // CStrongHandle< InfoForResourceTypeCTextureBase >

 C_OP_RenderLightBeam: [particles.dll]
    m_vColorBlend = 0X000260 // CParticleCollectionVecInput
    m_nColorBlendType = 0X000848 // ParticleColorBlendType_t
    m_flBrightnessLumensPerMeter = 0X000850 // CParticleCollectionFloatInput
    m_bCastShadows = 0X000990 // bool
    m_flSkirt = 0X000998 // CParticleCollectionFloatInput
    m_flRange = 0X000AD8 // CParticleCollectionFloatInput
    m_flThickness = 0X000C18 // CParticleCollectionFloatInput

 C_OP_RenderClothForce: [particles.dll]
    No schemes available

 C_OP_Callback: [particles.dll]
    No schemes available

 C_OP_RenderScreenShake: [particles.dll]
    m_flDurationScale = 0X000260 // float32
    m_flRadiusScale = 0X000264 // float32
    m_flFrequencyScale = 0X000268 // float32
    m_flAmplitudeScale = 0X00026C // float32
    m_nRadiusField = 0X000270 // ParticleAttributeIndex_t
    m_nDurationField = 0X000274 // ParticleAttributeIndex_t
    m_nFrequencyField = 0X000278 // ParticleAttributeIndex_t
    m_nAmplitudeField = 0X00027C // ParticleAttributeIndex_t
    m_nFilterCP = 0X000280 // int32

 C_OP_RenderTonemapController: [particles.dll]
    m_flTonemapLevel = 0X000260 // float32
    m_flTonemapWeight = 0X000264 // float32
    m_nTonemapLevelField = 0X000268 // ParticleAttributeIndex_t
    m_nTonemapWeightField = 0X00026C // ParticleAttributeIndex_t

 C_OP_RenderPostProcessing: [particles.dll]
    m_flPostProcessStrength = 0X000260 // CPerParticleFloatInput
    m_hPostTexture = 0X0003A0 // CStrongHandle< InfoForResourceTypeCPostProcessingResource >
    m_nPriority = 0X0003A8 // ParticlePostProcessPriorityGroup_t

 C_OP_RenderSound: [particles.dll]
    m_flDurationScale = 0X000260 // float32
    m_flSndLvlScale = 0X000264 // float32
    m_flPitchScale = 0X000268 // float32
    m_flVolumeScale = 0X00026C // float32
    m_nSndLvlField = 0X000270 // ParticleAttributeIndex_t
    m_nDurationField = 0X000274 // ParticleAttributeIndex_t
    m_nPitchField = 0X000278 // ParticleAttributeIndex_t
    m_nVolumeField = 0X00027C // ParticleAttributeIndex_t
    m_nChannel = 0X000280 // int32
    m_nCPReference = 0X000284 // int32
    m_pszSoundName = 0X000288 // char[256]
    m_bSuppressStopSoundEvent = 0X000388 // bool

 C_OP_RenderStatusEffect: [particles.dll]
    m_pTextureColorWarp = 0X000260 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureDetail2 = 0X000268 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureDiffuseWarp = 0X000270 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureFresnelColorWarp = 0X000278 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureFresnelWarp = 0X000280 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureSpecularWarp = 0X000288 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureEnvMap = 0X000290 // CStrongHandle< InfoForResourceTypeCTextureBase >

 C_OP_RenderStatusEffectCitadel: [particles.dll]
    m_pTextureColorWarp = 0X000260 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureNormal = 0X000268 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureMetalness = 0X000270 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureRoughness = 0X000278 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureSelfIllum = 0X000280 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_pTextureDetail = 0X000288 // CStrongHandle< InfoForResourceTypeCTextureBase >

 C_OP_RenderFlattenGrass: [particles.dll]
    m_flFlattenStrength = 0X000260 // float32
    m_nStrengthFieldOverride = 0X000264 // ParticleAttributeIndex_t
    m_flRadiusScale = 0X000268 // float32

 C_OP_RenderTreeShake: [particles.dll]
    m_flPeakStrength = 0X000260 // float32
    m_nPeakStrengthFieldOverride = 0X000264 // ParticleAttributeIndex_t
    m_flRadius = 0X000268 // float32
    m_nRadiusFieldOverride = 0X00026C // ParticleAttributeIndex_t
    m_flShakeDuration = 0X000270 // float32
    m_flTransitionTime = 0X000274 // float32
    m_flTwistAmount = 0X000278 // float32
    m_flRadialAmount = 0X00027C // float32
    m_flControlPointOrientationAmount = 0X000280 // float32
    m_nControlPointForLinearDirection = 0X000284 // int32

 C_OP_RenderText: [particles.dll]
    m_OutlineColor = 0X000260 // Color
    m_DefaultText = 0X000268 // CUtlString

 C_OP_RenderVRHapticEvent: [particles.dll]
    m_nHand = 0X000260 // ParticleVRHandChoiceList_t
    m_nOutputHandCP = 0X000264 // int32
    m_nOutputField = 0X000268 // int32
    m_flAmplitude = 0X000270 // CPerParticleFloatInput


panorama.dll:
  No schemes classes available | panorama.dll


server.dll:
 CRangeFloat: [server.dll]
    m_pValue = 0X000000 // float32[2]

 CRangeInt: [server.dll]
    m_pValue = 0X000000 // int32[2]

 Extent: [server.dll]
    lo = 0X000000 // Vector
    hi = 0X00000C // Vector

 CNavVolume: [server.dll]
    No schemes available

 CNavVolumeVector: [server.dll]
    m_bHasBeenPreFiltered = 0X000078 // bool

 CNavVolumeAll: [server.dll]
    No schemes available

 CNavVolumeSphere: [server.dll]
    m_vCenter = 0X000070 // Vector
    m_flRadius = 0X00007C // float32

 CNavVolumeSphericalShell: [server.dll]
    m_flRadiusInner = 0X000080 // float32

 CEntityIdentity: [server.dll]
    m_nameStringableIndex = 0X000014 // int32
    m_name = 0X000018 // CUtlSymbolLarge
    m_designerName = 0X000020 // CUtlSymbolLarge
    m_flags = 0X000030 // uint32
    m_worldGroupId = 0X000038 // WorldGroupId_t
    m_fDataObjectTypes = 0X00003C // uint32
    m_PathIndex = 0X000040 // ChangeAccessorFieldPathIndex_t
    m_pPrev = 0X000058 // CEntityIdentity*
    m_pNext = 0X000060 // CEntityIdentity*
    m_pPrevByClass = 0X000068 // CEntityIdentity*
    m_pNextByClass = 0X000070 // CEntityIdentity*

 CEntityInstance: [server.dll]
    m_iszPrivateVScripts = 0X000008 // CUtlSymbolLarge
    m_pEntity = 0X000010 // CEntityIdentity*
    m_CScriptComponent = 0X000028 // CScriptComponent*

 CScriptComponent: [server.dll]
    m_scriptClassName = 0X000030 // CUtlSymbolLarge

 CBodyComponent: [server.dll]
    m_pSceneNode = 0X000008 // CGameSceneNode*
    __m_pChainEntity = 0X000020 // CNetworkVarChainer

 CBodyComponentPoint: [server.dll]
    m_sceneNode = 0X000050 // CGameSceneNode
    __m_pChainEntity = 0X0001A0 // CNetworkVarChainer

 CBodyComponentSkeletonInstance: [server.dll]
    m_skeletonInstance = 0X000050 // CSkeletonInstance
    __m_pChainEntity = 0X000440 // CNetworkVarChainer

 CHitboxComponent: [server.dll]
    m_bvDisabledHitGroups = 0X000024 // uint32[1]

 CLightComponent: [server.dll]
    __m_pChainEntity = 0X000048 // CNetworkVarChainer
    m_Color = 0X000085 // Color
    m_SecondaryColor = 0X000089 // Color
    m_flBrightness = 0X000090 // float32
    m_flBrightnessScale = 0X000094 // float32
    m_flBrightnessMult = 0X000098 // float32
    m_flRange = 0X00009C // float32
    m_flFalloff = 0X0000A0 // float32
    m_flAttenuation0 = 0X0000A4 // float32
    m_flAttenuation1 = 0X0000A8 // float32
    m_flAttenuation2 = 0X0000AC // float32
    m_flTheta = 0X0000B0 // float32
    m_flPhi = 0X0000B4 // float32
    m_hLightCookie = 0X0000B8 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_nCascades = 0X0000C0 // int32
    m_nCastShadows = 0X0000C4 // int32
    m_nShadowWidth = 0X0000C8 // int32
    m_nShadowHeight = 0X0000CC // int32
    m_bRenderDiffuse = 0X0000D0 // bool
    m_nRenderSpecular = 0X0000D4 // int32
    m_bRenderTransmissive = 0X0000D8 // bool
    m_flOrthoLightWidth = 0X0000DC // float32
    m_flOrthoLightHeight = 0X0000E0 // float32
    m_nStyle = 0X0000E4 // int32
    m_Pattern = 0X0000E8 // CUtlString
    m_nCascadeRenderStaticObjects = 0X0000F0 // int32
    m_flShadowCascadeCrossFade = 0X0000F4 // float32
    m_flShadowCascadeDistanceFade = 0X0000F8 // float32
    m_flShadowCascadeDistance0 = 0X0000FC // float32
    m_flShadowCascadeDistance1 = 0X000100 // float32
    m_flShadowCascadeDistance2 = 0X000104 // float32
    m_flShadowCascadeDistance3 = 0X000108 // float32
    m_nShadowCascadeResolution0 = 0X00010C // int32
    m_nShadowCascadeResolution1 = 0X000110 // int32
    m_nShadowCascadeResolution2 = 0X000114 // int32
    m_nShadowCascadeResolution3 = 0X000118 // int32
    m_bUsesBakedShadowing = 0X00011C // bool
    m_nShadowPriority = 0X000120 // int32
    m_nBakedShadowIndex = 0X000124 // int32
    m_bRenderToCubemaps = 0X000128 // bool
    m_LightGroups = 0X000130 // CUtlSymbolLarge
    m_nDirectLight = 0X000138 // int32
    m_nIndirectLight = 0X00013C // int32
    m_flFadeMinDist = 0X000140 // float32
    m_flFadeMaxDist = 0X000144 // float32
    m_flShadowFadeMinDist = 0X000148 // float32
    m_flShadowFadeMaxDist = 0X00014C // float32
    m_bEnabled = 0X000150 // bool
    m_bFlicker = 0X000151 // bool
    m_bPrecomputedFieldsValid = 0X000152 // bool
    m_vPrecomputedBoundsMins = 0X000154 // Vector
    m_vPrecomputedBoundsMaxs = 0X000160 // Vector
    m_vPrecomputedOBBOrigin = 0X00016C // Vector
    m_vPrecomputedOBBAngles = 0X000178 // QAngle
    m_vPrecomputedOBBExtent = 0X000184 // Vector
    m_flPrecomputedMaxRange = 0X000190 // float32
    m_nFogLightingMode = 0X000194 // int32
    m_flFogContributionStength = 0X000198 // float32
    m_flNearClipPlane = 0X00019C // float32
    m_SkyColor = 0X0001A0 // Color
    m_flSkyIntensity = 0X0001A4 // float32
    m_SkyAmbientBounce = 0X0001A8 // Color
    m_bUseSecondaryColor = 0X0001AC // bool
    m_bMixedShadows = 0X0001AD // bool
    m_flLightStyleStartTime = 0X0001B0 // GameTime_t
    m_flCapsuleLength = 0X0001B4 // float32
    m_flMinRoughness = 0X0001B8 // float32
    m_bPvsModifyEntity = 0X0001C8 // bool

 CNetworkTransmitComponent: [server.dll]
    m_nTransmitStateOwnedCounter = 0X00016C // uint8

 CRenderComponent: [server.dll]
    __m_pChainEntity = 0X000010 // CNetworkVarChainer
    m_bIsRenderingWithViewModels = 0X000050 // bool
    m_nSplitscreenFlags = 0X000054 // uint32
    m_bEnableRendering = 0X000060 // bool
    m_bInterpolationReadyToDraw = 0X0000B0 // bool

 AnimationUpdateListHandle_t: [server.dll]
    m_Value = 0X000000 // uint32

 CBuoyancyHelper: [server.dll]
    m_flFluidDensity = 0X000018 // float32
    m_flDisplacementFromObjects = 0X00001C // float32

 CSkillFloat: [server.dll]
    m_pValue = 0X000000 // float32[4]

 CSkillInt: [server.dll]
    m_pValue = 0X000000 // int32[4]

 CSkillDamage: [server.dll]
    m_flDamage = 0X000000 // CSkillFloat
    m_flPhysicsForceDamage = 0X000010 // float32

 CRemapFloat: [server.dll]
    m_pValue = 0X000000 // float32[4]

 CScriptUniformRandomStream: [server.dll]
    m_hScriptScope = 0X000008 // HSCRIPT
    m_nInitialSeed = 0X00009C // int32

 CommandToolCommand_t: [server.dll]
    m_bEnabled = 0X000000 // bool
    m_bOpened = 0X000001 // bool
    m_InternalId = 0X000004 // uint32
    m_ShortName = 0X000008 // CUtlString
    m_ExecMode = 0X000010 // CommandExecMode_t
    m_SpawnGroup = 0X000018 // CUtlString
    m_PeriodicExecDelay = 0X000020 // float32
    m_SpecType = 0X000024 // CommandEntitySpecType_t
    m_EntitySpec = 0X000028 // CUtlString
    m_Commands = 0X000030 // CUtlString
    m_SetDebugBits = 0X000038 // DebugOverlayBits_t
    m_ClearDebugBits = 0X000040 // DebugOverlayBits_t

 CPlayerPawnComponent: [server.dll]
    __m_pChainEntity = 0X000008 // CNetworkVarChainer

 CPlayerControllerComponent: [server.dll]
    __m_pChainEntity = 0X000008 // CNetworkVarChainer

 CPlayer_AutoaimServices: [server.dll]
    No schemes available

 audioparams_t: [server.dll]
    localSound = 0X000008 // Vector[8]
    soundscapeIndex = 0X000068 // int32
    localBits = 0X00006C // uint8
    soundscapeEntityListIndex = 0X000070 // int32
    soundEventHash = 0X000074 // uint32

 CPlayer_CameraServices: [server.dll]
    m_iFOV = 0X000040 // uint32
    m_iFOVStart = 0X000044 // uint32
    m_flFOVTime = 0X000048 // GameTime_t
    m_flFOVRate = 0X00004C // float32
    m_vecPunchAngle = 0X000050 // QAngle
    m_vecPunchAngleVel = 0X00005C // QAngle
    m_nPunchAngleJoltTick = 0X000068 // GameTick_t
    m_hZoomOwner = 0X00006C // CHandle< CBaseEntity >
    m_PlayerFog = 0X000070 // fogplayerparams_t
    m_hColorCorrectionCtrl = 0X0000B0 // CHandle< CColorCorrection >
    m_hViewEntity = 0X0000B4 // CHandle< CBaseEntity >
    m_hTonemapController = 0X0000B8 // CHandle< CTonemapController2 >
    m_audio = 0X0000C0 // audioparams_t
    m_PostProcessingVolumes = 0X000138 // CNetworkUtlVectorBase< CHandle< CPostProcessingVolume > >
    m_flOldPlayerZ = 0X000150 // float32
    m_flOldPlayerViewOffsetZ = 0X000154 // float32
    m_hTriggerSoundscapeList = 0X000170 // CUtlVector< CHandle< CEnvSoundscapeTriggerable > >

 CPlayer_FlashlightServices: [server.dll]
    No schemes available

 CPlayer_ItemServices: [server.dll]
    No schemes available

 CPlayer_MovementServices: [server.dll]
    m_nImpulse = 0X000040 // int32
    m_nButtons = 0X000048 // CInButtonState
    m_nQueuedButtonDownMask = 0X000068 // uint64
    m_nQueuedButtonChangeMask = 0X000070 // uint64
    m_nButtonDoublePressed = 0X000078 // uint64
    m_pButtonPressedCmdNumber = 0X000080 // uint32[64]
    m_nLastCommandNumberProcessed = 0X000180 // uint32
    m_nToggleButtonDownMask = 0X000188 // uint64
    m_flMaxspeed = 0X000190 // float32
    m_flForceSubtickMoveWhen = 0X000194 // float32
    m_flForwardMove = 0X000198 // float32
    m_flLeftMove = 0X00019C // float32
    m_flUpMove = 0X0001A0 // float32
    m_vecOldViewAngles = 0X0001A4 // QAngle

 CPlayer_MovementServices_Humanoid: [server.dll]
    m_flStepSoundTime = 0X0001B8 // float32
    m_flFallVelocity = 0X0001BC // float32
    m_bInCrouch = 0X0001C0 // bool
    m_nCrouchState = 0X0001C4 // uint32
    m_flCrouchTransitionStartTime = 0X0001C8 // GameTime_t
    m_bDucked = 0X0001CC // bool
    m_bDucking = 0X0001CD // bool
    m_bInDuckJump = 0X0001CE // bool
    m_groundNormal = 0X0001D0 // Vector
    m_flSurfaceFriction = 0X0001DC // float32
    m_surfaceProps = 0X0001E0 // CUtlStringToken
    m_nStepside = 0X0001F0 // int32
    m_iTargetVolume = 0X0001F4 // int32
    m_vecSmoothedVelocity = 0X0001F8 // Vector

 CPlayer_ObserverServices: [server.dll]
    m_iObserverMode = 0X000040 // uint8
    m_hObserverTarget = 0X000044 // CHandle< CBaseEntity >
    m_iObserverLastMode = 0X000048 // ObserverMode_t
    m_bForcedObserverMode = 0X00004C // bool

 CPlayer_UseServices: [server.dll]
    No schemes available

 CPlayer_WaterServices: [server.dll]
    No schemes available

 CPlayer_WeaponServices: [server.dll]
    m_bAllowSwitchToNoWeapon = 0X000040 // bool
    m_hMyWeapons = 0X000048 // CNetworkUtlVectorBase< CHandle< CBasePlayerWeapon > >
    m_hActiveWeapon = 0X000060 // CHandle< CBasePlayerWeapon >
    m_hLastWeapon = 0X000064 // CHandle< CBasePlayerWeapon >
    m_iAmmo = 0X000068 // uint16[32]
    m_bPreventWeaponPickup = 0X0000A8 // bool

 AmmoTypeInfo_t: [server.dll]
    m_nMaxCarry = 0X000010 // int32
    m_nSplashSize = 0X00001C // CRangeInt
    m_nFlags = 0X000024 // AmmoFlags_t
    m_flMass = 0X000028 // float32
    m_flSpeed = 0X00002C // CRangeFloat

 CBodyComponentBaseAnimGraph: [server.dll]
    m_animationController = 0X000470 // CBaseAnimGraphController
    __m_pChainEntity = 0X000720 // CNetworkVarChainer

 EntityRenderAttribute_t: [server.dll]
    m_ID = 0X000030 // CUtlStringToken
    m_Values = 0X000034 // Vector4D

 ModelConfigHandle_t: [server.dll]
    m_Value = 0X000000 // uint32

 ActiveModelConfig_t: [server.dll]
    m_Handle = 0X000028 // ModelConfigHandle_t
    m_Name = 0X000030 // CUtlSymbolLarge
    m_AssociatedEntities = 0X000038 // CNetworkUtlVectorBase< CHandle< CBaseModelEntity > >
    m_AssociatedEntityNames = 0X000050 // CNetworkUtlVectorBase< CUtlSymbolLarge >

 CBodyComponentBaseModelEntity: [server.dll]
    __m_pChainEntity = 0X000470 // CNetworkVarChainer

 CNetworkOriginCellCoordQuantizedVector: [server.dll]
    m_cellX = 0X000010 // uint16
    m_cellY = 0X000012 // uint16
    m_cellZ = 0X000014 // uint16
    m_nOutsideWorld = 0X000016 // uint16
    m_vecX = 0X000018 // CNetworkedQuantizedFloat
    m_vecY = 0X000020 // CNetworkedQuantizedFloat
    m_vecZ = 0X000028 // CNetworkedQuantizedFloat

 CNetworkOriginQuantizedVector: [server.dll]
    m_vecX = 0X000010 // CNetworkedQuantizedFloat
    m_vecY = 0X000018 // CNetworkedQuantizedFloat
    m_vecZ = 0X000020 // CNetworkedQuantizedFloat

 CNetworkVelocityVector: [server.dll]
    m_vecX = 0X000010 // CNetworkedQuantizedFloat
    m_vecY = 0X000018 // CNetworkedQuantizedFloat
    m_vecZ = 0X000020 // CNetworkedQuantizedFloat

 CNetworkViewOffsetVector: [server.dll]
    m_vecX = 0X000010 // CNetworkedQuantizedFloat
    m_vecY = 0X000018 // CNetworkedQuantizedFloat
    m_vecZ = 0X000020 // CNetworkedQuantizedFloat

 GameTime_t: [server.dll]
    m_Value = 0X000000 // float32

 GameTick_t: [server.dll]
    m_Value = 0X000000 // int32

 CGameSceneNodeHandle: [server.dll]
    m_hOwner = 0X000008 // CEntityHandle
    m_name = 0X00000C // CUtlStringToken

 CGameSceneNode: [server.dll]
    m_nodeToWorld = 0X000010 // CTransform
    m_pOwner = 0X000030 // CEntityInstance*
    m_pParent = 0X000038 // CGameSceneNode*
    m_pChild = 0X000040 // CGameSceneNode*
    m_pNextSibling = 0X000048 // CGameSceneNode*
    m_hParent = 0X000070 // CGameSceneNodeHandle
    m_vecOrigin = 0X000080 // CNetworkOriginCellCoordQuantizedVector
    m_angRotation = 0X0000B8 // QAngle
    m_flScale = 0X0000C4 // float32
    m_vecAbsOrigin = 0X0000C8 // Vector
    m_angAbsRotation = 0X0000D4 // QAngle
    m_flAbsScale = 0X0000E0 // float32
    m_nParentAttachmentOrBone = 0X0000E4 // int16
    m_bDebugAbsOriginChanges = 0X0000E6 // bool
    m_bDormant = 0X0000E7 // bool
    m_bForceParentToBeNetworked = 0X0000E8 // bool
    m_bDirtyHierarchy = 0X000000 // bitfield:1
    m_bDirtyBoneMergeInfo = 0X000000 // bitfield:1
    m_bNetworkedPositionChanged = 0X000000 // bitfield:1
    m_bNetworkedAnglesChanged = 0X000000 // bitfield:1
    m_bNetworkedScaleChanged = 0X000000 // bitfield:1
    m_bWillBeCallingPostDataUpdate = 0X000000 // bitfield:1
    m_bNotifyBoneTransformsChanged = 0X000000 // bitfield:1
    m_bBoneMergeFlex = 0X000000 // bitfield:1
    m_nLatchAbsOrigin = 0X000000 // bitfield:2
    m_bDirtyBoneMergeBoneToRoot = 0X000000 // bitfield:1
    m_nHierarchicalDepth = 0X0000EB // uint8
    m_nHierarchyType = 0X0000EC // uint8
    m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0X0000ED // uint8
    m_name = 0X0000F0 // CUtlStringToken
    m_hierarchyAttachName = 0X000130 // CUtlStringToken
    m_flZOffset = 0X000134 // float32
    m_vRenderOrigin = 0X000138 // Vector

 IChoreoServices: [server.dll]
    No schemes available

 CInButtonState: [server.dll]
    m_pButtonStates = 0X000008 // uint64[3]

 CSkeletonAnimationController: [server.dll]
    m_pSkeletonInstance = 0X000008 // CSkeletonInstance*

 CNetworkedSequenceOperation: [server.dll]
    m_hSequence = 0X000008 // HSequence
    m_flPrevCycle = 0X00000C // float32
    m_flCycle = 0X000010 // float32
    m_flWeight = 0X000014 // CNetworkedQuantizedFloat
    m_bSequenceChangeNetworked = 0X00001C // bool
    m_bDiscontinuity = 0X00001D // bool
    m_flPrevCycleFromDiscontinuity = 0X000020 // float32
    m_flPrevCycleForAnimEventDetection = 0X000024 // float32

 CModelState: [server.dll]
    m_hModel = 0X0000A0 // CStrongHandle< InfoForResourceTypeCModel >
    m_ModelName = 0X0000A8 // CUtlSymbolLarge
    m_bClientClothCreationSuppressed = 0X0000E8 // bool
    m_MeshGroupMask = 0X000180 // uint64
    m_nIdealMotionType = 0X000222 // int8
    m_nForceLOD = 0X000223 // int8
    m_nClothUpdateFlags = 0X000224 // int8

 CSkeletonInstance: [server.dll]
    m_modelState = 0X000160 // CModelState
    m_bIsAnimationEnabled = 0X000390 // bool
    m_bUseParentRenderBounds = 0X000391 // bool
    m_bDisableSolidCollisionsForHierarchy = 0X000392 // bool
    m_bDirtyMotionType = 0X000000 // bitfield:1
    m_bIsGeneratingLatchedParentSpaceState = 0X000000 // bitfield:1
    m_materialGroup = 0X000394 // CUtlStringToken
    m_nHitboxSet = 0X000398 // uint8

 IntervalTimer: [server.dll]
    m_timestamp = 0X000008 // GameTime_t
    m_nWorldGroupId = 0X00000C // WorldGroupId_t

 CountdownTimer: [server.dll]
    m_duration = 0X000008 // float32
    m_timestamp = 0X00000C // GameTime_t
    m_timescale = 0X000010 // float32
    m_nWorldGroupId = 0X000014 // WorldGroupId_t

 EngineCountdownTimer: [server.dll]
    m_duration = 0X000008 // float32
    m_timestamp = 0X00000C // float32
    m_timescale = 0X000010 // float32

 CTimeline: [server.dll]
    m_flValues = 0X000010 // float32[64]
    m_nValueCounts = 0X000110 // int32[64]
    m_nBucketCount = 0X000210 // int32
    m_flInterval = 0X000214 // float32
    m_flFinalValue = 0X000218 // float32
    m_nCompressionType = 0X00021C // TimelineCompression_t
    m_bStopped = 0X000220 // bool

 CAnimGraphNetworkedVariables: [server.dll]
    m_PredNetBoolVariables = 0X000008 // CNetworkUtlVectorBase< uint32 >
    m_PredNetByteVariables = 0X000020 // CNetworkUtlVectorBase< uint8 >
    m_PredNetUInt16Variables = 0X000038 // CNetworkUtlVectorBase< uint16 >
    m_PredNetIntVariables = 0X000050 // CNetworkUtlVectorBase< int32 >
    m_PredNetUInt32Variables = 0X000068 // CNetworkUtlVectorBase< uint32 >
    m_PredNetFloatVariables = 0X000080 // CNetworkUtlVectorBase< float32 >
    m_PredNetVectorVariables = 0X000098 // CNetworkUtlVectorBase< Vector >
    m_PredNetQuaternionVariables = 0X0000B0 // CNetworkUtlVectorBase< Quaternion >
    m_OwnerOnlyPredNetBoolVariables = 0X0000C8 // CNetworkUtlVectorBase< uint32 >
    m_OwnerOnlyPredNetByteVariables = 0X0000E0 // CNetworkUtlVectorBase< uint8 >
    m_OwnerOnlyPredNetUInt16Variables = 0X0000F8 // CNetworkUtlVectorBase< uint16 >
    m_OwnerOnlyPredNetIntVariables = 0X000110 // CNetworkUtlVectorBase< int32 >
    m_OwnerOnlyPredNetUInt32Variables = 0X000128 // CNetworkUtlVectorBase< uint32 >
    m_OwnerOnlyPredNetFloatVariables = 0X000140 // CNetworkUtlVectorBase< float32 >
    m_OwnerOnlyPredNetVectorVariables = 0X000158 // CNetworkUtlVectorBase< Vector >
    m_OwnerOnlyPredNetQuaternionVariables = 0X000170 // CNetworkUtlVectorBase< Quaternion >
    m_nBoolVariablesCount = 0X000188 // int32
    m_nOwnerOnlyBoolVariablesCount = 0X00018C // int32
    m_nRandomSeedOffset = 0X000190 // int32
    m_flLastTeleportTime = 0X000194 // float32

 CFootstepTableHandle: [server.dll]
    No schemes available

 ResponseFollowup: [server.dll]
    followup_concept = 0X000000 // char*
    followup_contexts = 0X000008 // char*
    followup_delay = 0X000010 // float32
    followup_target = 0X000014 // char*
    followup_entityiotarget = 0X00001C // char*
    followup_entityioinput = 0X000024 // char*
    followup_entityiodelay = 0X00002C // float32
    bFired = 0X000030 // bool

 ResponseParams: [server.dll]
    odds = 0X000010 // int16
    flags = 0X000012 // int16
    m_pFollowup = 0X000018 // ResponseFollowup*

 CResponseCriteriaSet: [server.dll]
    m_nNumPrefixedContexts = 0X000028 // int32
    m_bOverrideOnAppend = 0X00002C // bool

 CRR_Response: [server.dll]
    m_Type = 0X000000 // uint8
    m_szResponseName = 0X000001 // char[192]
    m_szMatchingRule = 0X0000C1 // char[128]
    m_Params = 0X000148 // ResponseParams
    m_fMatchScore = 0X000168 // float32
    m_szSpeakerContext = 0X000170 // char*
    m_szWorldContext = 0X000178 // char*
    m_Followup = 0X000180 // ResponseFollowup
    m_pchCriteriaNames = 0X0001B8 // CUtlVector< CUtlSymbol >
    m_pchCriteriaValues = 0X0001D0 // CUtlVector< char* >

 ConceptHistory_t: [server.dll]
    timeSpoken = 0X000000 // float32
    m_response = 0X000008 // CRR_Response

 CAI_Expresser: [server.dll]
    m_flStopTalkTime = 0X000038 // GameTime_t
    m_flStopTalkTimeWithoutDelay = 0X00003C // GameTime_t
    m_flBlockedTalkTime = 0X000040 // GameTime_t
    m_voicePitch = 0X000044 // int32
    m_flLastTimeAcceptedSpeak = 0X000048 // GameTime_t
    m_bAllowSpeakingInterrupts = 0X00004C // bool
    m_bConsiderSceneInvolvementAsSpeech = 0X00004D // bool
    m_nLastSpokenPriority = 0X000050 // int32
    m_pOuter = 0X000058 // CBaseFlex*

 CResponseQueue: [server.dll]
    m_ExpresserTargets = 0X000050 // CUtlVector< CAI_Expresser* >

 CResponseQueue::CDeferredResponse: [server.dll]
    m_contexts = 0X000010 // CResponseCriteriaSet
    m_fDispatchTime = 0X000040 // float32
    m_hIssuer = 0X000044 // CHandle< CBaseEntity >
    m_response = 0X000050 // CRR_Response
    m_bResponseValid = 0X000238 // bool

 CAI_ExpresserWithFollowup: [server.dll]
    m_pPostponedFollowup = 0X000060 // ResponseFollowup*

 CMultiplayer_Expresser: [server.dll]
    m_bAllowMultipleScenes = 0X000070 // bool

 CCommentarySystem: [server.dll]
    m_bCommentaryConvarsChanging = 0X000011 // bool
    m_bCommentaryEnabledMidGame = 0X000012 // bool
    m_flNextTeleportTime = 0X000014 // GameTime_t
    m_iTeleportStage = 0X000018 // int32
    m_bCheatState = 0X00001C // bool
    m_bIsFirstSpawnGroupToLoad = 0X00001D // bool
    m_hCurrentNode = 0X000038 // CHandle< CPointCommentaryNode >
    m_hActiveCommentaryNode = 0X00003C // CHandle< CPointCommentaryNode >
    m_hLastCommentaryNode = 0X000040 // CHandle< CPointCommentaryNode >
    m_vecNodes = 0X000048 // CUtlVector< CHandle< CPointCommentaryNode > >

 CPhysicsShake: [server.dll]
    m_force = 0X000008 // Vector

 CGameScriptedMoveData: [server.dll]
    m_vDest = 0X000000 // Vector
    m_vSrc = 0X00000C // Vector
    m_angSrc = 0X000018 // QAngle
    m_angDst = 0X000024 // QAngle
    m_angCurrent = 0X000030 // QAngle
    m_flAngRate = 0X00003C // float32
    m_flDuration = 0X000040 // float32
    m_flStartTime = 0X000044 // GameTime_t
    m_nPrevMoveType = 0X000048 // MoveType_t
    m_bActive = 0X000049 // bool
    m_bTeleportOnEnd = 0X00004A // bool
    m_bIgnoreRotation = 0X00004B // bool
    m_nType = 0X00004C // ScriptedMoveType_t
    m_bSuccess = 0X000050 // bool
    m_nForcedCrouchState = 0X000054 // ForcedCrouchState_t
    m_bIgnoreCollisions = 0X000058 // bool

 CGameChoreoServices: [server.dll]
    m_hOwner = 0X000008 // CHandle< CBaseAnimGraph >
    m_hScriptedSequence = 0X00000C // CHandle< CScriptedSequence >
    m_scriptState = 0X000010 // IChoreoServices::ScriptState_t
    m_choreoState = 0X000014 // IChoreoServices::ChoreoState_t
    m_flTimeStartedState = 0X000018 // GameTime_t

 HullFlags_t: [server.dll]
    m_bHull_Human = 0X000000 // bool
    m_bHull_SmallCentered = 0X000001 // bool
    m_bHull_WideHuman = 0X000002 // bool
    m_bHull_Tiny = 0X000003 // bool
    m_bHull_Medium = 0X000004 // bool
    m_bHull_TinyCentered = 0X000005 // bool
    m_bHull_Large = 0X000006 // bool
    m_bHull_LargeCentered = 0X000007 // bool
    m_bHull_MediumTall = 0X000008 // bool
    m_bHull_Small = 0X000009 // bool

 CConstantForceController: [server.dll]
    m_linear = 0X00000C // Vector
    m_angular = 0X000018 // RotationVector
    m_linearSave = 0X000024 // Vector
    m_angularSave = 0X000030 // RotationVector

 CMotorController: [server.dll]
    m_speed = 0X000008 // float32
    m_maxTorque = 0X00000C // float32
    m_axis = 0X000010 // Vector
    m_inertiaFactor = 0X00001C // float32

 CSoundEnvelope: [server.dll]
    m_current = 0X000000 // float32
    m_target = 0X000004 // float32
    m_rate = 0X000008 // float32
    m_forceupdate = 0X00000C // bool

 CCopyRecipientFilter: [server.dll]
    m_Flags = 0X000008 // int32
    m_Recipients = 0X000010 // CUtlVector< CPlayerSlot >

 CSoundPatch: [server.dll]
    m_pitch = 0X000008 // CSoundEnvelope
    m_volume = 0X000018 // CSoundEnvelope
    m_shutdownTime = 0X000030 // float32
    m_flLastTime = 0X000034 // float32
    m_iszSoundScriptName = 0X000038 // CUtlSymbolLarge
    m_hEnt = 0X000040 // CHandle< CBaseEntity >
    m_soundEntityIndex = 0X000044 // CEntityIndex
    m_soundOrigin = 0X000048 // Vector
    m_isPlaying = 0X000054 // int32
    m_Filter = 0X000058 // CCopyRecipientFilter
    m_flCloseCaptionDuration = 0X000080 // float32
    m_bUpdatedSoundOrigin = 0X000084 // bool
    m_iszClassName = 0X000088 // CUtlSymbolLarge

 CTouchExpansionComponent: [server.dll]
    No schemes available

 dynpitchvol_base_t: [server.dll]
    preset = 0X000000 // int32
    pitchrun = 0X000004 // int32
    pitchstart = 0X000008 // int32
    spinup = 0X00000C // int32
    spindown = 0X000010 // int32
    volrun = 0X000014 // int32
    volstart = 0X000018 // int32
    fadein = 0X00001C // int32
    fadeout = 0X000020 // int32
    lfotype = 0X000024 // int32
    lforate = 0X000028 // int32
    lfomodpitch = 0X00002C // int32
    lfomodvol = 0X000030 // int32
    cspinup = 0X000034 // int32
    cspincount = 0X000038 // int32
    pitch = 0X00003C // int32
    spinupsav = 0X000040 // int32
    spindownsav = 0X000044 // int32
    pitchfrac = 0X000048 // int32
    vol = 0X00004C // int32
    fadeinsav = 0X000050 // int32
    fadeoutsav = 0X000054 // int32
    volfrac = 0X000058 // int32
    lfofrac = 0X00005C // int32
    lfomult = 0X000060 // int32

 dynpitchvol_t: [server.dll]
    No schemes available

 ResponseContext_t: [server.dll]
    m_iszName = 0X000000 // CUtlSymbolLarge
    m_iszValue = 0X000008 // CUtlSymbolLarge
    m_fExpirationTime = 0X000010 // GameTime_t

 Relationship_t: [server.dll]
    disposition = 0X000000 // Disposition_t
    priority = 0X000004 // int32

 CBaseEntity: [server.dll]
    m_CBodyComponent = 0X000030 // CBodyComponent*
    m_NetworkTransmitComponent = 0X000038 // CNetworkTransmitComponent
    m_aThinkFunctions = 0X000218 // CUtlVector< thinkfunc_t >
    m_iCurrentThinkContext = 0X000230 // int32
    m_nLastThinkTick = 0X000234 // GameTick_t
    m_isSteadyState = 0X000240 // CBitVec< 64 >
    m_lastNetworkChange = 0X000248 // float32
    m_ResponseContexts = 0X000258 // CUtlVector< ResponseContext_t >
    m_iszResponseContext = 0X000270 // CUtlSymbolLarge
    m_iHealth = 0X000298 // int32
    m_iMaxHealth = 0X00029C // int32
    m_lifeState = 0X0002A0 // uint8
    m_flDamageAccumulator = 0X0002A4 // float32
    m_bTakesDamage = 0X0002A8 // bool
    m_nTakeDamageFlags = 0X0002AC // TakeDamageFlags_t
    m_MoveCollide = 0X0002B1 // MoveCollide_t
    m_MoveType = 0X0002B2 // MoveType_t
    m_nWaterTouch = 0X0002B3 // uint8
    m_nSlimeTouch = 0X0002B4 // uint8
    m_bRestoreInHierarchy = 0X0002B5 // bool
    m_target = 0X0002B8 // CUtlSymbolLarge
    m_flMoveDoneTime = 0X0002C0 // float32
    m_hDamageFilter = 0X0002C4 // CHandle< CBaseFilter >
    m_iszDamageFilterName = 0X0002C8 // CUtlSymbolLarge
    m_nSubclassID = 0X0002D0 // CUtlStringToken
    m_flAnimTime = 0X0002E0 // float32
    m_flSimulationTime = 0X0002E4 // float32
    m_flCreateTime = 0X0002E8 // GameTime_t
    m_bClientSideRagdoll = 0X0002EC // bool
    m_ubInterpolationFrame = 0X0002ED // uint8
    m_vPrevVPhysicsUpdatePos = 0X0002F0 // Vector
    m_iTeamNum = 0X0002FC // uint8
    m_iGlobalname = 0X000300 // CUtlSymbolLarge
    m_iSentToClients = 0X000308 // int32
    m_flSpeed = 0X00030C // float32
    m_sUniqueHammerID = 0X000310 // CUtlString
    m_spawnflags = 0X000318 // uint32
    m_nNextThinkTick = 0X00031C // GameTick_t
    m_nSimulationTick = 0X000320 // int32
    m_OnKilled = 0X000328 // CEntityIOOutput
    m_fFlags = 0X000350 // uint32
    m_vecAbsVelocity = 0X000354 // Vector
    m_vecVelocity = 0X000360 // CNetworkVelocityVector
    m_vecBaseVelocity = 0X000390 // Vector
    m_nPushEnumCount = 0X00039C // int32
    m_pCollision = 0X0003A0 // CCollisionProperty*
    m_hEffectEntity = 0X0003A8 // CHandle< CBaseEntity >
    m_hOwnerEntity = 0X0003AC // CHandle< CBaseEntity >
    m_fEffects = 0X0003B0 // uint32
    m_hGroundEntity = 0X0003B4 // CHandle< CBaseEntity >
    m_flFriction = 0X0003B8 // float32
    m_flElasticity = 0X0003BC // float32
    m_flGravityScale = 0X0003C0 // float32
    m_flTimeScale = 0X0003C4 // float32
    m_flWaterLevel = 0X0003C8 // float32
    m_bSimulatedEveryTick = 0X0003CC // bool
    m_bAnimatedEveryTick = 0X0003CD // bool
    m_nMinCPULevel = 0X0003CE // uint8
    m_nMaxCPULevel = 0X0003CF // uint8
    m_nMinGPULevel = 0X0003D0 // uint8
    m_nMaxGPULevel = 0X0003D1 // uint8
    m_bDisableLowViolence = 0X0003D2 // bool
    m_nWaterType = 0X0003D3 // uint8
    m_iEFlags = 0X0003D4 // int32
    m_OnUser1 = 0X0003D8 // CEntityIOOutput
    m_OnUser2 = 0X000400 // CEntityIOOutput
    m_OnUser3 = 0X000428 // CEntityIOOutput
    m_OnUser4 = 0X000450 // CEntityIOOutput
    m_iInitialTeamNum = 0X000478 // int32
    m_flNavIgnoreUntilTime = 0X00047C // GameTime_t
    m_vecAngVelocity = 0X000480 // QAngle
    m_bNetworkQuantizeOriginAndAngles = 0X00048C // bool
    m_bLagCompensate = 0X00048D // bool
    m_flOverriddenFriction = 0X000490 // float32
    m_pBlocker = 0X000494 // CHandle< CBaseEntity >
    m_flLocalTime = 0X000498 // float32
    m_flVPhysicsUpdateLocalTime = 0X00049C // float32

 CServerOnlyEntity: [server.dll]
    No schemes available

 CServerOnlyPointEntity: [server.dll]
    No schemes available

 CLogicalEntity: [server.dll]
    No schemes available

 CColorCorrection: [server.dll]
    m_flFadeInDuration = 0X0004A0 // float32
    m_flFadeOutDuration = 0X0004A4 // float32
    m_flStartFadeInWeight = 0X0004A8 // float32
    m_flStartFadeOutWeight = 0X0004AC // float32
    m_flTimeStartFadeIn = 0X0004B0 // GameTime_t
    m_flTimeStartFadeOut = 0X0004B4 // GameTime_t
    m_flMaxWeight = 0X0004B8 // float32
    m_bStartDisabled = 0X0004BC // bool
    m_bEnabled = 0X0004BD // bool
    m_bMaster = 0X0004BE // bool
    m_bClientSide = 0X0004BF // bool
    m_bExclusive = 0X0004C0 // bool
    m_MinFalloff = 0X0004C4 // float32
    m_MaxFalloff = 0X0004C8 // float32
    m_flCurWeight = 0X0004CC // float32
    m_netlookupFilename = 0X0004D0 // char[512]
    m_lookupFilename = 0X0006D0 // CUtlSymbolLarge

 CEntityFlame: [server.dll]
    m_hEntAttached = 0X0004A0 // CHandle< CBaseEntity >
    m_bCheapEffect = 0X0004A4 // bool
    m_flSize = 0X0004A8 // float32
    m_bUseHitboxes = 0X0004AC // bool
    m_iNumHitboxFires = 0X0004B0 // int32
    m_flHitboxFireScale = 0X0004B4 // float32
    m_flLifetime = 0X0004B8 // GameTime_t
    m_hAttacker = 0X0004BC // CHandle< CBaseEntity >
    m_iDangerSound = 0X0004C0 // int32
    m_flDirectDamagePerSecond = 0X0004C4 // float32
    m_iCustomDamageType = 0X0004C8 // int32

 CBaseFilter: [server.dll]
    m_bNegated = 0X0004A0 // bool
    m_OnPass = 0X0004A8 // CEntityIOOutput
    m_OnFail = 0X0004D0 // CEntityIOOutput

 CFilterMultiple: [server.dll]
    m_nFilterType = 0X0004F8 // filter_t
    m_iFilterName = 0X000500 // CUtlSymbolLarge[10]
    m_hFilter = 0X000550 // CHandle< CBaseEntity >[10]
    m_nFilterCount = 0X000578 // int32

 CFilterProximity: [server.dll]
    m_flRadius = 0X0004F8 // float32

 CFilterLOS: [server.dll]
    No schemes available

 CFilterClass: [server.dll]
    m_iFilterClass = 0X0004F8 // CUtlSymbolLarge

 CBaseFire: [server.dll]
    m_flScale = 0X0004A0 // float32
    m_flStartScale = 0X0004A4 // float32
    m_flScaleTime = 0X0004A8 // float32
    m_nFlags = 0X0004AC // uint32

 CFireSmoke: [server.dll]
    m_nFlameModelIndex = 0X0004B0 // int32
    m_nFlameFromAboveModelIndex = 0X0004B4 // int32

 CFishPool: [server.dll]
    m_fishCount = 0X0004B0 // int32
    m_maxRange = 0X0004B4 // float32
    m_swimDepth = 0X0004B8 // float32
    m_waterLevel = 0X0004BC // float32
    m_isDormant = 0X0004C0 // bool
    m_fishes = 0X0004C8 // CUtlVector< CHandle< CFish > >
    m_visTimer = 0X0004E0 // CountdownTimer

 CInfoData: [server.dll]
    No schemes available

 locksound_t: [server.dll]
    sLockedSound = 0X000008 // CUtlSymbolLarge
    sUnlockedSound = 0X000010 // CUtlSymbolLarge
    flwaitSound = 0X000018 // GameTime_t

 CLogicBranch: [server.dll]
    m_bInValue = 0X0004A0 // bool
    m_Listeners = 0X0004A8 // CUtlVector< CHandle< CBaseEntity > >
    m_OnTrue = 0X0004C0 // CEntityIOOutput
    m_OnFalse = 0X0004E8 // CEntityIOOutput

 CLogicDistanceCheck: [server.dll]
    m_iszEntityA = 0X0004A0 // CUtlSymbolLarge
    m_iszEntityB = 0X0004A8 // CUtlSymbolLarge
    m_flZone1Distance = 0X0004B0 // float32
    m_flZone2Distance = 0X0004B4 // float32
    m_InZone1 = 0X0004B8 // CEntityIOOutput
    m_InZone2 = 0X0004E0 // CEntityIOOutput
    m_InZone3 = 0X000508 // CEntityIOOutput

 VelocitySampler: [server.dll]
    m_prevSample = 0X000000 // Vector
    m_fPrevSampleTime = 0X00000C // GameTime_t
    m_fIdealSampleRate = 0X000010 // float32

 SimpleConstraintSoundProfile: [server.dll]
    eKeypoints = 0X000008 // SimpleConstraintSoundProfile::SimpleConstraintsSoundProfileKeypoints_t
    m_keyPoints = 0X00000C // float32[2]
    m_reversalSoundThresholds = 0X000014 // float32[3]

 ConstraintSoundInfo: [server.dll]
    m_vSampler = 0X000008 // VelocitySampler
    m_soundProfile = 0X000020 // SimpleConstraintSoundProfile
    m_forwardAxis = 0X000040 // Vector
    m_iszTravelSoundFwd = 0X000050 // CUtlSymbolLarge
    m_iszTravelSoundBack = 0X000058 // CUtlSymbolLarge
    m_iszReversalSounds = 0X000068 // CUtlSymbolLarge[3]
    m_bPlayTravelSound = 0X000080 // bool
    m_bPlayReversalSound = 0X000081 // bool

 CSmoothFunc: [server.dll]
    m_flSmoothAmplitude = 0X000008 // float32
    m_flSmoothBias = 0X00000C // float32
    m_flSmoothDuration = 0X000010 // float32
    m_flSmoothRemainingTime = 0X000014 // float32
    m_nSmoothDir = 0X000018 // int32

 magnetted_objects_t: [server.dll]
    hEntity = 0X000008 // CHandle< CBaseEntity >

 CPointPrefab: [server.dll]
    m_targetMapName = 0X0004A0 // CUtlSymbolLarge
    m_forceWorldGroupID = 0X0004A8 // CUtlSymbolLarge
    m_fixupNames = 0X0004B0 // bool

 CSkyboxReference: [server.dll]
    m_worldGroupId = 0X0004A0 // WorldGroupId_t
    m_hSkyCamera = 0X0004A4 // CHandle< CSkyCamera >

 CSkyCamera: [server.dll]
    m_skyboxData = 0X0004A0 // sky3dparams_t
    m_skyboxSlotToken = 0X000530 // CUtlStringToken
    m_bUseAngles = 0X000534 // bool
    m_pNext = 0X000538 // CSkyCamera*

 CSound: [server.dll]
    m_hOwner = 0X000000 // CHandle< CBaseEntity >
    m_hTarget = 0X000004 // CHandle< CBaseEntity >
    m_iVolume = 0X000008 // int32
    m_flOcclusionScale = 0X00000C // float32
    m_iType = 0X000010 // int32
    m_iNextAudible = 0X000014 // int32
    m_flExpireTime = 0X000018 // GameTime_t
    m_iNext = 0X00001C // int16
    m_bNoExpirationTime = 0X00001E // bool
    m_ownerChannelIndex = 0X000020 // int32
    m_vecOrigin = 0X000024 // Vector
    m_bHasOwner = 0X000030 // bool

 CEnvSoundscape: [server.dll]
    m_OnPlay = 0X0004A0 // CEntityIOOutput
    m_flRadius = 0X0004C8 // float32
    m_soundscapeName = 0X0004D0 // CUtlSymbolLarge
    m_soundEventName = 0X0004D8 // CUtlSymbolLarge
    m_bOverrideWithEvent = 0X0004E0 // bool
    m_soundscapeIndex = 0X0004E4 // int32
    m_soundscapeEntityListId = 0X0004E8 // int32
    m_soundEventHash = 0X0004EC // uint32
    m_positionNames = 0X0004F0 // CUtlSymbolLarge[8]
    m_hProxySoundscape = 0X000530 // CHandle< CEnvSoundscape >
    m_bDisabled = 0X000534 // bool

 CEnvSoundscapeProxy: [server.dll]
    m_MainSoundscapeName = 0X000538 // CUtlSymbolLarge

 CEnvSoundscapeTriggerable: [server.dll]
    No schemes available

 CTriggerCamera: [server.dll]
    m_hPlayer = 0X0004A0 // CHandle< CBaseEntity >
    m_hTarget = 0X0004A4 // CHandle< CBaseEntity >
    m_pPath = 0X0004A8 // CBaseEntity*
    m_sPath = 0X0004B0 // CUtlSymbolLarge
    m_flWait = 0X0004B8 // float32
    m_flReturnTime = 0X0004BC // GameTime_t
    m_flStopTime = 0X0004C0 // GameTime_t
    m_moveDistance = 0X0004C4 // float32
    m_targetSpeed = 0X0004C8 // float32
    m_initialSpeed = 0X0004CC // float32
    m_acceleration = 0X0004D0 // float32
    m_deceleration = 0X0004D4 // float32
    m_state = 0X0004D8 // int32
    m_vecMoveDir = 0X0004DC // Vector
    m_fov = 0X0004E8 // float32
    m_fovSpeed = 0X0004EC // float32
    m_iszTargetAttachment = 0X0004F0 // CUtlSymbolLarge
    m_iAttachmentIndex = 0X0004F8 // AttachmentHandle_t
    m_bSnapToGoal = 0X0004F9 // bool
    m_bInterpolatePosition = 0X0004FA // bool
    m_vStartPos = 0X0004FC // Vector
    m_vEndPos = 0X000508 // Vector
    m_flInterpStartTime = 0X000514 // GameTime_t
    m_nPlayerButtons = 0X000518 // uint64
    m_bOldTakesDamage = 0X000520 // bool
    m_nOldTakeDamageFlags = 0X000524 // TakeDamageFlags_t
    m_OnEndFollow = 0X000528 // CEntityIOOutput

 lerpdata_t: [server.dll]
    m_hEnt = 0X000000 // CHandle< CBaseEntity >
    m_MoveType = 0X000004 // MoveType_t
    m_flStartTime = 0X000008 // GameTime_t
    m_vecStartOrigin = 0X00000C // Vector
    m_qStartRot = 0X000020 // Quaternion
    m_nFXIndex = 0X000030 // ParticleIndex_t

 CNavLinkAnimgraphVar: [server.dll]
    m_strAnimgraphVar = 0X000000 // CUtlString
    m_unAlignmentDegrees = 0X000008 // uint32

 CNavLinkMovementVData: [server.dll]
    m_bIsInterpolated = 0X000000 // bool
    m_unRecommendedDistance = 0X000004 // uint32
    m_vecAnimgraphVars = 0X000008 // CUtlVector< CNavLinkAnimgraphVar >

 CNavVolumeMarkupVolume: [server.dll]
    No schemes available

 CNavVolumeCalculatedVector: [server.dll]
    No schemes available

 CNavVolumeBreadthFirstSearch: [server.dll]
    m_vStartPos = 0X0000A0 // Vector
    m_flSearchDist = 0X0000AC // float32

 VPhysicsCollisionAttribute_t: [server.dll]
    m_nInteractsAs = 0X000008 // uint64
    m_nInteractsWith = 0X000010 // uint64
    m_nInteractsExclude = 0X000018 // uint64
    m_nEntityId = 0X000020 // uint32
    m_nOwnerId = 0X000024 // uint32
    m_nHierarchyId = 0X000028 // uint16
    m_nCollisionGroup = 0X00002A // uint8
    m_nCollisionFunctionMask = 0X00002B // uint8

 CCollisionProperty: [server.dll]
    m_collisionAttribute = 0X000010 // VPhysicsCollisionAttribute_t
    m_vecMins = 0X000040 // Vector
    m_vecMaxs = 0X00004C // Vector
    m_usSolidFlags = 0X00005A // uint8
    m_nSolidType = 0X00005B // SolidType_t
    m_triggerBloat = 0X00005C // uint8
    m_nSurroundType = 0X00005D // SurroundingBoundsType_t
    m_CollisionGroup = 0X00005E // uint8
    m_nEnablePhysics = 0X00005F // uint8
    m_flBoundingRadius = 0X000060 // float32
    m_vecSpecifiedSurroundingMins = 0X000064 // Vector
    m_vecSpecifiedSurroundingMaxs = 0X000070 // Vector
    m_vecSurroundingMaxs = 0X00007C // Vector
    m_vecSurroundingMins = 0X000088 // Vector
    m_vCapsuleCenter1 = 0X000094 // Vector
    m_vCapsuleCenter2 = 0X0000A0 // Vector
    m_flCapsuleRadius = 0X0000AC // float32

 CEffectData: [server.dll]
    m_vOrigin = 0X000008 // Vector
    m_vStart = 0X000014 // Vector
    m_vNormal = 0X000020 // Vector
    m_vAngles = 0X00002C // QAngle
    m_hEntity = 0X000038 // CEntityHandle
    m_hOtherEntity = 0X00003C // CEntityHandle
    m_flScale = 0X000040 // float32
    m_flMagnitude = 0X000044 // float32
    m_flRadius = 0X000048 // float32
    m_nSurfaceProp = 0X00004C // CUtlStringToken
    m_nEffectIndex = 0X000050 // CWeakHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_nDamageType = 0X000058 // uint32
    m_nPenetrate = 0X00005C // uint8
    m_nMaterial = 0X00005E // uint16
    m_nHitBox = 0X000060 // uint16
    m_nColor = 0X000062 // uint8
    m_fFlags = 0X000063 // uint8
    m_nAttachmentIndex = 0X000064 // AttachmentHandle_t
    m_nAttachmentName = 0X000068 // CUtlStringToken
    m_iEffectName = 0X00006C // uint16
    m_nExplosionType = 0X00006E // uint8

 CEnvDetailController: [server.dll]
    m_flFadeStartDist = 0X0004A0 // float32
    m_flFadeEndDist = 0X0004A4 // float32

 CEnvWindShared: [server.dll]
    m_flStartTime = 0X000008 // GameTime_t
    m_iWindSeed = 0X00000C // uint32
    m_iMinWind = 0X000010 // uint16
    m_iMaxWind = 0X000012 // uint16
    m_windRadius = 0X000014 // int32
    m_iMinGust = 0X000018 // uint16
    m_iMaxGust = 0X00001A // uint16
    m_flMinGustDelay = 0X00001C // float32
    m_flMaxGustDelay = 0X000020 // float32
    m_flGustDuration = 0X000024 // float32
    m_iGustDirChange = 0X000028 // uint16
    m_location = 0X00002C // Vector
    m_iszGustSound = 0X000038 // int32
    m_iWindDir = 0X00003C // int32
    m_flWindSpeed = 0X000040 // float32
    m_currentWindVector = 0X000044 // Vector
    m_CurrentSwayVector = 0X000050 // Vector
    m_PrevSwayVector = 0X00005C // Vector
    m_iInitialWindDir = 0X000068 // uint16
    m_flInitialWindSpeed = 0X00006C // float32
    m_OnGustStart = 0X000070 // CEntityIOOutput
    m_OnGustEnd = 0X000098 // CEntityIOOutput
    m_flVariationTime = 0X0000C0 // GameTime_t
    m_flSwayTime = 0X0000C4 // GameTime_t
    m_flSimTime = 0X0000C8 // GameTime_t
    m_flSwitchTime = 0X0000CC // GameTime_t
    m_flAveWindSpeed = 0X0000D0 // float32
    m_bGusting = 0X0000D4 // bool
    m_flWindAngleVariation = 0X0000D8 // float32
    m_flWindSpeedVariation = 0X0000DC // float32
    m_iEntIndex = 0X0000E0 // CEntityIndex

 CEnvWindShared::WindAveEvent_t: [server.dll]
    m_flStartWindSpeed = 0X000000 // float32
    m_flAveWindSpeed = 0X000004 // float32

 CEnvWindShared::WindVariationEvent_t: [server.dll]
    m_flWindAngleVariation = 0X000000 // float32
    m_flWindSpeedVariation = 0X000004 // float32

 CInfoLadderDismount: [server.dll]
    No schemes available

 shard_model_desc_t: [server.dll]
    m_nModelID = 0X000008 // int32
    m_hMaterial = 0X000010 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_solid = 0X000018 // ShardSolid_t
    m_ShatterPanelMode = 0X000019 // ShatterPanelMode
    m_vecPanelSize = 0X00001C // Vector2D
    m_vecStressPositionA = 0X000024 // Vector2D
    m_vecStressPositionB = 0X00002C // Vector2D
    m_vecPanelVertices = 0X000038 // CNetworkUtlVectorBase< Vector2D >
    m_flGlassHalfThickness = 0X000050 // float32
    m_bHasParent = 0X000054 // bool
    m_bParentFrozen = 0X000055 // bool
    m_SurfacePropStringToken = 0X000058 // CUtlStringToken
    m_LightGroup = 0X00005C // CUtlStringToken

 CShatterGlassShard: [server.dll]
    m_hShardHandle = 0X000008 // uint32
    m_vecPanelVertices = 0X000010 // CUtlVector< Vector2D >
    m_vLocalPanelSpaceOrigin = 0X000028 // Vector2D
    m_hModel = 0X000030 // CStrongHandle< InfoForResourceTypeCModel >
    m_hPhysicsEntity = 0X000038 // CHandle< CShatterGlassShardPhysics >
    m_hParentPanel = 0X00003C // CHandle< CFuncShatterglass >
    m_hParentShard = 0X000040 // uint32
    m_ShatterStressType = 0X000044 // ShatterGlassStressType
    m_vecStressVelocity = 0X000048 // Vector
    m_bCreatedModel = 0X000054 // bool
    m_flLongestEdge = 0X000058 // float32
    m_flShortestEdge = 0X00005C // float32
    m_flLongestAcross = 0X000060 // float32
    m_flShortestAcross = 0X000064 // float32
    m_flSumOfAllEdges = 0X000068 // float32
    m_flArea = 0X00006C // float32
    m_nOnFrameEdge = 0X000070 // OnFrame
    m_nParentPanelsNthShard = 0X000074 // int32
    m_nSubShardGeneration = 0X000078 // int32
    m_vecAverageVertPosition = 0X00007C // Vector2D
    m_bAverageVertPositionIsValid = 0X000084 // bool
    m_vecPanelSpaceStressPositionA = 0X000088 // Vector2D
    m_vecPanelSpaceStressPositionB = 0X000090 // Vector2D
    m_bStressPositionAIsValid = 0X000098 // bool
    m_bStressPositionBIsValid = 0X000099 // bool
    m_bFlaggedForRemoval = 0X00009A // bool
    m_flPhysicsEntitySpawnedAtTime = 0X00009C // GameTime_t
    m_bShatterRateLimited = 0X0000A0 // bool
    m_hEntityHittingMe = 0X0000A4 // CHandle< CBaseEntity >
    m_vecNeighbors = 0X0000A8 // CUtlVector< uint32 >

 CGameRulesProxy: [server.dll]
    No schemes available

 CGameRules: [server.dll]
    m_szQuestName = 0X000008 // char[128]
    m_nQuestPhase = 0X000088 // int32

 CGlowProperty: [server.dll]
    m_fGlowColor = 0X000008 // Vector
    m_iGlowType = 0X000030 // int32
    m_iGlowTeam = 0X000034 // int32
    m_nGlowRange = 0X000038 // int32
    m_nGlowRangeMin = 0X00003C // int32
    m_glowColorOverride = 0X000040 // Color
    m_bFlashing = 0X000044 // bool
    m_flGlowTime = 0X000048 // float32
    m_flGlowStartTime = 0X00004C // float32
    m_bEligibleForScreenHighlight = 0X000050 // bool
    m_bGlowing = 0X000051 // bool

 IVehicle: [server.dll]
    No schemes available

 CMultiplayRules: [server.dll]
    No schemes available

 fogparams_t: [server.dll]
    dirPrimary = 0X000008 // Vector
    colorPrimary = 0X000014 // Color
    colorSecondary = 0X000018 // Color
    colorPrimaryLerpTo = 0X00001C // Color
    colorSecondaryLerpTo = 0X000020 // Color
    start = 0X000024 // float32
    end = 0X000028 // float32
    farz = 0X00002C // float32
    maxdensity = 0X000030 // float32
    exponent = 0X000034 // float32
    HDRColorScale = 0X000038 // float32
    skyboxFogFactor = 0X00003C // float32
    skyboxFogFactorLerpTo = 0X000040 // float32
    startLerpTo = 0X000044 // float32
    endLerpTo = 0X000048 // float32
    maxdensityLerpTo = 0X00004C // float32
    lerptime = 0X000050 // GameTime_t
    duration = 0X000054 // float32
    blendtobackground = 0X000058 // float32
    scattering = 0X00005C // float32
    locallightscale = 0X000060 // float32
    enable = 0X000064 // bool
    blend = 0X000065 // bool
    m_bNoReflectionFog = 0X000066 // bool
    m_bPadding = 0X000067 // bool

 fogplayerparams_t: [server.dll]
    m_hCtrl = 0X000008 // CHandle< CFogController >
    m_flTransitionTime = 0X00000C // float32
    m_OldColor = 0X000010 // Color
    m_flOldStart = 0X000014 // float32
    m_flOldEnd = 0X000018 // float32
    m_flOldMaxDensity = 0X00001C // float32
    m_flOldHDRColorScale = 0X000020 // float32
    m_flOldFarZ = 0X000024 // float32
    m_NewColor = 0X000028 // Color
    m_flNewStart = 0X00002C // float32
    m_flNewEnd = 0X000030 // float32
    m_flNewMaxDensity = 0X000034 // float32
    m_flNewHDRColorScale = 0X000038 // float32
    m_flNewFarZ = 0X00003C // float32

 sky3dparams_t: [server.dll]
    scale = 0X000008 // int16
    origin = 0X00000C // Vector
    bClip3DSkyBoxNearToWorldFar = 0X000018 // bool
    flClip3DSkyBoxNearToWorldFarOffset = 0X00001C // float32
    fog = 0X000020 // fogparams_t
    m_nWorldGroupID = 0X000088 // WorldGroupId_t

 IRagdoll: [server.dll]
    No schemes available

 ragdollelement_t: [server.dll]
    originParentSpace = 0X000000 // Vector
    parentIndex = 0X000020 // int32
    m_flRadius = 0X000024 // float32

 ragdoll_t: [server.dll]
    list = 0X000000 // CUtlVector< ragdollelement_t >
    boneIndex = 0X000018 // CUtlVector< int32 >
    allowStretch = 0X000030 // bool
    unused = 0X000031 // bool

 PhysicsRagdollPose_t: [server.dll]
    __m_pChainEntity = 0X000008 // CNetworkVarChainer
    m_Transforms = 0X000030 // CNetworkUtlVectorBase< CTransform >

 CSceneEventInfo: [server.dll]
    m_iLayer = 0X000000 // int32
    m_iPriority = 0X000004 // int32
    m_hSequence = 0X000008 // HSequence
    m_flWeight = 0X00000C // float32
    m_bIsMoving = 0X000010 // bool
    m_bHasArrived = 0X000011 // bool
    m_flInitialYaw = 0X000014 // float32
    m_flTargetYaw = 0X000018 // float32
    m_flFacingYaw = 0X00001C // float32
    m_nType = 0X000020 // int32
    m_flNext = 0X000024 // GameTime_t
    m_bIsGesture = 0X000028 // bool
    m_bShouldRemove = 0X000029 // bool
    m_hTarget = 0X000054 // CHandle< CBaseEntity >
    m_nSceneEventId = 0X000058 // uint32
    m_bClientSide = 0X00005C // bool
    m_bStarted = 0X00005D // bool

 ParticleIndex_t: [server.dll]
    m_Value = 0X000000 // int32

 AmmoIndex_t: [server.dll]
    m_Value = 0X000000 // int8

 CEntitySubclassVDataBase: [server.dll]
    No schemes available

 thinkfunc_t: [server.dll]
    m_hFn = 0X000008 // HSCRIPT
    m_nContext = 0X000010 // CUtlStringToken
    m_nNextThinkTick = 0X000014 // GameTick_t
    m_nLastThinkTick = 0X000018 // GameTick_t

 RagdollCreationParams_t: [server.dll]
    m_vForce = 0X000000 // Vector
    m_nForceBone = 0X00000C // int32

 hudtextparms_t: [server.dll]
    color1 = 0X000000 // Color
    color2 = 0X000004 // Color
    effect = 0X000008 // uint8
    channel = 0X000009 // uint8
    x = 0X00000C // float32
    y = 0X000010 // float32

 CSimpleSimTimer: [server.dll]
    m_next = 0X000000 // GameTime_t
    m_nWorldGroupId = 0X000004 // WorldGroupId_t

 CSimTimer: [server.dll]
    m_interval = 0X000008 // float32

 CRandSimTimer: [server.dll]
    m_minInterval = 0X000008 // float32
    m_maxInterval = 0X00000C // float32

 CStopwatchBase: [server.dll]
    m_fIsRunning = 0X000008 // bool

 CSimpleStopwatch: [server.dll]
    No schemes available

 CStopwatch: [server.dll]
    m_interval = 0X00000C // float32

 CRandStopwatch: [server.dll]
    m_minInterval = 0X00000C // float32
    m_maxInterval = 0X000010 // float32

 CSingleplayRules: [server.dll]
    m_bSinglePlayerGameEnding = 0X000090 // bool

 CSoundOpvarSetPointBase: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_hSource = 0X0004A4 // CEntityHandle
    m_iszSourceEntityName = 0X0004B0 // CUtlSymbolLarge
    m_vLastPosition = 0X000508 // Vector
    m_iszStackName = 0X000518 // CUtlSymbolLarge
    m_iszOperatorName = 0X000520 // CUtlSymbolLarge
    m_iszOpvarName = 0X000528 // CUtlSymbolLarge
    m_iOpvarIndex = 0X000530 // int32
    m_bUseAutoCompare = 0X000534 // bool

 CSoundOpvarSetPointEntity: [server.dll]
    m_OnEnter = 0X000538 // CEntityIOOutput
    m_OnExit = 0X000560 // CEntityIOOutput
    m_bAutoDisable = 0X000588 // bool
    m_flDistanceMin = 0X0005CC // float32
    m_flDistanceMax = 0X0005D0 // float32
    m_flDistanceMapMin = 0X0005D4 // float32
    m_flDistanceMapMax = 0X0005D8 // float32
    m_flOcclusionRadius = 0X0005DC // float32
    m_flOcclusionMin = 0X0005E0 // float32
    m_flOcclusionMax = 0X0005E4 // float32
    m_flValSetOnDisable = 0X0005E8 // float32
    m_bSetValueOnDisable = 0X0005EC // bool
    m_nSimulationMode = 0X0005F0 // int32
    m_nVisibilitySamples = 0X0005F4 // int32
    m_vDynamicProxyPoint = 0X0005F8 // Vector
    m_flDynamicMaximumOcclusion = 0X000604 // float32
    m_hDynamicEntity = 0X000608 // CEntityHandle
    m_iszDynamicEntityName = 0X000610 // CUtlSymbolLarge
    m_flPathingDistanceNormFactor = 0X000618 // float32
    m_vPathingSourcePos = 0X00061C // Vector
    m_vPathingListenerPos = 0X000628 // Vector

 CSoundOpvarSetAABBEntity: [server.dll]
    m_vDistanceInnerMins = 0X000638 // Vector
    m_vDistanceInnerMaxs = 0X000644 // Vector
    m_vDistanceOuterMins = 0X000650 // Vector
    m_vDistanceOuterMaxs = 0X00065C // Vector
    m_nAABBDirection = 0X000668 // int32
    m_vInnerMins = 0X00066C // Vector
    m_vInnerMaxs = 0X000678 // Vector
    m_vOuterMins = 0X000684 // Vector
    m_vOuterMaxs = 0X000690 // Vector

 CSoundOpvarSetOBBEntity: [server.dll]
    No schemes available

 CSoundOpvarSetPathCornerEntity: [server.dll]
    m_flDistMinSqr = 0X000650 // float32
    m_flDistMaxSqr = 0X000654 // float32
    m_iszPathCornerEntityName = 0X000658 // CUtlSymbolLarge

 CSoundOpvarSetOBBWindEntity: [server.dll]
    m_vMins = 0X000538 // Vector
    m_vMaxs = 0X000544 // Vector
    m_vDistanceMins = 0X000550 // Vector
    m_vDistanceMaxs = 0X00055C // Vector
    m_flWindMin = 0X000568 // float32
    m_flWindMax = 0X00056C // float32
    m_flWindMapMin = 0X000570 // float32
    m_flWindMapMax = 0X000574 // float32

 CTakeDamageInfo: [server.dll]
    m_vecDamageForce = 0X000008 // Vector
    m_vecDamagePosition = 0X000014 // Vector
    m_vecReportedPosition = 0X000020 // Vector
    m_vecDamageDirection = 0X00002C // Vector
    m_hInflictor = 0X000038 // CHandle< CBaseEntity >
    m_hAttacker = 0X00003C // CHandle< CBaseEntity >
    m_hAbility = 0X000040 // CHandle< CBaseEntity >
    m_flDamage = 0X000044 // float32
    m_bitsDamageType = 0X000048 // int32
    m_iDamageCustom = 0X00004C // int32
    m_iAmmoType = 0X000050 // AmmoIndex_t
    m_flOriginalDamage = 0X000060 // float32
    m_nDamageFlags = 0X000070 // TakeDamageFlags_t
    m_nNumObjectsPenetrated = 0X000074 // int32
    m_hScriptInstance = 0X000078 // HSCRIPT
    m_bInTakeDamageFlow = 0X000098 // bool

 CTakeDamageResult: [server.dll]
    m_nHealthLost = 0X000000 // int32
    m_nDamageTaken = 0X000004 // int32

 SummaryTakeDamageInfo_t: [server.dll]
    nSummarisedCount = 0X000000 // int32
    info = 0X000008 // CTakeDamageInfo
    result = 0X0000A8 // CTakeDamageResult
    hTarget = 0X0000B0 // CHandle< CBaseEntity >

 CTakeDamageSummaryScopeGuard: [server.dll]
    m_vecSummaries = 0X000008 // CUtlVector< SummaryTakeDamageInfo_t* >

 CTeamplayRules: [server.dll]
    No schemes available

 CAttributeList: [server.dll]
    m_Attributes = 0X000008 // CUtlVectorEmbeddedNetworkVar< CEconItemAttribute >
    m_pManager = 0X000058 // CAttributeManager*

 CEconItemAttribute: [server.dll]
    m_iAttributeDefinitionIndex = 0X000030 // uint16
    m_flValue = 0X000034 // float32
    m_flInitialValue = 0X000038 // float32
    m_nRefundableCurrency = 0X00003C // int32
    m_bSetBonus = 0X000040 // bool

 IEconItemInterface: [server.dll]
    No schemes available

 CAttributeManager: [server.dll]
    m_Providers = 0X000008 // CUtlVector< CHandle< CBaseEntity > >
    m_iReapplyProvisionParity = 0X000020 // int32
    m_hOuter = 0X000024 // CHandle< CBaseEntity >
    m_bPreventLoopback = 0X000028 // bool
    m_ProviderType = 0X00002C // attributeprovidertypes_t
    m_CachedResults = 0X000030 // CUtlVector< CAttributeManager::cached_attribute_float_t >

 CAttributeManager::cached_attribute_float_t: [server.dll]
    flIn = 0X000000 // float32
    iAttribHook = 0X000008 // CUtlSymbolLarge
    flOut = 0X000010 // float32

 CAttributeContainer: [server.dll]
    m_Item = 0X000050 // CEconItemView

 IHasAttributes: [server.dll]
    No schemes available

 GameAmmoTypeInfo_t: [server.dll]
    m_nBuySize = 0X000038 // int32
    m_nCost = 0X00003C // int32

 EntitySpottedState_t: [server.dll]
    m_bSpotted = 0X000008 // bool
    m_bSpottedByMask = 0X00000C // uint32[2]

 SpawnPoint: [server.dll]
    m_iPriority = 0X0004A0 // int32
    m_bEnabled = 0X0004A4 // bool
    m_nType = 0X0004A8 // int32

 SpawnPointCoopEnemy: [server.dll]
    m_szWeaponsToGive = 0X0004B0 // CUtlSymbolLarge
    m_szPlayerModelToUse = 0X0004B8 // CUtlSymbolLarge
    m_nArmorToSpawnWith = 0X0004C0 // int32
    m_nDefaultBehavior = 0X0004C4 // SpawnPointCoopEnemy::BotDefaultBehavior_t
    m_nBotDifficulty = 0X0004C8 // int32
    m_bIsAgressive = 0X0004CC // bool
    m_bStartAsleep = 0X0004CD // bool
    m_flHideRadius = 0X0004D0 // float32
    m_szBehaviorTreeFile = 0X0004E0 // CUtlSymbolLarge

 CCSGameRulesProxy: [server.dll]
    m_pGameRules = 0X0004A0 // CCSGameRules*

 CCSGameRules: [server.dll]
    __m_pChainEntity = 0X000098 // CNetworkVarChainer
    m_coopMissionManager = 0X0000C0 // CHandle< CBaseEntity >
    m_bFreezePeriod = 0X0000C4 // bool
    m_bWarmupPeriod = 0X0000C5 // bool
    m_fWarmupPeriodEnd = 0X0000C8 // GameTime_t
    m_fWarmupPeriodStart = 0X0000CC // GameTime_t
    m_bTerroristTimeOutActive = 0X0000D0 // bool
    m_bCTTimeOutActive = 0X0000D1 // bool
    m_flTerroristTimeOutRemaining = 0X0000D4 // float32
    m_flCTTimeOutRemaining = 0X0000D8 // float32
    m_nTerroristTimeOuts = 0X0000DC // int32
    m_nCTTimeOuts = 0X0000E0 // int32
    m_bTechnicalTimeOut = 0X0000E4 // bool
    m_bMatchWaitingForResume = 0X0000E5 // bool
    m_iRoundTime = 0X0000E8 // int32
    m_fMatchStartTime = 0X0000EC // float32
    m_fRoundStartTime = 0X0000F0 // GameTime_t
    m_flRestartRoundTime = 0X0000F4 // GameTime_t
    m_bGameRestart = 0X0000F8 // bool
    m_flGameStartTime = 0X0000FC // float32
    m_timeUntilNextPhaseStarts = 0X000100 // float32
    m_gamePhase = 0X000104 // int32
    m_totalRoundsPlayed = 0X000108 // int32
    m_nRoundsPlayedThisPhase = 0X00010C // int32
    m_nOvertimePlaying = 0X000110 // int32
    m_iHostagesRemaining = 0X000114 // int32
    m_bAnyHostageReached = 0X000118 // bool
    m_bMapHasBombTarget = 0X000119 // bool
    m_bMapHasRescueZone = 0X00011A // bool
    m_bMapHasBuyZone = 0X00011B // bool
    m_bIsQueuedMatchmaking = 0X00011C // bool
    m_nQueuedMatchmakingMode = 0X000120 // int32
    m_bIsValveDS = 0X000124 // bool
    m_bLogoMap = 0X000125 // bool
    m_bPlayAllStepSoundsOnServer = 0X000126 // bool
    m_iNumGunGameProgressiveWeaponsCT = 0X000128 // int32
    m_iNumGunGameProgressiveWeaponsT = 0X00012C // int32
    m_iSpectatorSlotCount = 0X000130 // int32
    m_GGProgressiveWeaponOrderCT = 0X000134 // int32[60]
    m_GGProgressiveWeaponOrderT = 0X000224 // int32[60]
    m_GGProgressiveWeaponKillUpgradeOrderCT = 0X000314 // int32[60]
    m_GGProgressiveWeaponKillUpgradeOrderT = 0X000404 // int32[60]
    m_MatchDevice = 0X0004F4 // int32
    m_bHasMatchStarted = 0X0004F8 // bool
    m_flDMBonusStartTime = 0X0004FC // float32
    m_flDMBonusTimeLength = 0X000500 // float32
    m_unDMBonusWeaponLoadoutSlot = 0X000504 // uint16
    m_bDMBonusActive = 0X000506 // bool
    m_nNextMapInMapgroup = 0X000508 // int32
    m_szTournamentEventName = 0X00050C // char[512]
    m_szTournamentEventStage = 0X00070C // char[512]
    m_szMatchStatTxt = 0X00090C // char[512]
    m_szTournamentPredictionsTxt = 0X000B0C // char[512]
    m_nTournamentPredictionsPct = 0X000D0C // int32
    m_flCMMItemDropRevealStartTime = 0X000D10 // GameTime_t
    m_flCMMItemDropRevealEndTime = 0X000D14 // GameTime_t
    m_bIsDroppingItems = 0X000D18 // bool
    m_bIsQuestEligible = 0X000D19 // bool
    m_nGuardianModeWaveNumber = 0X000D1C // int32
    m_nGuardianModeSpecialKillsRemaining = 0X000D20 // int32
    m_nGuardianModeSpecialWeaponNeeded = 0X000D24 // int32
    m_nGuardianGrenadesToGiveBots = 0X000D28 // int32
    m_nNumHeaviesToSpawn = 0X000D2C // int32
    m_numGlobalGiftsGiven = 0X000D30 // uint32
    m_numGlobalGifters = 0X000D34 // uint32
    m_numGlobalGiftsPeriodSeconds = 0X000D38 // uint32
    m_arrFeaturedGiftersAccounts = 0X000D3C // uint32[4]
    m_arrFeaturedGiftersGifts = 0X000D4C // uint32[4]
    m_arrProhibitedItemIndices = 0X000D5C // uint16[100]
    m_arrTournamentActiveCasterAccounts = 0X000E24 // uint32[4]
    m_numBestOfMaps = 0X000E34 // int32
    m_nHalloweenMaskListSeed = 0X000E38 // int32
    m_bBombDropped = 0X000E3C // bool
    m_bBombPlanted = 0X000E3D // bool
    m_iRoundWinStatus = 0X000E40 // int32
    m_eRoundWinReason = 0X000E44 // int32
    m_bTCantBuy = 0X000E48 // bool
    m_bCTCantBuy = 0X000E49 // bool
    m_flGuardianBuyUntilTime = 0X000E4C // GameTime_t
    m_iMatchStats_RoundResults = 0X000E50 // int32[30]
    m_iMatchStats_PlayersAlive_CT = 0X000EC8 // int32[30]
    m_iMatchStats_PlayersAlive_T = 0X000F40 // int32[30]
    m_TeamRespawnWaveTimes = 0X000FB8 // float32[32]
    m_flNextRespawnWave = 0X001038 // GameTime_t[32]
    m_nServerQuestID = 0X0010B8 // int32
    m_bDontIncrementCoopWave = 0X0010BC // bool
    m_bSpawnedTerrorHuntHeavy = 0X0010BD // bool
    m_nEndMatchMapGroupVoteTypes = 0X0010C0 // int32[10]
    m_nEndMatchMapGroupVoteOptions = 0X0010E8 // int32[10]
    m_nEndMatchMapVoteWinner = 0X001110 // int32
    m_iNumConsecutiveCTLoses = 0X001114 // int32
    m_iNumConsecutiveTerroristLoses = 0X001118 // int32
    m_bHasHostageBeenTouched = 0X001138 // bool
    m_flIntermissionStartTime = 0X00113C // GameTime_t
    m_flIntermissionEndTime = 0X001140 // GameTime_t
    m_bLevelInitialized = 0X001144 // bool
    m_iTotalRoundsPlayed = 0X001148 // int32
    m_iUnBalancedRounds = 0X00114C // int32
    m_endMatchOnRoundReset = 0X001150 // bool
    m_endMatchOnThink = 0X001151 // bool
    m_iFreezeTime = 0X001154 // int32
    m_iNumTerrorist = 0X001158 // int32
    m_iNumCT = 0X00115C // int32
    m_iNumSpawnableTerrorist = 0X001160 // int32
    m_iNumSpawnableCT = 0X001164 // int32
    m_arrSelectedHostageSpawnIndices = 0X001168 // CUtlVector< int32 >
    m_bFirstConnected = 0X001180 // bool
    m_bCompleteReset = 0X001181 // bool
    m_bPickNewTeamsOnReset = 0X001182 // bool
    m_bScrambleTeamsOnRestart = 0X001183 // bool
    m_bSwapTeamsOnRestart = 0X001184 // bool
    m_nEndMatchTiedVotes = 0X001190 // CUtlVector< int32 >
    m_bNeedToAskPlayersForContinueVote = 0X0011AC // bool
    m_numQueuedMatchmakingAccounts = 0X0011B0 // uint32
    m_pQueuedMatchmakingReservationString = 0X0011B8 // char*
    m_numTotalTournamentDrops = 0X0011C0 // uint32
    m_numSpectatorsCountMax = 0X0011C4 // uint32
    m_numSpectatorsCountMaxTV = 0X0011C8 // uint32
    m_numSpectatorsCountMaxLnk = 0X0011CC // uint32
    m_bForceTeamChangeSilent = 0X0011D8 // bool
    m_bLoadingRoundBackupData = 0X0011D9 // bool
    m_nMatchInfoShowType = 0X001210 // int32
    m_flMatchInfoDecidedTime = 0X001214 // float32
    m_flCoopRespawnAndHealTime = 0X001230 // float32
    m_coopBonusCoinsFound = 0X001234 // int32
    m_coopBonusPistolsOnly = 0X001238 // bool
    m_coopPlayersInDeploymentZone = 0X001239 // bool
    m_coopMissionDeadPlayerRespawnEnabled = 0X00123A // bool
    mTeamDMLastWinningTeamNumber = 0X00123C // int32
    mTeamDMLastThinkTime = 0X001240 // float32
    m_flTeamDMLastAnnouncementTime = 0X001244 // float32
    m_iAccountTerrorist = 0X001248 // int32
    m_iAccountCT = 0X00124C // int32
    m_iSpawnPointCount_Terrorist = 0X001250 // int32
    m_iSpawnPointCount_CT = 0X001254 // int32
    m_iMaxNumTerrorists = 0X001258 // int32
    m_iMaxNumCTs = 0X00125C // int32
    m_iLoserBonus = 0X001260 // int32
    m_iLoserBonusMostRecentTeam = 0X001264 // int32
    m_tmNextPeriodicThink = 0X001268 // float32
    m_bVoiceWonMatchBragFired = 0X00126C // bool
    m_fWarmupNextChatNoticeTime = 0X001270 // float32
    m_iHostagesRescued = 0X001278 // int32
    m_iHostagesTouched = 0X00127C // int32
    m_flNextHostageAnnouncement = 0X001280 // float32
    m_bNoTerroristsKilled = 0X001284 // bool
    m_bNoCTsKilled = 0X001285 // bool
    m_bNoEnemiesKilled = 0X001286 // bool
    m_bCanDonateWeapons = 0X001287 // bool
    m_firstKillTime = 0X00128C // float32
    m_firstBloodTime = 0X001294 // float32
    m_hostageWasInjured = 0X0012B0 // bool
    m_hostageWasKilled = 0X0012B1 // bool
    m_bVoteCalled = 0X0012C0 // bool
    m_bServerVoteOnReset = 0X0012C1 // bool
    m_flVoteCheckThrottle = 0X0012C4 // float32
    m_bBuyTimeEnded = 0X0012C8 // bool
    m_nLastFreezeEndBeep = 0X0012CC // int32
    m_iHaveEscaped = 0X0012D0 // int32
    m_bMapHasEscapeZone = 0X0012D4 // bool
    m_iNumEscapers = 0X0012D8 // int32
    m_iNumEscapeRounds = 0X0012DC // int32
    m_bTargetBombed = 0X0012E0 // bool
    m_bBombDefused = 0X0012E1 // bool
    m_bMapHasBombZone = 0X0012E2 // bool
    m_bGunGameRespawnWithBomb = 0X0012E3 // bool
    m_fGunGameBombRespawnTimer = 0X0012E4 // float32
    m_vecMainCTSpawnPos = 0X001304 // Vector
    m_CTSpawnPointsMasterList = 0X001310 // CUtlVector< SpawnPoint* >
    m_TerroristSpawnPointsMasterList = 0X001328 // CUtlVector< SpawnPoint* >
    m_iNextCTSpawnPoint = 0X001340 // int32
    m_iNextTerroristSpawnPoint = 0X001344 // int32
    m_CTSpawnPoints = 0X001348 // CUtlVector< SpawnPoint* >
    m_TerroristSpawnPoints = 0X001360 // CUtlVector< SpawnPoint* >
    m_bIsUnreservedGameServer = 0X001378 // bool
    m_fAutobalanceDisplayTime = 0X00137C // float32
    m_bAllowWeaponSwitch = 0X0015E8 // bool
    m_bRoundTimeWarningTriggered = 0X0015E9 // bool
    m_phaseChangeAnnouncementTime = 0X0015EC // GameTime_t
    m_fNextUpdateTeamClanNamesTime = 0X0015F0 // float32
    m_flLastThinkTime = 0X0015F4 // GameTime_t
    m_fAccumulatedRoundOffDamage = 0X0015F8 // float32
    m_nShorthandedBonusLastEvalRound = 0X0015FC // int32
    m_bHasTriggeredRoundStartMusic = 0X001860 // bool
    m_bHasTriggeredCoopSpawnReset = 0X001861 // bool
    m_bSwitchingTeamsAtRoundReset = 0X001862 // bool
    m_iMaxGunGameProgressiveWeaponIndex = 0X001864 // int32
    m_SurvivalRules = 0X001880 // CSurvivalGameRules
    m_BtGlobalBlackboard = 0X003518 // KeyValues3
    m_hPlayerResource = 0X003580 // CHandle< CBaseEntity >
    m_RetakeRules = 0X003588 // CRetakeGameRules
    m_GuardianBotSkillLevelMax = 0X00376C // int32
    m_GuardianBotSkillLevelMin = 0X003770 // int32
    m_arrTeamUniqueKillWeaponsMatch = 0X003778 // CUtlVector< int32 >[4]
    m_bTeamLastKillUsedUniqueWeaponMatch = 0X0037D8 // bool[4]
    m_nMatchEndCount = 0X003800 // uint8
    m_bTeamIntroPeriod = 0X003801 // bool
    m_fTeamIntroPeriodEnd = 0X003804 // GameTime_t

 CRetakeGameRules: [server.dll]
    m_nMatchSeed = 0X0000F8 // int32
    m_bBlockersPresent = 0X0000FC // bool
    m_bRoundInProgress = 0X0000FD // bool
    m_iFirstSecondHalfRound = 0X000100 // int32
    m_iBombSite = 0X000104 // int32

 QuestProgress: [server.dll]
    No schemes available

 CSPerRoundStats_t: [server.dll]
    m_iKills = 0X000030 // int32
    m_iDeaths = 0X000034 // int32
    m_iAssists = 0X000038 // int32
    m_iDamage = 0X00003C // int32
    m_iEquipmentValue = 0X000040 // int32
    m_iMoneySaved = 0X000044 // int32
    m_iKillReward = 0X000048 // int32
    m_iLiveTime = 0X00004C // int32
    m_iHeadShotKills = 0X000050 // int32
    m_iObjective = 0X000054 // int32
    m_iCashEarned = 0X000058 // int32
    m_iUtilityDamage = 0X00005C // int32
    m_iEnemiesFlashed = 0X000060 // int32

 CSMatchStats_t: [server.dll]
    m_iEnemy5Ks = 0X000068 // int32
    m_iEnemy4Ks = 0X00006C // int32
    m_iEnemy3Ks = 0X000070 // int32
    m_iEnemy2Ks = 0X000074 // int32
    m_iUtility_Count = 0X000078 // int32
    m_iUtility_Successes = 0X00007C // int32
    m_iUtility_Enemies = 0X000080 // int32
    m_iFlash_Count = 0X000084 // int32
    m_iFlash_Successes = 0X000088 // int32
    m_nHealthPointsRemovedTotal = 0X00008C // int32
    m_nHealthPointsDealtTotal = 0X000090 // int32
    m_nShotsFiredTotal = 0X000094 // int32
    m_nShotsOnTargetTotal = 0X000098 // int32
    m_i1v1Count = 0X00009C // int32
    m_i1v1Wins = 0X0000A0 // int32
    m_i1v2Count = 0X0000A4 // int32
    m_i1v2Wins = 0X0000A8 // int32
    m_iEntryCount = 0X0000AC // int32
    m_iEntryWins = 0X0000B0 // int32

 CCSGO_TeamPreviewCharacterPosition: [server.dll]
    m_nOrdinal = 0X0004A0 // int32
    m_sWeaponName = 0X0004A8 // CUtlString
    m_xuid = 0X0004B0 // uint64
    m_weaponItem = 0X0004B8 // CEconItemView

 CCSGO_TeamSelectCharacterPosition: [server.dll]
    No schemes available

 CCSGO_TeamSelectTerroristPosition: [server.dll]
    No schemes available

 CCSGO_TeamSelectCounterTerroristPosition: [server.dll]
    No schemes available

 CCSGO_TeamIntroCharacterPosition: [server.dll]
    No schemes available

 CCSGO_TeamIntroTerroristPosition: [server.dll]
    No schemes available

 CCSGO_TeamIntroCounterTerroristPosition: [server.dll]
    No schemes available

 CCSGOPlayerAnimGraphState: [server.dll]
    No schemes available

 WeaponPurchaseCount_t: [server.dll]
    m_nItemDefIndex = 0X000030 // uint16
    m_nCount = 0X000032 // uint16

 WeaponPurchaseTracker_t: [server.dll]
    m_weaponPurchases = 0X000008 // CUtlVectorEmbeddedNetworkVar< WeaponPurchaseCount_t >

 CCSPlayer_ActionTrackingServices: [server.dll]
    m_lastWeaponBeforeC4AutoSwitch = 0X000230 // CBasePlayerWeapon*
    m_bIsRescuing = 0X000268 // bool
    m_weaponPurchasesThisMatch = 0X000270 // WeaponPurchaseTracker_t
    m_weaponPurchasesThisRound = 0X0002C8 // WeaponPurchaseTracker_t

 CPlayerPing: [server.dll]
    m_hPlayer = 0X0004A8 // CHandle< CBaseEntity >
    m_hPingedEntity = 0X0004AC // CHandle< CBaseEntity >
    m_iType = 0X0004B0 // int32
    m_bUrgent = 0X0004B4 // bool
    m_szPlaceName = 0X0004B5 // char[18]

 CCSPlayer_PingServices: [server.dll]
    m_flPlayerPingTokens = 0X000040 // GameTime_t[5]
    m_hPlayerPing = 0X000054 // CHandle< CBaseEntity >

 CCSPlayerResource: [server.dll]
    m_bHostageAlive = 0X0004A0 // bool[12]
    m_isHostageFollowingSomeone = 0X0004AC // bool[12]
    m_iHostageEntityIDs = 0X0004B8 // CEntityIndex[12]
    m_bombsiteCenterA = 0X0004E8 // Vector
    m_bombsiteCenterB = 0X0004F4 // Vector
    m_hostageRescueX = 0X000500 // int32[4]
    m_hostageRescueY = 0X000510 // int32[4]
    m_hostageRescueZ = 0X000520 // int32[4]
    m_bEndMatchNextMapAllVoted = 0X000530 // bool
    m_foundGoalPositions = 0X000531 // bool

 CCSPlayer_BulletServices: [server.dll]
    m_totalHitsOnServer = 0X000040 // int32

 CCSPlayer_CameraServices: [server.dll]
    m_hTriggerFogList = 0X000188 // CUtlVector< CHandle< CBaseEntity > >
    m_hLastFogTrigger = 0X0001A0 // CHandle< CBaseEntity >

 CCSPlayer_HostageServices: [server.dll]
    m_hCarriedHostage = 0X000040 // CHandle< CBaseEntity >
    m_hCarriedHostageProp = 0X000044 // CHandle< CBaseEntity >

 CCSPlayer_ItemServices: [server.dll]
    m_bHasDefuser = 0X000040 // bool
    m_bHasHelmet = 0X000041 // bool
    m_bHasHeavyArmor = 0X000042 // bool

 CCSPlayer_MovementServices: [server.dll]
    m_flMaxFallVelocity = 0X000208 // float32
    m_vecLadderNormal = 0X00020C // Vector
    m_nLadderSurfacePropIndex = 0X000218 // int32
    m_bAllowAutoMovement = 0X00021C // bool
    m_flDuckAmount = 0X000220 // float32
    m_flDuckSpeed = 0X000224 // float32
    m_bDuckOverride = 0X000228 // bool
    m_flDuckOffset = 0X00022C // float32
    m_nDuckTimeMsecs = 0X000230 // uint32
    m_nDuckJumpTimeMsecs = 0X000234 // uint32
    m_nJumpTimeMsecs = 0X000238 // uint32
    m_flLastDuckTime = 0X00023C // float32
    m_vecLastPositionAtFullCrouchSpeed = 0X000248 // Vector2D
    m_duckUntilOnGround = 0X000250 // bool
    m_bHasWalkMovedSinceLastJump = 0X000251 // bool
    m_bInStuckTest = 0X000252 // bool
    m_CachedGetPointContents = 0X000258 // uint64[64][3]
    m_CachedGetPointContentsPoint = 0X000858 // Vector[64][3]
    m_flStuckCheckTime = 0X001160 // float32[64][2]
    m_nTraceCount = 0X001360 // int32
    m_StuckLast = 0X001364 // int32
    m_bSpeedCropped = 0X001368 // bool
    m_nOldWaterLevel = 0X00136C // int32
    m_flWaterEntryTime = 0X001370 // float32
    m_vecForward = 0X001374 // Vector
    m_vecLeft = 0X001380 // Vector
    m_vecUp = 0X00138C // Vector
    m_vecPreviouslyPredictedOrigin = 0X001398 // Vector
    m_bMadeFootstepNoise = 0X0013A4 // bool
    m_iFootsteps = 0X0013A8 // int32
    m_nRoundFootstepsMade = 0X0013AC // int32
    m_bOldJumpPressed = 0X0013B0 // bool
    m_flJumpUntil = 0X0013B4 // float32
    m_flJumpVel = 0X0013B8 // float32
    m_fStashGrenadeParameterWhen = 0X0013BC // GameTime_t

 CCSPlayer_ObserverServices: [server.dll]
    No schemes available

 CCSPlayer_UseServices: [server.dll]
    m_hLastKnownUseEntity = 0X000040 // CHandle< CBaseEntity >
    m_flLastUseTimeStamp = 0X000044 // GameTime_t
    m_flTimeStartedHoldingUse = 0X000048 // GameTime_t
    m_flTimeLastUsedWindow = 0X00004C // GameTime_t

 CCSPlayer_ViewModelServices: [server.dll]
    m_hViewModel = 0X000040 // CHandle< CBaseViewModel >[3]

 CCSPlayer_WaterServices: [server.dll]
    m_NextDrownDamageTime = 0X000040 // float32
    m_nDrownDmgRate = 0X000044 // int32
    m_AirFinishedTime = 0X000048 // GameTime_t
    m_flWaterJumpTime = 0X00004C // float32
    m_vecWaterJumpVel = 0X000050 // Vector
    m_flSwimSoundTime = 0X00005C // float32

 CCSPlayer_WeaponServices: [server.dll]
    m_flNextAttack = 0X0000B0 // GameTime_t
    m_bIsLookingAtWeapon = 0X0000B4 // bool
    m_bIsHoldingLookAtWeapon = 0X0000B5 // bool
    m_hSavedWeapon = 0X0000B8 // CHandle< CBasePlayerWeapon >
    m_nTimeToMelee = 0X0000BC // int32
    m_nTimeToSecondary = 0X0000C0 // int32
    m_nTimeToPrimary = 0X0000C4 // int32
    m_nTimeToSniperRifle = 0X0000C8 // int32
    m_bIsBeingGivenItem = 0X0000CC // bool
    m_bIsPickingUpItemWithUse = 0X0000CD // bool
    m_bPickedUpWeapon = 0X0000CE // bool

 CSAdditionalPerRoundStats_t: [server.dll]
    m_numChickensKilled = 0X000000 // int32
    m_killsWhileBlind = 0X000004 // int32
    m_bombCarrierkills = 0X000008 // int32
    m_iBurnDamageInflicted = 0X00000C // int32
    m_iDinks = 0X000010 // int32

 CSAdditionalMatchStats_t: [server.dll]
    m_numRoundsSurvived = 0X000014 // int32
    m_maxNumRoundsSurvived = 0X000018 // int32
    m_numRoundsSurvivedTotal = 0X00001C // int32
    m_iRoundsWonWithoutPurchase = 0X000020 // int32
    m_iRoundsWonWithoutPurchaseTotal = 0X000024 // int32
    m_numFirstKills = 0X000028 // int32
    m_numClutchKills = 0X00002C // int32
    m_numPistolKills = 0X000030 // int32
    m_numSniperKills = 0X000034 // int32

 CCSPlayerController_ActionTrackingServices: [server.dll]
    m_perRoundStats = 0X000040 // CUtlVectorEmbeddedNetworkVar< CSPerRoundStats_t >
    m_matchStats = 0X000090 // CSMatchStats_t
    m_iNumRoundKills = 0X000148 // int32
    m_iNumRoundKillsHeadshots = 0X00014C // int32

 CDamageRecord: [server.dll]
    m_PlayerDamager = 0X000028 // CHandle< CCSPlayerPawnBase >
    m_PlayerRecipient = 0X00002C // CHandle< CCSPlayerPawnBase >
    m_hPlayerControllerDamager = 0X000030 // CHandle< CCSPlayerController >
    m_hPlayerControllerRecipient = 0X000034 // CHandle< CCSPlayerController >
    m_szPlayerDamagerName = 0X000038 // CUtlString
    m_szPlayerRecipientName = 0X000040 // CUtlString
    m_DamagerXuid = 0X000048 // uint64
    m_RecipientXuid = 0X000050 // uint64
    m_iDamage = 0X000058 // int32
    m_iActualHealthRemoved = 0X00005C // int32
    m_iNumHits = 0X000060 // int32
    m_iLastBulletUpdate = 0X000064 // int32
    m_bIsOtherEnemy = 0X000068 // bool
    m_killType = 0X000069 // EKillTypes_t

 CCSPlayerController_DamageServices: [server.dll]
    m_nSendUpdate = 0X000040 // int32
    m_DamageList = 0X000048 // CUtlVectorEmbeddedNetworkVar< CDamageRecord >

 CCSPlayerController_InGameMoneyServices: [server.dll]
    m_bReceivesMoneyNextRound = 0X000040 // bool
    m_iAccountMoneyEarnedForNextRound = 0X000044 // int32
    m_iAccount = 0X000048 // int32
    m_iStartAccount = 0X00004C // int32
    m_iTotalCashSpent = 0X000050 // int32
    m_iCashSpentThisRound = 0X000054 // int32

 CCSPlayerController_InventoryServices: [server.dll]
    m_unMusicID = 0X000040 // uint16
    m_rank = 0X000044 // MedalRank_t[6]
    m_nPersonaDataPublicLevel = 0X00005C // int32
    m_nPersonaDataPublicCommendsLeader = 0X000060 // int32
    m_nPersonaDataPublicCommendsTeacher = 0X000064 // int32
    m_nPersonaDataPublicCommendsFriendly = 0X000068 // int32
    m_unEquippedPlayerSprayIDs = 0X000868 // uint32[1]
    m_vecTerroristLoadoutCache = 0X000870 // CUtlVectorEmbeddedNetworkVar< CEconItemView >
    m_vecCounterTerroristLoadoutCache = 0X0008C0 // CUtlVectorEmbeddedNetworkVar< CEconItemView >

 CSurvivalGameRules: [server.dll]
    m_bBoundsInitialized = 0X000008 // bool
    m_vecPlayAreaMins = 0X00000C // Vector
    m_vecPlayAreaMaxs = 0X000018 // Vector
    m_iPlayerSpawnHexIndices = 0X000024 // int32[64]
    m_SpawnTileState = 0X000124 // ESurvivalSpawnTileState[224]
    m_flSpawnSelectionTimeStartCurrentStage = 0X000204 // float32
    m_flSpawnSelectionTimeEndCurrentStage = 0X000208 // float32
    m_flSpawnSelectionTimeEndLastStage = 0X00020C // float32
    m_spawnStage = 0X000210 // SpawnStage_t
    m_flTabletHexOriginX = 0X000214 // float32
    m_flTabletHexOriginY = 0X000218 // float32
    m_flTabletHexSize = 0X00021C // float32
    m_roundData_playerXuids = 0X000220 // uint64[64]
    m_roundData_playerPositions = 0X000420 // int32[64]
    m_roundData_playerTeams = 0X000520 // int32[64]
    m_SurvivalGameRuleDecisionTypes = 0X000620 // ESurvivalGameRuleDecision_t[16]
    m_SurvivalGameRuleDecisionValues = 0X000660 // int32[16]
    m_flSurvivalStartTime = 0X0006A0 // float32
    m_flLastThinkTime = 0X0006A4 // float32
    m_nBlockedTileIndices = 0X0006A8 // bool[224]
    m_vecPlayerSpawnLocations = 0X000790 // CUtlVector< Vector >
    m_bWaitingForMoreThanOnePlayer = 0X0007A8 // bool
    m_bSurvivalEventFired_FadeEveryoneOutFromMapSelection = 0X0007A9 // bool
    m_bSurvivalEventFired_TimeForSmokeBeacons = 0X0007AA // bool
    m_bSurvivalEventFired_FirstParadropIncoming = 0X0007AB // bool
    m_bSurvivalEventFired_WarnedEveryoneAboutRespawnEnding = 0X0007AC // bool
    m_flLastWinConditionDetectedTime = 0X0007B0 // float32
    m_nWinConditionStageProgress = 0X0007B4 // int32
    m_nEntIndexOfRunnerUpPlayer = 0X0007B8 // int32
    m_nEntIndexOfKilledPlayerCheckingWinConditions = 0X0007BC // int32
    m_flTimeOfLastParadrop = 0X0007C0 // float32
    m_bSurvivalEventFired_PlayedWinnerSurrenderAnim = 0X0007F8 // bool
    m_hWinnerPlayer = 0X0007FC // CEntityHandle
    m_vecLoadedOutPlayers = 0X000800 // CUtlVector< CEntityHandle >
    m_vecRespawnedPlayers = 0X000818 // CUtlVector< CEntityHandle >
    m_vecMetalCrates = 0X000830 // CUtlVector< CEntityHandle >
    m_flLastDroneSpawnTime = 0X000848 // float32
    m_hSpawnChopper = 0X000868 // CHandle< CBaseEntity >

 CDangerZoneController: [server.dll]
    m_bDangerZoneControllerEnabled = 0X0004A0 // bool
    m_bMissionControlledExplosions = 0X0004A1 // bool
    m_vecEndGameCircleStart = 0X0004A4 // Vector
    m_vecEndGameCircleEnd = 0X0004B0 // Vector
    m_flStartTime = 0X0004BC // GameTime_t
    m_flFinalExpansionTime = 0X0004C0 // float32
    m_DangerZones = 0X0004C4 // CHandle< CDangerZone >[42]
    m_flWaveEndTimes = 0X00056C // GameTime_t[5]
    m_hTheFinalZone = 0X000580 // CHandle< CDangerZone >
    m_flLastDangerZoneStatusLogged = 0X000584 // float32
    m_flLastDangerZoneDamageTime = 0X000588 // GameTime_t
    m_bFirstBombWarning = 0X00058C // bool
    m_numWaveRewardsGranted = 0X000590 // int32
    m_pGasCanLaunchers = 0X000598 // CUtlVector< CPointEntity* >

 CFiringModeFloat: [server.dll]
    m_flValues = 0X000000 // float32[2]

 CFiringModeInt: [server.dll]
    m_nValues = 0X000000 // int32[2]

 CIronSightController: [server.dll]
    m_bIronSightAvailable = 0X000008 // bool
    m_flIronSightAmount = 0X00000C // float32
    m_flIronSightAmountGained = 0X000010 // float32
    m_flIronSightAmountBiased = 0X000014 // float32

 CPointDZParadropDenialRegion: [server.dll]
    m_flRadius = 0X0004A8 // float32

 CHintMessage: [server.dll]
    m_hintString = 0X000008 // char*
    m_args = 0X000010 // CUtlVector< char* >
    m_duration = 0X000028 // float32

 CHintMessageQueue: [server.dll]
    m_tmMessageEnd = 0X000008 // float32
    m_messages = 0X000010 // CUtlVector< CHintMessage* >
    m_pPlayerController = 0X000028 // CBasePlayerController*

 CCSPlayer_BuyServices: [server.dll]
    m_flNextAutoBuyAmmoTime = 0X000040 // float32

 CCSPlayer_DamageReactServices: [server.dll]
    No schemes available

 CCSPlayer_ParachuteServices: [server.dll]
    No schemes available

 CCSPlayer_RadioServices: [server.dll]
    m_flGotHostageTalkTimer = 0X000040 // GameTime_t
    m_flDefusingTalkTimer = 0X000044 // GameTime_t
    m_flC4PlantTalkTimer = 0X000048 // GameTime_t
    m_flRadioTokenSlots = 0X00004C // float32[3]
    m_bIgnoreRadio = 0X000058 // bool

 CBaseIssue: [server.dll]
    m_szTypeString = 0X000020 // char[64]
    m_szDetailsString = 0X000060 // char[260]
    m_iNumYesVotes = 0X000164 // int32
    m_iNumNoVotes = 0X000168 // int32
    m_iNumPotentialVotes = 0X00016C // int32
    m_pVoteController = 0X000170 // CVoteController*

 CVoteController: [server.dll]
    m_iActiveIssueIndex = 0X0004A0 // int32
    m_iOnlyTeamToVote = 0X0004A4 // int32
    m_nVoteOptionCount = 0X0004A8 // int32[5]
    m_nPotentialVotes = 0X0004BC // int32
    m_bIsYesNoVote = 0X0004C0 // bool
    m_acceptingVotesTimer = 0X0004C8 // CountdownTimer
    m_executeCommandTimer = 0X0004E0 // CountdownTimer
    m_resetVoteTimer = 0X0004F8 // CountdownTimer
    m_arrVotedUsers = 0X000510 // CUtlVector< uint64 >
    m_nVotesCast = 0X000528 // int32[64]
    m_playerHoldingVote = 0X000628 // CPlayerSlot
    m_nHighestCountIndex = 0X00062C // int32
    m_potentialIssues = 0X000630 // CUtlVector< CBaseIssue* >
    m_VoteOptions = 0X000648 // CUtlVector< char* >

 CMapVetoPickController: [server.dll]
    m_bPlayedIntroVcd = 0X0004A0 // bool
    m_bNeedToPlayFiveSecondsRemaining = 0X0004A1 // bool
    m_nDraftType = 0X0004C0 // int32
    m_nTeamWinningCoinToss = 0X0004C4 // int32
    m_nTeamWithFirstChoice = 0X0004C8 // int32[64]
    m_nVoteMapIdsList = 0X0005C8 // int32[7]
    m_nAccountIDs = 0X0005E4 // int32[64]
    m_nMapId0 = 0X0006E4 // int32[64]
    m_nMapId1 = 0X0007E4 // int32[64]
    m_nMapId2 = 0X0008E4 // int32[64]
    m_nMapId3 = 0X0009E4 // int32[64]
    m_nMapId4 = 0X000AE4 // int32[64]
    m_nMapId5 = 0X000BE4 // int32[64]
    m_nStartingSide0 = 0X000CE4 // int32[64]
    m_nCurrentPhase = 0X000DE4 // int32
    m_nPhaseStartTick = 0X000DE8 // int32
    m_nPhaseDurationTicks = 0X000DEC // int32
    m_OnMapVetoed = 0X000DF0 // CEntityOutputTemplate< CUtlSymbolLarge >
    m_OnMapPicked = 0X000E18 // CEntityOutputTemplate< CUtlSymbolLarge >
    m_OnSidesPicked = 0X000E40 // CEntityOutputTemplate< int32 >
    m_OnNewPhaseStarted = 0X000E68 // CEntityOutputTemplate< int32 >
    m_OnLevelTransition = 0X000E90 // CEntityOutputTemplate< int32 >

 CPointDZItemSpawn: [server.dll]
    No schemes available

 CPointDZWeaponSpawn: [server.dll]
    m_nGroupID = 0X0004B0 // int32
    m_flDefaultWeight = 0X0004B4 // float32
    m_flCurrentWeight = 0X0004B8 // float32
    m_hItem = 0X0004BC // CHandle< CBaseEntity >
    m_iszDoorName = 0X0004C0 // CUtlSymbolLarge
    m_hDoor = 0X0004C8 // CHandle< CDZDoor >
    m_nPrice = 0X0004CC // int32

 CPointDZItemSpawnGroup: [server.dll]
    m_flRadius = 0X0004A0 // float32

 CPointDZWeaponSpawnGroup: [server.dll]
    No schemes available

 CPointDZDroneGunSpawn: [server.dll]
    m_bSpawnAutomatically = 0X0004A8 // bool

 CPointDZParachuteSpawn: [server.dll]
    No schemes available

 CLogicEventListener: [server.dll]
    m_iszEventName = 0X0004B0 // CUtlSymbolLarge
    m_bIsEnabled = 0X0004B8 // bool
    m_nTeam = 0X0004BC // int32
    m_bFetchEventData = 0X0004C0 // bool
    m_OnEventFired = 0X0004C8 // CEntityIOOutput

 CBot: [server.dll]
    m_pPlayer = 0X000010 // CCSPlayerPawnBase*
    m_bHasSpawned = 0X000018 // bool
    m_id = 0X00001C // uint32
    m_isRunning = 0X000090 // bool
    m_isCrouching = 0X000091 // bool
    m_forwardSpeed = 0X000094 // float32
    m_leftSpeed = 0X000098 // float32
    m_verticalSpeed = 0X00009C // float32
    m_buttonFlags = 0X0000A0 // uint64
    m_jumpTimestamp = 0X0000A8 // float32
    m_viewForward = 0X0000AC // Vector
    m_postureStackIndex = 0X0000C8 // int32

 CBtNode: [server.dll]
    No schemes available

 CBtNodeDecorator: [server.dll]
    No schemes available

 CBtNodeComposite: [server.dll]
    No schemes available

 CBtActionAim: [server.dll]
    m_szSensorInputKey = 0X000068 // CUtlString
    m_szAimReadyKey = 0X000080 // CUtlString
    m_flZoomCooldownTimestamp = 0X000088 // float32
    m_bDoneAiming = 0X00008C // bool
    m_flLerpStartTime = 0X000090 // float32
    m_flNextLookTargetLerpTime = 0X000094 // float32
    m_flPenaltyReductionRatio = 0X000098 // float32
    m_NextLookTarget = 0X00009C // QAngle
    m_AimTimer = 0X0000A8 // CountdownTimer
    m_SniperHoldTimer = 0X0000C0 // CountdownTimer
    m_FocusIntervalTimer = 0X0000D8 // CountdownTimer
    m_bAcquired = 0X0000F0 // bool

 CBtActionCombatPositioning: [server.dll]
    m_szSensorInputKey = 0X000068 // CUtlString
    m_szIsAttackingKey = 0X000080 // CUtlString
    m_ActionTimer = 0X000088 // CountdownTimer
    m_bCrouching = 0X0000A0 // bool

 CBtActionMoveTo: [server.dll]
    m_szDestinationInputKey = 0X000060 // CUtlString
    m_szHidingSpotInputKey = 0X000068 // CUtlString
    m_szThreatInputKey = 0X000070 // CUtlString
    m_vecDestination = 0X000078 // Vector
    m_bAutoLookAdjust = 0X000084 // bool
    m_bComputePath = 0X000085 // bool
    m_flDamagingAreasPenaltyCost = 0X000088 // float32
    m_CheckApproximateCornersTimer = 0X000090 // CountdownTimer
    m_CheckHighPriorityItem = 0X0000A8 // CountdownTimer
    m_RepathTimer = 0X0000C0 // CountdownTimer
    m_flArrivalEpsilon = 0X0000D8 // float32
    m_flAdditionalArrivalEpsilon2D = 0X0000DC // float32
    m_flHidingSpotCheckDistanceThreshold = 0X0000E0 // float32
    m_flNearestAreaDistanceThreshold = 0X0000E4 // float32

 CBtActionParachutePositioning: [server.dll]
    m_ActionTimer = 0X000058 // CountdownTimer

 CBtNodeCondition: [server.dll]
    m_bNegated = 0X000058 // bool

 CBtNodeConditionInactive: [server.dll]
    m_flRoundStartThresholdSeconds = 0X000078 // float32
    m_flSensorInactivityThresholdSeconds = 0X00007C // float32
    m_SensorInactivityTimer = 0X000080 // CountdownTimer

 CPointEntity: [server.dll]
    No schemes available

 CEnvCombinedLightProbeVolume: [server.dll]
    m_Color = 0X001570 // Color
    m_flBrightness = 0X001574 // float32
    m_hCubemapTexture = 0X001578 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_bCustomCubemapTexture = 0X001580 // bool
    m_hLightProbeTexture = 0X001588 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightIndicesTexture = 0X001590 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightScalarsTexture = 0X001598 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightShadowsTexture = 0X0015A0 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_vBoxMins = 0X0015A8 // Vector
    m_vBoxMaxs = 0X0015B4 // Vector
    m_LightGroups = 0X0015C0 // CUtlSymbolLarge
    m_bMoveable = 0X0015C8 // bool
    m_nHandshake = 0X0015CC // int32
    m_nEnvCubeMapArrayIndex = 0X0015D0 // int32
    m_nPriority = 0X0015D4 // int32
    m_bStartDisabled = 0X0015D8 // bool
    m_flEdgeFadeDist = 0X0015DC // float32
    m_vEdgeFadeDists = 0X0015E0 // Vector
    m_nLightProbeSizeX = 0X0015EC // int32
    m_nLightProbeSizeY = 0X0015F0 // int32
    m_nLightProbeSizeZ = 0X0015F4 // int32
    m_nLightProbeAtlasX = 0X0015F8 // int32
    m_nLightProbeAtlasY = 0X0015FC // int32
    m_nLightProbeAtlasZ = 0X001600 // int32
    m_bEnabled = 0X001619 // bool

 CEnvCubemap: [server.dll]
    m_hCubemapTexture = 0X000590 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_bCustomCubemapTexture = 0X000598 // bool
    m_flInfluenceRadius = 0X00059C // float32
    m_vBoxProjectMins = 0X0005A0 // Vector
    m_vBoxProjectMaxs = 0X0005AC // Vector
    m_LightGroups = 0X0005B8 // CUtlSymbolLarge
    m_bMoveable = 0X0005C0 // bool
    m_nHandshake = 0X0005C4 // int32
    m_nEnvCubeMapArrayIndex = 0X0005C8 // int32
    m_nPriority = 0X0005CC // int32
    m_flEdgeFadeDist = 0X0005D0 // float32
    m_vEdgeFadeDists = 0X0005D4 // Vector
    m_flDiffuseScale = 0X0005E0 // float32
    m_bStartDisabled = 0X0005E4 // bool
    m_bDefaultEnvMap = 0X0005E5 // bool
    m_bDefaultSpecEnvMap = 0X0005E6 // bool
    m_bIndoorCubeMap = 0X0005E7 // bool
    m_bCopyDiffuseFromDefaultCubemap = 0X0005E8 // bool
    m_bEnabled = 0X0005F8 // bool

 CEnvCubemapBox: [server.dll]
    No schemes available

 CEnvCubemapFog: [server.dll]
    m_flEndDistance = 0X0004A0 // float32
    m_flStartDistance = 0X0004A4 // float32
    m_flFogFalloffExponent = 0X0004A8 // float32
    m_bHeightFogEnabled = 0X0004AC // bool
    m_flFogHeightWidth = 0X0004B0 // float32
    m_flFogHeightEnd = 0X0004B4 // float32
    m_flFogHeightStart = 0X0004B8 // float32
    m_flFogHeightExponent = 0X0004BC // float32
    m_flLODBias = 0X0004C0 // float32
    m_bActive = 0X0004C4 // bool
    m_bStartDisabled = 0X0004C5 // bool
    m_flFogMaxOpacity = 0X0004C8 // float32
    m_nCubemapSourceType = 0X0004CC // int32
    m_hSkyMaterial = 0X0004D0 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_iszSkyEntity = 0X0004D8 // CUtlSymbolLarge
    m_hFogCubemapTexture = 0X0004E0 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_bHasHeightFogEnd = 0X0004E8 // bool
    m_bFirstTime = 0X0004E9 // bool

 CGradientFog: [server.dll]
    m_hGradientFogTexture = 0X0004A0 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_flFogStartDistance = 0X0004A8 // float32
    m_flFogEndDistance = 0X0004AC // float32
    m_bHeightFogEnabled = 0X0004B0 // bool
    m_flFogStartHeight = 0X0004B4 // float32
    m_flFogEndHeight = 0X0004B8 // float32
    m_flFarZ = 0X0004BC // float32
    m_flFogMaxOpacity = 0X0004C0 // float32
    m_flFogFalloffExponent = 0X0004C4 // float32
    m_flFogVerticalExponent = 0X0004C8 // float32
    m_fogColor = 0X0004CC // Color
    m_flFogStrength = 0X0004D0 // float32
    m_flFadeTime = 0X0004D4 // float32
    m_bStartDisabled = 0X0004D8 // bool
    m_bIsEnabled = 0X0004D9 // bool
    m_bGradientFogNeedsTextures = 0X0004DA // bool

 CEnvLightProbeVolume: [server.dll]
    m_hLightProbeTexture = 0X001480 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightIndicesTexture = 0X001488 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightScalarsTexture = 0X001490 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightShadowsTexture = 0X001498 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_vBoxMins = 0X0014A0 // Vector
    m_vBoxMaxs = 0X0014AC // Vector
    m_LightGroups = 0X0014B8 // CUtlSymbolLarge
    m_bMoveable = 0X0014C0 // bool
    m_nHandshake = 0X0014C4 // int32
    m_nPriority = 0X0014C8 // int32
    m_bStartDisabled = 0X0014CC // bool
    m_nLightProbeSizeX = 0X0014D0 // int32
    m_nLightProbeSizeY = 0X0014D4 // int32
    m_nLightProbeSizeZ = 0X0014D8 // int32
    m_nLightProbeAtlasX = 0X0014DC // int32
    m_nLightProbeAtlasY = 0X0014E0 // int32
    m_nLightProbeAtlasZ = 0X0014E4 // int32
    m_bEnabled = 0X0014F1 // bool

 CTonemapController2: [server.dll]
    m_flAutoExposureMin = 0X0004A0 // float32
    m_flAutoExposureMax = 0X0004A4 // float32
    m_flTonemapPercentTarget = 0X0004A8 // float32
    m_flTonemapPercentBrightPixels = 0X0004AC // float32
    m_flTonemapMinAvgLum = 0X0004B0 // float32
    m_flExposureAdaptationSpeedUp = 0X0004B4 // float32
    m_flExposureAdaptationSpeedDown = 0X0004B8 // float32
    m_flTonemapEVSmoothingRange = 0X0004BC // float32

 CEnvVolumetricFogController: [server.dll]
    m_flScattering = 0X0004A0 // float32
    m_flAnisotropy = 0X0004A4 // float32
    m_flFadeSpeed = 0X0004A8 // float32
    m_flDrawDistance = 0X0004AC // float32
    m_flFadeInStart = 0X0004B0 // float32
    m_flFadeInEnd = 0X0004B4 // float32
    m_flIndirectStrength = 0X0004B8 // float32
    m_nIndirectTextureDimX = 0X0004BC // int32
    m_nIndirectTextureDimY = 0X0004C0 // int32
    m_nIndirectTextureDimZ = 0X0004C4 // int32
    m_vBoxMins = 0X0004C8 // Vector
    m_vBoxMaxs = 0X0004D4 // Vector
    m_bActive = 0X0004E0 // bool
    m_flStartAnisoTime = 0X0004E4 // GameTime_t
    m_flStartScatterTime = 0X0004E8 // GameTime_t
    m_flStartDrawDistanceTime = 0X0004EC // GameTime_t
    m_flStartAnisotropy = 0X0004F0 // float32
    m_flStartScattering = 0X0004F4 // float32
    m_flStartDrawDistance = 0X0004F8 // float32
    m_flDefaultAnisotropy = 0X0004FC // float32
    m_flDefaultScattering = 0X000500 // float32
    m_flDefaultDrawDistance = 0X000504 // float32
    m_bStartDisabled = 0X000508 // bool
    m_bEnableIndirect = 0X000509 // bool
    m_bIsMaster = 0X00050A // bool
    m_hFogIndirectTexture = 0X000510 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_nForceRefreshCount = 0X000518 // int32
    m_bFirstTime = 0X00051C // bool

 CEnvVolumetricFogVolume: [server.dll]
    m_bActive = 0X0004A0 // bool
    m_vBoxMins = 0X0004A4 // Vector
    m_vBoxMaxs = 0X0004B0 // Vector
    m_bStartDisabled = 0X0004BC // bool
    m_flStrength = 0X0004C0 // float32
    m_nFalloffShape = 0X0004C4 // int32
    m_flFalloffExponent = 0X0004C8 // float32

 CFogController: [server.dll]
    m_fog = 0X0004A0 // fogparams_t
    m_bUseAngles = 0X000508 // bool
    m_iChangedVariables = 0X00050C // int32

 CInfoTarget: [server.dll]
    No schemes available

 CInfoParticleTarget: [server.dll]
    No schemes available

 CInfoVisibilityBox: [server.dll]
    m_nMode = 0X0004A4 // int32
    m_vBoxSize = 0X0004A8 // Vector
    m_bEnabled = 0X0004B4 // bool

 CInfoWorldLayer: [server.dll]
    m_pOutputOnEntitiesSpawned = 0X0004A0 // CEntityIOOutput
    m_worldName = 0X0004C8 // CUtlSymbolLarge
    m_layerName = 0X0004D0 // CUtlSymbolLarge
    m_bWorldLayerVisible = 0X0004D8 // bool
    m_bEntitiesSpawned = 0X0004D9 // bool
    m_bCreateAsChildSpawnGroup = 0X0004DA // bool
    m_hLayerSpawnGroup = 0X0004DC // uint32

 CMultiLightProxy: [server.dll]
    m_iszLightNameFilter = 0X0004A0 // CUtlSymbolLarge
    m_iszLightClassFilter = 0X0004A8 // CUtlSymbolLarge
    m_flLightRadiusFilter = 0X0004B0 // float32
    m_flBrightnessDelta = 0X0004B4 // float32
    m_bPerformScreenFade = 0X0004B8 // bool
    m_flTargetBrightnessMultiplier = 0X0004BC // float32
    m_flCurrentBrightnessMultiplier = 0X0004C0 // float32
    m_vecLights = 0X0004C8 // CUtlVector< CHandle< CLightEntity > >

 CPointCamera: [server.dll]
    m_FOV = 0X0004A0 // float32
    m_Resolution = 0X0004A4 // float32
    m_bFogEnable = 0X0004A8 // bool
    m_FogColor = 0X0004A9 // Color
    m_flFogStart = 0X0004B0 // float32
    m_flFogEnd = 0X0004B4 // float32
    m_flFogMaxDensity = 0X0004B8 // float32
    m_bActive = 0X0004BC // bool
    m_bUseScreenAspectRatio = 0X0004BD // bool
    m_flAspectRatio = 0X0004C0 // float32
    m_bNoSky = 0X0004C4 // bool
    m_fBrightness = 0X0004C8 // float32
    m_flZFar = 0X0004CC // float32
    m_flZNear = 0X0004D0 // float32
    m_bDofEnabled = 0X0004D4 // bool
    m_flDofNearBlurry = 0X0004D8 // float32
    m_flDofNearCrisp = 0X0004DC // float32
    m_flDofFarCrisp = 0X0004E0 // float32
    m_flDofFarBlurry = 0X0004E4 // float32
    m_flDofTiltToGround = 0X0004E8 // float32
    m_TargetFOV = 0X0004EC // float32
    m_DegreesPerSecond = 0X0004F0 // float32
    m_bIsOn = 0X0004F4 // bool
    m_pNext = 0X0004F8 // CPointCamera*

 CPointCameraVFOV: [server.dll]
    m_flVerticalFOV = 0X000500 // float32

 CPointTemplate: [server.dll]
    m_iszWorldName = 0X0004A0 // CUtlSymbolLarge
    m_iszSource2EntityLumpName = 0X0004A8 // CUtlSymbolLarge
    m_iszEntityFilterName = 0X0004B0 // CUtlSymbolLarge
    m_flTimeoutInterval = 0X0004B8 // float32
    m_bAsynchronouslySpawnEntities = 0X0004BC // bool
    m_pOutputOnSpawned = 0X0004C0 // CEntityIOOutput
    m_clientOnlyEntityBehavior = 0X0004E8 // PointTemplateClientOnlyEntityBehavior_t
    m_ownerSpawnGroupType = 0X0004EC // PointTemplateOwnerSpawnGroupType_t
    m_createdSpawnGroupHandles = 0X0004F0 // CUtlVector< uint32 >
    m_SpawnedEntityHandles = 0X000508 // CUtlVector< CEntityHandle >
    m_ScriptSpawnCallback = 0X000520 // HSCRIPT
    m_ScriptCallbackScope = 0X000528 // HSCRIPT

 CGameGibManager: [server.dll]
    m_bAllowNewGibs = 0X0004C0 // bool
    m_iCurrentMaxPieces = 0X0004C4 // int32
    m_iMaxPieces = 0X0004C8 // int32
    m_iLastFrame = 0X0004CC // int32

 CSoundAreaEntityBase: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_iszSoundAreaType = 0X0004A8 // CUtlSymbolLarge
    m_vPos = 0X0004B0 // Vector

 CSoundAreaEntitySphere: [server.dll]
    m_flRadius = 0X0004C0 // float32

 CSoundAreaEntityOrientedBox: [server.dll]
    m_vMin = 0X0004C0 // Vector
    m_vMax = 0X0004CC // Vector

 CTeam: [server.dll]
    m_aPlayerControllers = 0X0004A0 // CNetworkUtlVectorBase< CHandle< CBasePlayerController > >
    m_aPlayers = 0X0004B8 // CNetworkUtlVectorBase< CHandle< CBasePlayerPawn > >
    m_iScore = 0X0004D0 // int32
    m_szTeamname = 0X0004D4 // char[129]

 CBasePlayerController: [server.dll]
    m_nInButtonsWhichAreToggles = 0X0004A8 // uint64
    m_nTickBase = 0X0004B0 // uint32
    m_hPawn = 0X0004E0 // CHandle< CBasePlayerPawn >
    m_nSplitScreenSlot = 0X0004E4 // CSplitScreenSlot
    m_hSplitOwner = 0X0004E8 // CHandle< CBasePlayerController >
    m_hSplitScreenPlayers = 0X0004F0 // CUtlVector< CHandle< CBasePlayerController > >
    m_bIsHLTV = 0X000508 // bool
    m_iConnected = 0X00050C // PlayerConnectedState
    m_iszPlayerName = 0X000510 // char[128]
    m_szNetworkIDString = 0X000590 // CUtlString
    m_fLerpTime = 0X000598 // float32
    m_bLagCompensation = 0X00059C // bool
    m_bPredict = 0X00059D // bool
    m_bAutoKickDisabled = 0X00059E // bool
    m_bIsLowViolence = 0X00059F // bool
    m_bGamePaused = 0X0005A0 // bool
    m_nHighestCommandNumberReceived = 0X000618 // int32
    m_nUsecTimestampLastUserCmdReceived = 0X000620 // int64
    m_iIgnoreGlobalChat = 0X000638 // ChatIgnoreType_t
    m_flLastPlayerTalkTime = 0X00063C // float32
    m_flLastEntitySteadyState = 0X000640 // float32
    m_nAvailableEntitySteadyState = 0X000644 // int32
    m_bHasAnySteadyStateEnts = 0X000648 // bool
    m_steamID = 0X000658 // uint64
    m_iDesiredFOV = 0X000660 // uint32

 CBasePlayerVData: [server.dll]
    m_sModelName = 0X000028 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_flHeadDamageMultiplier = 0X000108 // CSkillFloat
    m_flChestDamageMultiplier = 0X000118 // CSkillFloat
    m_flStomachDamageMultiplier = 0X000128 // CSkillFloat
    m_flArmDamageMultiplier = 0X000138 // CSkillFloat
    m_flLegDamageMultiplier = 0X000148 // CSkillFloat
    m_flHoldBreathTime = 0X000158 // float32
    m_flDrowningDamageInterval = 0X00015C // float32
    m_nDrowningDamageInitial = 0X000160 // int32
    m_nDrowningDamageMax = 0X000164 // int32
    m_nWaterSpeed = 0X000168 // int32
    m_flUseRange = 0X00016C // float32
    m_flUseAngleTolerance = 0X000170 // float32
    m_flCrouchTime = 0X000174 // float32

 CBasePlayerWeaponVData: [server.dll]
    m_szWorldModel = 0X000028 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_bBuiltRightHanded = 0X000108 // bool
    m_bAllowFlipping = 0X000109 // bool
    m_bIsFullAuto = 0X00010A // bool
    m_nNumBullets = 0X00010C // int32
    m_sMuzzleAttachment = 0X000110 // CUtlString
    m_szMuzzleFlashParticle = 0X000118 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szTracerParticle = 0X0001F8 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_iFlags = 0X0002D8 // ItemFlagTypes_t
    m_nPrimaryAmmoType = 0X0002D9 // AmmoIndex_t
    m_nSecondaryAmmoType = 0X0002DA // AmmoIndex_t
    m_iMaxClip1 = 0X0002DC // int32
    m_iMaxClip2 = 0X0002E0 // int32
    m_iDefaultClip1 = 0X0002E4 // int32
    m_iDefaultClip2 = 0X0002E8 // int32
    m_iWeight = 0X0002EC // int32
    m_bAutoSwitchTo = 0X0002F0 // bool
    m_bAutoSwitchFrom = 0X0002F1 // bool
    m_iRumbleEffect = 0X0002F4 // RumbleEffect_t
    m_aShootSounds = 0X0002F8 // CUtlMap< WeaponSound_t, CSoundEventName >
    m_iSlot = 0X000318 // int32
    m_iPosition = 0X00031C // int32

 CInfoGameEventProxy: [server.dll]
    m_iszEventName = 0X0004A0 // CUtlSymbolLarge
    m_flRange = 0X0004A8 // float32

 CProjectedDecal: [server.dll]
    m_nTexture = 0X0004A0 // int32
    m_flDistance = 0X0004A4 // float32

 CBaseAnimGraphController: [server.dll]
    m_baseLayer = 0X000018 // CNetworkedSequenceOperation
    m_animGraphNetworkedVars = 0X000040 // CAnimGraphNetworkedVariables
    m_bSequenceFinished = 0X0001F0 // bool
    m_flLastEventCycle = 0X0001F4 // float32
    m_flLastEventAnimTime = 0X0001F8 // float32
    m_flPlaybackRate = 0X0001FC // CNetworkedQuantizedFloat
    m_flPrevAnimTime = 0X000204 // float32
    m_bClientSideAnimation = 0X000208 // bool
    m_bNetworkedAnimationInputsChanged = 0X000209 // bool
    m_nNewSequenceParity = 0X00020C // int32
    m_nResetEventsParity = 0X000210 // int32
    m_nAnimLoopMode = 0X000214 // AnimLoopMode_t
    m_hAnimationUpdate = 0X0002AC // AnimationUpdateListHandle_t

 CBaseModelEntity: [server.dll]
    m_CRenderComponent = 0X0004A0 // CRenderComponent*
    m_CHitboxComponent = 0X0004A8 // CHitboxComponent
    m_flDissolveStartTime = 0X0004D0 // GameTime_t
    m_OnIgnite = 0X0004D8 // CEntityIOOutput
    m_nRenderMode = 0X000500 // RenderMode_t
    m_nRenderFX = 0X000501 // RenderFx_t
    m_bAllowFadeInView = 0X000502 // bool
    m_clrRender = 0X000503 // Color
    m_vecRenderAttributes = 0X000508 // CUtlVectorEmbeddedNetworkVar< EntityRenderAttribute_t >
    m_LightGroup = 0X000558 // CUtlStringToken
    m_bRenderToCubemaps = 0X00055C // bool
    m_Collision = 0X000560 // CCollisionProperty
    m_Glow = 0X000610 // CGlowProperty
    m_flGlowBackfaceMult = 0X000668 // float32
    m_fadeMinDist = 0X00066C // float32
    m_fadeMaxDist = 0X000670 // float32
    m_flFadeScale = 0X000674 // float32
    m_flShadowStrength = 0X000678 // float32
    m_nObjectCulling = 0X00067C // uint8
    m_nAddDecal = 0X000680 // int32
    m_vDecalPosition = 0X000684 // Vector
    m_vDecalForwardAxis = 0X000690 // Vector
    m_flDecalHealBloodRate = 0X00069C // float32
    m_flDecalHealHeightRate = 0X0006A0 // float32
    m_ConfigEntitiesToPropagateMaterialDecalsTo = 0X0006A8 // CNetworkUtlVectorBase< CHandle< CBaseModelEntity > >
    m_vecViewOffset = 0X0006C0 // CNetworkViewOffsetVector

 CServerOnlyModelEntity: [server.dll]
    No schemes available

 CModelPointEntity: [server.dll]
    No schemes available

 CLogicRelay: [server.dll]
    m_OnTrigger = 0X0004A0 // CEntityIOOutput
    m_OnSpawn = 0X0004C8 // CEntityIOOutput
    m_bDisabled = 0X0004F0 // bool
    m_bWaitForRefire = 0X0004F1 // bool
    m_bTriggerOnce = 0X0004F2 // bool
    m_bFastRetrigger = 0X0004F3 // bool
    m_bPassthoughCaller = 0X0004F4 // bool

 CParticleSystem: [server.dll]
    m_szSnapshotFileName = 0X0006F0 // char[512]
    m_bActive = 0X0008F0 // bool
    m_bFrozen = 0X0008F1 // bool
    m_flFreezeTransitionDuration = 0X0008F4 // float32
    m_nStopType = 0X0008F8 // int32
    m_bAnimateDuringGameplayPause = 0X0008FC // bool
    m_iEffectIndex = 0X000900 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_flStartTime = 0X000908 // GameTime_t
    m_flPreSimTime = 0X00090C // float32
    m_vServerControlPoints = 0X000910 // Vector[4]
    m_iServerControlPointAssignments = 0X000940 // uint8[4]
    m_hControlPointEnts = 0X000944 // CHandle< CBaseEntity >[64]
    m_bNoSave = 0X000A44 // bool
    m_bNoFreeze = 0X000A45 // bool
    m_bStartActive = 0X000A46 // bool
    m_iszEffectName = 0X000A48 // CUtlSymbolLarge
    m_iszControlPointNames = 0X000A50 // CUtlSymbolLarge[64]
    m_nDataCP = 0X000C50 // int32
    m_vecDataCPValue = 0X000C54 // Vector
    m_nTintCP = 0X000C60 // int32
    m_clrTint = 0X000C64 // Color

 CPathParticleRope: [server.dll]
    m_bStartActive = 0X0004A0 // bool
    m_flMaxSimulationTime = 0X0004A4 // float32
    m_iszEffectName = 0X0004A8 // CUtlSymbolLarge
    m_PathNodes_Name = 0X0004B0 // CUtlVector< CUtlSymbolLarge >
    m_flParticleSpacing = 0X0004C8 // float32
    m_flSlack = 0X0004CC // float32
    m_flRadius = 0X0004D0 // float32
    m_ColorTint = 0X0004D4 // Color
    m_nEffectState = 0X0004D8 // int32
    m_iEffectIndex = 0X0004E0 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_PathNodes_Position = 0X0004E8 // CNetworkUtlVectorBase< Vector >
    m_PathNodes_TangentIn = 0X000500 // CNetworkUtlVectorBase< Vector >
    m_PathNodes_TangentOut = 0X000518 // CNetworkUtlVectorBase< Vector >
    m_PathNodes_Color = 0X000530 // CNetworkUtlVectorBase< Vector >
    m_PathNodes_PinEnabled = 0X000548 // CNetworkUtlVectorBase< bool >
    m_PathNodes_RadiusScale = 0X000560 // CNetworkUtlVectorBase< float32 >

 CPathParticleRopeAlias_path_particle_rope_clientside: [server.dll]
    No schemes available

 CFuncWall: [server.dll]
    m_nState = 0X0006F0 // int32

 CFuncWallToggle: [server.dll]
    No schemes available

 CFuncVehicleClip: [server.dll]
    No schemes available

 CFuncIllusionary: [server.dll]
    No schemes available

 CFuncVPhysicsClip: [server.dll]
    m_bDisabled = 0X0006F0 // bool

 CFuncInteractionLayerClip: [server.dll]
    m_bDisabled = 0X0006F0 // bool
    m_iszInteractsAs = 0X0006F8 // CUtlSymbolLarge
    m_iszInteractsWith = 0X000700 // CUtlSymbolLarge

 CPointClientCommand: [server.dll]
    No schemes available

 CPointServerCommand: [server.dll]
    No schemes available

 CPointBroadcastClientCommand: [server.dll]
    No schemes available

 CCommentaryAuto: [server.dll]
    m_OnCommentaryNewGame = 0X0004A0 // CEntityIOOutput
    m_OnCommentaryMidGame = 0X0004C8 // CEntityIOOutput
    m_OnCommentaryMultiplayerSpawn = 0X0004F0 // CEntityIOOutput

 CDynamicLight: [server.dll]
    m_ActualFlags = 0X0006F0 // uint8
    m_Flags = 0X0006F1 // uint8
    m_LightStyle = 0X0006F2 // uint8
    m_On = 0X0006F3 // bool
    m_Radius = 0X0006F4 // float32
    m_Exponent = 0X0006F8 // int32
    m_InnerAngle = 0X0006FC // float32
    m_OuterAngle = 0X000700 // float32
    m_SpotRadius = 0X000704 // float32

 CBubbling: [server.dll]
    m_density = 0X0006F0 // int32
    m_frequency = 0X0006F4 // int32
    m_state = 0X0006F8 // int32

 CEnvTracer: [server.dll]
    m_vecEnd = 0X0004A0 // Vector
    m_flDelay = 0X0004AC // float32

 CTestEffect: [server.dll]
    m_iLoop = 0X0004A0 // int32
    m_iBeam = 0X0004A4 // int32
    m_pBeam = 0X0004A8 // CBeam*[24]
    m_flBeamTime = 0X000568 // GameTime_t[24]
    m_flStartTime = 0X0005C8 // GameTime_t

 CBlood: [server.dll]
    m_vecSprayAngles = 0X0004A0 // QAngle
    m_vecSprayDir = 0X0004AC // Vector
    m_flAmount = 0X0004B8 // float32
    m_Color = 0X0004BC // int32

 CEnvFunnel: [server.dll]
    No schemes available

 CEnvBeverage: [server.dll]
    m_CanInDispenser = 0X0004A0 // bool
    m_nBeverageType = 0X0004A4 // int32

 CPrecipitationBlocker: [server.dll]
    No schemes available

 CEnvWind: [server.dll]
    m_EnvWindShared = 0X0004A0 // CEnvWindShared

 CPhysicsWire: [server.dll]
    m_nDensity = 0X0004A0 // int32

 CEnvMuzzleFlash: [server.dll]
    m_flScale = 0X0004A0 // float32
    m_iszParentAttachment = 0X0004A8 // CUtlSymbolLarge

 CEnvSplash: [server.dll]
    m_flScale = 0X0004A0 // float32

 CEnvViewPunch: [server.dll]
    m_flRadius = 0X0004A0 // float32
    m_angViewPunch = 0X0004A4 // QAngle

 CEnvEntityIgniter: [server.dll]
    m_flLifetime = 0X0004A0 // float32

 CDebugHistory: [server.dll]
    m_nNpcEvents = 0X1F44E0 // int32

 CEnvEntityMaker: [server.dll]
    m_vecEntityMins = 0X0004A0 // Vector
    m_vecEntityMaxs = 0X0004AC // Vector
    m_hCurrentInstance = 0X0004B8 // CHandle< CBaseEntity >
    m_hCurrentBlocker = 0X0004BC // CHandle< CBaseEntity >
    m_vecBlockerOrigin = 0X0004C0 // Vector
    m_angPostSpawnDirection = 0X0004CC // QAngle
    m_flPostSpawnDirectionVariance = 0X0004D8 // float32
    m_flPostSpawnSpeed = 0X0004DC // float32
    m_bPostSpawnUseAngles = 0X0004E0 // bool
    m_iszTemplate = 0X0004E8 // CUtlSymbolLarge
    m_pOutputOnSpawned = 0X0004F0 // CEntityIOOutput
    m_pOutputOnFailedSpawn = 0X000518 // CEntityIOOutput

 CInfoInstructorHintTarget: [server.dll]
    No schemes available

 CEnvInstructorHint: [server.dll]
    m_iszName = 0X0004A0 // CUtlSymbolLarge
    m_iszReplace_Key = 0X0004A8 // CUtlSymbolLarge
    m_iszHintTargetEntity = 0X0004B0 // CUtlSymbolLarge
    m_iTimeout = 0X0004B8 // int32
    m_iDisplayLimit = 0X0004BC // int32
    m_iszIcon_Onscreen = 0X0004C0 // CUtlSymbolLarge
    m_iszIcon_Offscreen = 0X0004C8 // CUtlSymbolLarge
    m_iszCaption = 0X0004D0 // CUtlSymbolLarge
    m_iszActivatorCaption = 0X0004D8 // CUtlSymbolLarge
    m_Color = 0X0004E0 // Color
    m_fIconOffset = 0X0004E4 // float32
    m_fRange = 0X0004E8 // float32
    m_iPulseOption = 0X0004EC // uint8
    m_iAlphaOption = 0X0004ED // uint8
    m_iShakeOption = 0X0004EE // uint8
    m_bStatic = 0X0004EF // bool
    m_bNoOffscreen = 0X0004F0 // bool
    m_bForceCaption = 0X0004F1 // bool
    m_iInstanceType = 0X0004F4 // int32
    m_bSuppressRest = 0X0004F8 // bool
    m_iszBinding = 0X000500 // CUtlSymbolLarge
    m_bAllowNoDrawTarget = 0X000508 // bool
    m_bAutoStart = 0X000509 // bool
    m_bLocalPlayerOnly = 0X00050A // bool

 CEnvInstructorVRHint: [server.dll]
    m_iszName = 0X0004A0 // CUtlSymbolLarge
    m_iszHintTargetEntity = 0X0004A8 // CUtlSymbolLarge
    m_iTimeout = 0X0004B0 // int32
    m_iszCaption = 0X0004B8 // CUtlSymbolLarge
    m_iszStartSound = 0X0004C0 // CUtlSymbolLarge
    m_iLayoutFileType = 0X0004C8 // int32
    m_iszCustomLayoutFile = 0X0004D0 // CUtlSymbolLarge
    m_iAttachType = 0X0004D8 // int32
    m_flHeightOffset = 0X0004DC // float32

 CInstructorEventEntity: [server.dll]
    m_iszName = 0X0004A0 // CUtlSymbolLarge
    m_iszHintTargetEntity = 0X0004A8 // CUtlSymbolLarge
    m_hTargetPlayer = 0X0004B0 // CHandle< CBasePlayerPawn >

 CEnvScreenOverlay: [server.dll]
    m_iszOverlayNames = 0X0004A0 // CUtlSymbolLarge[10]
    m_flOverlayTimes = 0X0004F0 // float32[10]
    m_flStartTime = 0X000518 // GameTime_t
    m_iDesiredOverlay = 0X00051C // int32
    m_bIsActive = 0X000520 // bool

 CEnvZoom: [server.dll]
    m_flSpeed = 0X0004A0 // float32
    m_nFOV = 0X0004A4 // int32

 CEnvFade: [server.dll]
    m_fadeColor = 0X0004A0 // Color
    m_Duration = 0X0004A4 // float32
    m_HoldDuration = 0X0004A8 // float32
    m_OnBeginFade = 0X0004B0 // CEntityIOOutput

 CCredits: [server.dll]
    m_OnCreditsDone = 0X0004A0 // CEntityIOOutput
    m_bRolledOutroCredits = 0X0004C8 // bool
    m_flLogoLength = 0X0004CC // float32

 CEnvShake: [server.dll]
    m_limitToEntity = 0X0004A0 // CUtlSymbolLarge
    m_Amplitude = 0X0004A8 // float32
    m_Frequency = 0X0004AC // float32
    m_Duration = 0X0004B0 // float32
    m_Radius = 0X0004B4 // float32
    m_stopTime = 0X0004B8 // GameTime_t
    m_nextShake = 0X0004BC // GameTime_t
    m_currentAmp = 0X0004C0 // float32
    m_maxForce = 0X0004C4 // Vector
    m_shakeCallback = 0X0004D8 // CPhysicsShake

 CEnvTilt: [server.dll]
    m_Duration = 0X0004A0 // float32
    m_Radius = 0X0004A4 // float32
    m_TiltTime = 0X0004A8 // float32
    m_stopTime = 0X0004AC // GameTime_t

 CEnvSpark: [server.dll]
    m_flDelay = 0X0004A0 // float32
    m_nMagnitude = 0X0004A4 // int32
    m_nTrailLength = 0X0004A8 // int32
    m_nType = 0X0004AC // int32
    m_OnSpark = 0X0004B0 // CEntityIOOutput

 CShower: [server.dll]
    No schemes available

 CEnvExplosion: [server.dll]
    m_iMagnitude = 0X0006F0 // int32
    m_flPlayerDamage = 0X0006F4 // float32
    m_iRadiusOverride = 0X0006F8 // int32
    m_flInnerRadius = 0X0006FC // float32
    m_spriteScale = 0X000700 // int32
    m_flDamageForce = 0X000704 // float32
    m_hInflictor = 0X000708 // CHandle< CBaseEntity >
    m_iCustomDamageType = 0X00070C // int32
    m_iszExplosionType = 0X000718 // CUtlSymbolLarge
    m_iszCustomEffectName = 0X000720 // CUtlSymbolLarge
    m_iszCustomSoundName = 0X000728 // CUtlSymbolLarge
    m_iClassIgnore = 0X000730 // Class_T
    m_iClassIgnore2 = 0X000734 // Class_T
    m_iszEntityIgnoreName = 0X000738 // CUtlSymbolLarge
    m_hEntityIgnore = 0X000740 // CHandle< CBaseEntity >

 CFilterName: [server.dll]
    m_iFilterName = 0X0004F8 // CUtlSymbolLarge

 CFilterModel: [server.dll]
    m_iFilterModel = 0X0004F8 // CUtlSymbolLarge

 CFilterContext: [server.dll]
    m_iFilterContext = 0X0004F8 // CUtlSymbolLarge

 FilterTeam: [server.dll]
    m_iFilterTeam = 0X0004F8 // int32

 CFilterMassGreater: [server.dll]
    m_fFilterMass = 0X0004F8 // float32

 FilterDamageType: [server.dll]
    m_iDamageType = 0X0004F8 // int32

 FilterHealth: [server.dll]
    m_bAdrenalineActive = 0X0004F8 // bool
    m_iHealthMin = 0X0004FC // int32
    m_iHealthMax = 0X000500 // int32

 CFilterEnemy: [server.dll]
    m_iszEnemyName = 0X0004F8 // CUtlSymbolLarge
    m_flRadius = 0X000500 // float32
    m_flOuterRadius = 0X000504 // float32
    m_nMaxSquadmatesPerEnemy = 0X000508 // int32
    m_iszPlayerName = 0X000510 // CUtlSymbolLarge

 CFilterAttributeInt: [server.dll]
    m_sAttributeName = 0X0004F8 // CUtlStringToken

 CFire: [server.dll]
    m_hEffect = 0X0006F0 // CHandle< CBaseFire >
    m_hOwner = 0X0006F4 // CHandle< CBaseEntity >
    m_nFireType = 0X0006F8 // int32
    m_flFuel = 0X0006FC // float32
    m_flDamageTime = 0X000700 // GameTime_t
    m_lastDamage = 0X000704 // GameTime_t
    m_flFireSize = 0X000708 // float32
    m_flLastNavUpdateTime = 0X00070C // GameTime_t
    m_flHeatLevel = 0X000710 // float32
    m_flHeatAbsorb = 0X000714 // float32
    m_flDamageScale = 0X000718 // float32
    m_flMaxHeat = 0X00071C // float32
    m_flLastHeatLevel = 0X000720 // float32
    m_flAttackTime = 0X000724 // float32
    m_bEnabled = 0X000728 // bool
    m_bStartDisabled = 0X000729 // bool
    m_bDidActivate = 0X00072A // bool
    m_OnIgnited = 0X000730 // CEntityIOOutput
    m_OnExtinguished = 0X000758 // CEntityIOOutput

 CEnvFireSource: [server.dll]
    m_bEnabled = 0X0004A0 // bool
    m_radius = 0X0004A4 // float32
    m_damage = 0X0004A8 // float32

 CEnvFireSensor: [server.dll]
    m_bEnabled = 0X0004A0 // bool
    m_bHeatAtLevel = 0X0004A1 // bool
    m_radius = 0X0004A4 // float32
    m_targetLevel = 0X0004A8 // float32
    m_targetTime = 0X0004AC // float32
    m_levelTime = 0X0004B0 // float32
    m_OnHeatLevelStart = 0X0004B8 // CEntityIOOutput
    m_OnHeatLevelEnd = 0X0004E0 // CEntityIOOutput

 CFuncTimescale: [server.dll]
    m_flDesiredTimescale = 0X0004A0 // float32
    m_flAcceleration = 0X0004A4 // float32
    m_flMinBlendRate = 0X0004A8 // float32
    m_flBlendDeltaMultiplier = 0X0004AC // float32
    m_isStarted = 0X0004B0 // bool

 CGameWeaponManager: [server.dll]
    m_iszWeaponName = 0X0004A0 // CUtlSymbolLarge
    m_iMaxPieces = 0X0004B0 // int32
    m_flAmmoMod = 0X0004B4 // float32
    m_bExpectingWeapon = 0X0004B8 // bool
    m_ManagedNonWeapons = 0X0004C0 // CUtlVector< CHandle< CBaseEntity > >

 CLightGlow: [server.dll]
    m_nHorizontalSize = 0X0006F0 // uint32
    m_nVerticalSize = 0X0006F4 // uint32
    m_nMinDist = 0X0006F8 // uint32
    m_nMaxDist = 0X0006FC // uint32
    m_nOuterMaxDist = 0X000700 // uint32
    m_flGlowProxySize = 0X000704 // float32
    m_flHDRColorScale = 0X000708 // float32

 CLogicAchievement: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_iszAchievementEventID = 0X0004A8 // CUtlSymbolLarge
    m_OnFired = 0X0004B0 // CEntityIOOutput

 CLogicGameEventListener: [server.dll]
    m_OnEventFired = 0X0004B0 // CEntityIOOutput
    m_iszGameEventName = 0X0004D8 // CUtlSymbolLarge
    m_iszGameEventItem = 0X0004E0 // CUtlSymbolLarge
    m_bEnabled = 0X0004E8 // bool
    m_bStartDisabled = 0X0004E9 // bool

 CLogicMeasureMovement: [server.dll]
    m_strMeasureTarget = 0X0004A0 // CUtlSymbolLarge
    m_strMeasureReference = 0X0004A8 // CUtlSymbolLarge
    m_strTargetReference = 0X0004B0 // CUtlSymbolLarge
    m_hMeasureTarget = 0X0004B8 // CHandle< CBaseEntity >
    m_hMeasureReference = 0X0004BC // CHandle< CBaseEntity >
    m_hTarget = 0X0004C0 // CHandle< CBaseEntity >
    m_hTargetReference = 0X0004C4 // CHandle< CBaseEntity >
    m_flScale = 0X0004C8 // float32
    m_nMeasureType = 0X0004CC // int32

 CLogicNavigation: [server.dll]
    m_isOn = 0X0004A8 // bool
    m_navProperty = 0X0004AC // navproperties_t

 CLogicNPCCounter: [server.dll]
    m_OnMinCountAll = 0X0004A0 // CEntityIOOutput
    m_OnMaxCountAll = 0X0004C8 // CEntityIOOutput
    m_OnFactorAll = 0X0004F0 // CEntityOutputTemplate< float32 >
    m_OnMinPlayerDistAll = 0X000518 // CEntityOutputTemplate< float32 >
    m_OnMinCount_1 = 0X000540 // CEntityIOOutput
    m_OnMaxCount_1 = 0X000568 // CEntityIOOutput
    m_OnFactor_1 = 0X000590 // CEntityOutputTemplate< float32 >
    m_OnMinPlayerDist_1 = 0X0005B8 // CEntityOutputTemplate< float32 >
    m_OnMinCount_2 = 0X0005E0 // CEntityIOOutput
    m_OnMaxCount_2 = 0X000608 // CEntityIOOutput
    m_OnFactor_2 = 0X000630 // CEntityOutputTemplate< float32 >
    m_OnMinPlayerDist_2 = 0X000658 // CEntityOutputTemplate< float32 >
    m_OnMinCount_3 = 0X000680 // CEntityIOOutput
    m_OnMaxCount_3 = 0X0006A8 // CEntityIOOutput
    m_OnFactor_3 = 0X0006D0 // CEntityOutputTemplate< float32 >
    m_OnMinPlayerDist_3 = 0X0006F8 // CEntityOutputTemplate< float32 >
    m_hSource = 0X000720 // CEntityHandle
    m_iszSourceEntityName = 0X000728 // CUtlSymbolLarge
    m_flDistanceMax = 0X000730 // float32
    m_bDisabled = 0X000734 // bool
    m_nMinCountAll = 0X000738 // int32
    m_nMaxCountAll = 0X00073C // int32
    m_nMinFactorAll = 0X000740 // int32
    m_nMaxFactorAll = 0X000744 // int32
    m_iszNPCClassname_1 = 0X000750 // CUtlSymbolLarge
    m_nNPCState_1 = 0X000758 // int32
    m_bInvertState_1 = 0X00075C // bool
    m_nMinCount_1 = 0X000760 // int32
    m_nMaxCount_1 = 0X000764 // int32
    m_nMinFactor_1 = 0X000768 // int32
    m_nMaxFactor_1 = 0X00076C // int32
    m_flDefaultDist_1 = 0X000774 // float32
    m_iszNPCClassname_2 = 0X000778 // CUtlSymbolLarge
    m_nNPCState_2 = 0X000780 // int32
    m_bInvertState_2 = 0X000784 // bool
    m_nMinCount_2 = 0X000788 // int32
    m_nMaxCount_2 = 0X00078C // int32
    m_nMinFactor_2 = 0X000790 // int32
    m_nMaxFactor_2 = 0X000794 // int32
    m_flDefaultDist_2 = 0X00079C // float32
    m_iszNPCClassname_3 = 0X0007A0 // CUtlSymbolLarge
    m_nNPCState_3 = 0X0007A8 // int32
    m_bInvertState_3 = 0X0007AC // bool
    m_nMinCount_3 = 0X0007B0 // int32
    m_nMaxCount_3 = 0X0007B4 // int32
    m_nMinFactor_3 = 0X0007B8 // int32
    m_nMaxFactor_3 = 0X0007BC // int32
    m_flDefaultDist_3 = 0X0007C4 // float32

 CLogicNPCCounterAABB: [server.dll]
    m_vDistanceOuterMins = 0X0007E0 // Vector
    m_vDistanceOuterMaxs = 0X0007EC // Vector
    m_vOuterMins = 0X0007F8 // Vector
    m_vOuterMaxs = 0X000804 // Vector

 CLogicNPCCounterOBB: [server.dll]
    No schemes available

 CLogicPlayerProxy: [server.dll]
    m_hPlayer = 0X0004A0 // CHandle< CBaseEntity >
    m_PlayerHasAmmo = 0X0004A8 // CEntityIOOutput
    m_PlayerHasNoAmmo = 0X0004D0 // CEntityIOOutput
    m_PlayerDied = 0X0004F8 // CEntityIOOutput
    m_RequestedPlayerHealth = 0X000520 // CEntityOutputTemplate< int32 >

 CLogicAuto: [server.dll]
    m_OnMapSpawn = 0X0004A0 // CEntityIOOutput
    m_OnDemoMapSpawn = 0X0004C8 // CEntityIOOutput
    m_OnNewGame = 0X0004F0 // CEntityIOOutput
    m_OnLoadGame = 0X000518 // CEntityIOOutput
    m_OnMapTransition = 0X000540 // CEntityIOOutput
    m_OnBackgroundMap = 0X000568 // CEntityIOOutput
    m_OnMultiNewMap = 0X000590 // CEntityIOOutput
    m_OnMultiNewRound = 0X0005B8 // CEntityIOOutput
    m_OnVREnabled = 0X0005E0 // CEntityIOOutput
    m_OnVRNotEnabled = 0X000608 // CEntityIOOutput
    m_globalstate = 0X000630 // CUtlSymbolLarge

 CLogicScript: [server.dll]
    No schemes available

 CTimerEntity: [server.dll]
    m_OnTimer = 0X0004A0 // CEntityIOOutput
    m_OnTimerHigh = 0X0004C8 // CEntityIOOutput
    m_OnTimerLow = 0X0004F0 // CEntityIOOutput
    m_iDisabled = 0X000518 // int32
    m_flInitialDelay = 0X00051C // float32
    m_flRefireTime = 0X000520 // float32
    m_bUpDownState = 0X000524 // bool
    m_iUseRandomTime = 0X000528 // int32
    m_bPauseAfterFiring = 0X00052C // bool
    m_flLowerRandomBound = 0X000530 // float32
    m_flUpperRandomBound = 0X000534 // float32
    m_flRemainingTime = 0X000538 // float32
    m_bPaused = 0X00053C // bool

 CLogicLineToEntity: [server.dll]
    m_Line = 0X0004A0 // CEntityOutputTemplate< Vector >
    m_SourceName = 0X0004C8 // CUtlSymbolLarge
    m_StartEntity = 0X0004D0 // CHandle< CBaseEntity >
    m_EndEntity = 0X0004D4 // CHandle< CBaseEntity >

 CMathRemap: [server.dll]
    m_flInMin = 0X0004A0 // float32
    m_flInMax = 0X0004A4 // float32
    m_flOut1 = 0X0004A8 // float32
    m_flOut2 = 0X0004AC // float32
    m_flOldInValue = 0X0004B0 // float32
    m_bEnabled = 0X0004B4 // bool
    m_OutValue = 0X0004B8 // CEntityOutputTemplate< float32 >
    m_OnRoseAboveMin = 0X0004E0 // CEntityIOOutput
    m_OnRoseAboveMax = 0X000508 // CEntityIOOutput
    m_OnFellBelowMin = 0X000530 // CEntityIOOutput
    m_OnFellBelowMax = 0X000558 // CEntityIOOutput

 CMathColorBlend: [server.dll]
    m_flInMin = 0X0004A0 // float32
    m_flInMax = 0X0004A4 // float32
    m_OutColor1 = 0X0004A8 // Color
    m_OutColor2 = 0X0004AC // Color
    m_OutValue = 0X0004B0 // CEntityOutputTemplate< Color >

 CEnvGlobal: [server.dll]
    m_outCounter = 0X0004A0 // CEntityOutputTemplate< int32 >
    m_globalstate = 0X0004C8 // CUtlSymbolLarge
    m_triggermode = 0X0004D0 // int32
    m_initialstate = 0X0004D4 // int32
    m_counter = 0X0004D8 // int32

 CMultiSource: [server.dll]
    m_rgEntities = 0X0004A0 // CHandle< CBaseEntity >[32]
    m_rgTriggered = 0X000520 // int32[32]
    m_OnTrigger = 0X0005A0 // CEntityIOOutput
    m_iTotal = 0X0005C8 // int32
    m_globalstate = 0X0005D0 // CUtlSymbolLarge

 CMathCounter: [server.dll]
    m_flMin = 0X0004A0 // float32
    m_flMax = 0X0004A4 // float32
    m_bHitMin = 0X0004A8 // bool
    m_bHitMax = 0X0004A9 // bool
    m_bDisabled = 0X0004AA // bool
    m_OutValue = 0X0004B0 // CEntityOutputTemplate< float32 >
    m_OnGetValue = 0X0004D8 // CEntityOutputTemplate< float32 >
    m_OnHitMin = 0X000500 // CEntityIOOutput
    m_OnHitMax = 0X000528 // CEntityIOOutput
    m_OnChangedFromMin = 0X000550 // CEntityIOOutput
    m_OnChangedFromMax = 0X000578 // CEntityIOOutput

 CLogicCase: [server.dll]
    m_nCase = 0X0004A0 // CUtlSymbolLarge[32]
    m_nShuffleCases = 0X0005A0 // int32
    m_nLastShuffleCase = 0X0005A4 // int32
    m_uchShuffleCaseMap = 0X0005A8 // uint8[32]
    m_OnCase = 0X0005C8 // CEntityIOOutput[32]
    m_OnDefault = 0X000AC8 // CEntityOutputTemplate< CVariantBase< CVariantDefaultAllocator > >

 CLogicCompare: [server.dll]
    m_flInValue = 0X0004A0 // float32
    m_flCompareValue = 0X0004A4 // float32
    m_OnLessThan = 0X0004A8 // CEntityOutputTemplate< float32 >
    m_OnEqualTo = 0X0004D0 // CEntityOutputTemplate< float32 >
    m_OnNotEqualTo = 0X0004F8 // CEntityOutputTemplate< float32 >
    m_OnGreaterThan = 0X000520 // CEntityOutputTemplate< float32 >

 CLogicAutosave: [server.dll]
    m_bForceNewLevelUnit = 0X0004A0 // bool
    m_minHitPoints = 0X0004A4 // int32
    m_minHitPointsToCommit = 0X0004A8 // int32

 CLogicActiveAutosave: [server.dll]
    m_TriggerHitPoints = 0X0004B0 // int32
    m_flTimeToTrigger = 0X0004B4 // float32
    m_flStartTime = 0X0004B8 // GameTime_t
    m_flDangerousTime = 0X0004BC // float32

 CLogicDistanceAutosave: [server.dll]
    m_iszTargetEntity = 0X0004A0 // CUtlSymbolLarge
    m_flDistanceToPlayer = 0X0004A8 // float32
    m_bForceNewLevelUnit = 0X0004AC // bool
    m_bCheckCough = 0X0004AD // bool
    m_bThinkDangerous = 0X0004AE // bool
    m_flDangerousTime = 0X0004B0 // float32

 CLogicCollisionPair: [server.dll]
    m_nameAttach1 = 0X0004A0 // CUtlSymbolLarge
    m_nameAttach2 = 0X0004A8 // CUtlSymbolLarge
    m_disabled = 0X0004B0 // bool
    m_succeeded = 0X0004B1 // bool

 CLogicBranchList: [server.dll]
    m_nLogicBranchNames = 0X0004A0 // CUtlSymbolLarge[16]
    m_LogicBranchList = 0X000520 // CUtlVector< CHandle< CBaseEntity > >
    m_eLastState = 0X000538 // CLogicBranchList::LogicBranchListenerLastState_t
    m_OnAllTrue = 0X000540 // CEntityIOOutput
    m_OnAllFalse = 0X000568 // CEntityIOOutput
    m_OnMixed = 0X000590 // CEntityIOOutput

 CLogicGameEvent: [server.dll]
    m_iszEventName = 0X0004A0 // CUtlSymbolLarge

 CRuleEntity: [server.dll]
    m_iszMaster = 0X0006F0 // CUtlSymbolLarge

 CRulePointEntity: [server.dll]
    m_Score = 0X0006F8 // int32

 CRuleBrushEntity: [server.dll]
    No schemes available

 CGameEnd: [server.dll]
    No schemes available

 CGameText: [server.dll]
    m_iszMessage = 0X000700 // CUtlSymbolLarge
    m_textParms = 0X000708 // hudtextparms_t

 CGamePlayerZone: [server.dll]
    m_OnPlayerInZone = 0X0006F8 // CEntityIOOutput
    m_OnPlayerOutZone = 0X000720 // CEntityIOOutput
    m_PlayersInCount = 0X000748 // CEntityOutputTemplate< int32 >
    m_PlayersOutCount = 0X000770 // CEntityOutputTemplate< int32 >

 CGamePlayerEquip: [server.dll]
    m_weaponNames = 0X000700 // CUtlSymbolLarge[32]
    m_weaponCount = 0X000800 // int32[32]

 CMessageEntity: [server.dll]
    m_radius = 0X0004A0 // int32
    m_messageText = 0X0004A8 // CUtlSymbolLarge
    m_drawText = 0X0004B0 // bool
    m_bDeveloperOnly = 0X0004B1 // bool
    m_bEnabled = 0X0004B2 // bool

 CTriggerBrush: [server.dll]
    m_OnStartTouch = 0X0006F0 // CEntityIOOutput
    m_OnEndTouch = 0X000718 // CEntityIOOutput
    m_OnUse = 0X000740 // CEntityIOOutput
    m_iInputFilter = 0X000768 // int32
    m_iDontMessageParent = 0X00076C // int32

 CPathKeyFrame: [server.dll]
    m_Origin = 0X0004A0 // Vector
    m_Angles = 0X0004AC // QAngle
    m_qAngle = 0X0004C0 // Quaternion
    m_iNextKey = 0X0004D0 // CUtlSymbolLarge
    m_flNextTime = 0X0004D8 // float32
    m_pNextKey = 0X0004E0 // CPathKeyFrame*
    m_pPrevKey = 0X0004E8 // CPathKeyFrame*
    m_flSpeed = 0X0004F0 // float32

 CBaseMoveBehavior: [server.dll]
    m_iPositionInterpolator = 0X000500 // int32
    m_iRotationInterpolator = 0X000504 // int32
    m_flAnimStartTime = 0X000508 // float32
    m_flAnimEndTime = 0X00050C // float32
    m_flAverageSpeedAcrossFrame = 0X000510 // float32
    m_pCurrentKeyFrame = 0X000518 // CPathKeyFrame*
    m_pTargetKeyFrame = 0X000520 // CPathKeyFrame*
    m_pPreKeyFrame = 0X000528 // CPathKeyFrame*
    m_pPostKeyFrame = 0X000530 // CPathKeyFrame*
    m_flTimeIntoFrame = 0X000538 // float32
    m_iDirection = 0X00053C // int32

 CPathCorner: [server.dll]
    m_flWait = 0X0004A0 // float32
    m_flRadius = 0X0004A4 // float32
    m_OnPass = 0X0004A8 // CEntityIOOutput

 CPhysForce: [server.dll]
    m_nameAttach = 0X0004A8 // CUtlSymbolLarge
    m_force = 0X0004B0 // float32
    m_forceTime = 0X0004B4 // float32
    m_attachedObject = 0X0004B8 // CHandle< CBaseEntity >
    m_wasRestored = 0X0004BC // bool
    m_integrator = 0X0004C0 // CConstantForceController

 CPhysThruster: [server.dll]
    m_localOrigin = 0X000500 // Vector

 CPhysTorque: [server.dll]
    m_axis = 0X000500 // Vector

 CPhysMotor: [server.dll]
    m_nameAttach = 0X0004A0 // CUtlSymbolLarge
    m_hAttachedObject = 0X0004A8 // CHandle< CBaseEntity >
    m_spinUp = 0X0004AC // float32
    m_additionalAcceleration = 0X0004B0 // float32
    m_angularAcceleration = 0X0004B4 // float32
    m_lastTime = 0X0004B8 // GameTime_t
    m_motor = 0X0004D0 // CMotorController

 CKeepUpright: [server.dll]
    m_worldGoalAxis = 0X0004A8 // Vector
    m_localTestAxis = 0X0004B4 // Vector
    m_nameAttach = 0X0004C8 // CUtlSymbolLarge
    m_attachedObject = 0X0004D0 // CHandle< CBaseEntity >
    m_angularLimit = 0X0004D4 // float32
    m_bActive = 0X0004D8 // bool
    m_bDampAllRotation = 0X0004D9 // bool

 CPhysConstraint: [server.dll]
    m_nameAttach1 = 0X0004A8 // CUtlSymbolLarge
    m_nameAttach2 = 0X0004B0 // CUtlSymbolLarge
    m_breakSound = 0X0004B8 // CUtlSymbolLarge
    m_forceLimit = 0X0004C0 // float32
    m_torqueLimit = 0X0004C4 // float32
    m_teleportTick = 0X0004C8 // uint32
    m_minTeleportDistance = 0X0004CC // float32
    m_OnBreak = 0X0004D0 // CEntityIOOutput

 CPhysHinge: [server.dll]
    m_soundInfo = 0X000500 // ConstraintSoundInfo
    m_NotifyMinLimitReached = 0X000588 // CEntityIOOutput
    m_NotifyMaxLimitReached = 0X0005B0 // CEntityIOOutput
    m_bAtMinLimit = 0X0005D8 // bool
    m_bAtMaxLimit = 0X0005D9 // bool
    m_hinge = 0X0005DC // constraint_hingeparams_t
    m_hingeFriction = 0X00061C // float32
    m_systemLoadScale = 0X000620 // float32
    m_bIsAxisLocal = 0X000624 // bool
    m_flMinRotation = 0X000628 // float32
    m_flMaxRotation = 0X00062C // float32
    m_flInitialRotation = 0X000630 // float32
    m_flMotorFrequency = 0X000634 // float32
    m_flMotorDampingRatio = 0X000638 // float32
    m_flAngleSpeed = 0X00063C // float32
    m_flAngleSpeedThreshold = 0X000640 // float32
    m_OnStartMoving = 0X000648 // CEntityIOOutput
    m_OnStopMoving = 0X000670 // CEntityIOOutput

 CPhysHingeAlias_phys_hinge_local: [server.dll]
    No schemes available

 CPhysBallSocket: [server.dll]
    m_flFriction = 0X0004F8 // float32
    m_bEnableSwingLimit = 0X0004FC // bool
    m_flSwingLimit = 0X000500 // float32
    m_bEnableTwistLimit = 0X000504 // bool
    m_flMinTwistAngle = 0X000508 // float32
    m_flMaxTwistAngle = 0X00050C // float32

 CPhysSlideConstraint: [server.dll]
    m_axisEnd = 0X000500 // Vector
    m_slideFriction = 0X00050C // float32
    m_systemLoadScale = 0X000510 // float32
    m_initialOffset = 0X000514 // float32
    m_bEnableLinearConstraint = 0X000518 // bool
    m_bEnableAngularConstraint = 0X000519 // bool
    m_flMotorFrequency = 0X00051C // float32
    m_flMotorDampingRatio = 0X000520 // float32
    m_bUseEntityPivot = 0X000524 // bool
    m_soundInfo = 0X000528 // ConstraintSoundInfo

 CPhysFixed: [server.dll]
    m_flLinearFrequency = 0X0004F8 // float32
    m_flLinearDampingRatio = 0X0004FC // float32
    m_flAngularFrequency = 0X000500 // float32
    m_flAngularDampingRatio = 0X000504 // float32
    m_bEnableLinearConstraint = 0X000508 // bool
    m_bEnableAngularConstraint = 0X000509 // bool

 CPhysPulley: [server.dll]
    m_position2 = 0X0004F8 // Vector
    m_offset = 0X000504 // Vector[2]
    m_addLength = 0X00051C // float32
    m_gearRatio = 0X000520 // float32

 CPhysLength: [server.dll]
    m_offset = 0X0004F8 // Vector[2]
    m_vecAttach = 0X000510 // Vector
    m_addLength = 0X00051C // float32
    m_minLength = 0X000520 // float32
    m_totalLength = 0X000524 // float32
    m_bEnableCollision = 0X000528 // bool

 CRagdollConstraint: [server.dll]
    m_xmin = 0X0004F8 // float32
    m_xmax = 0X0004FC // float32
    m_ymin = 0X000500 // float32
    m_ymax = 0X000504 // float32
    m_zmin = 0X000508 // float32
    m_zmax = 0X00050C // float32
    m_xfriction = 0X000510 // float32
    m_yfriction = 0X000514 // float32
    m_zfriction = 0X000518 // float32

 CGenericConstraint: [server.dll]
    m_nLinearMotionX = 0X000500 // JointMotion_t
    m_nLinearMotionY = 0X000504 // JointMotion_t
    m_nLinearMotionZ = 0X000508 // JointMotion_t
    m_flLinearFrequencyX = 0X00050C // float32
    m_flLinearFrequencyY = 0X000510 // float32
    m_flLinearFrequencyZ = 0X000514 // float32
    m_flLinearDampingRatioX = 0X000518 // float32
    m_flLinearDampingRatioY = 0X00051C // float32
    m_flLinearDampingRatioZ = 0X000520 // float32
    m_flMaxLinearImpulseX = 0X000524 // float32
    m_flMaxLinearImpulseY = 0X000528 // float32
    m_flMaxLinearImpulseZ = 0X00052C // float32
    m_flBreakAfterTimeX = 0X000530 // float32
    m_flBreakAfterTimeY = 0X000534 // float32
    m_flBreakAfterTimeZ = 0X000538 // float32
    m_flBreakAfterTimeStartTimeX = 0X00053C // GameTime_t
    m_flBreakAfterTimeStartTimeY = 0X000540 // GameTime_t
    m_flBreakAfterTimeStartTimeZ = 0X000544 // GameTime_t
    m_flBreakAfterTimeThresholdX = 0X000548 // float32
    m_flBreakAfterTimeThresholdY = 0X00054C // float32
    m_flBreakAfterTimeThresholdZ = 0X000550 // float32
    m_flNotifyForceX = 0X000554 // float32
    m_flNotifyForceY = 0X000558 // float32
    m_flNotifyForceZ = 0X00055C // float32
    m_flNotifyForceMinTimeX = 0X000560 // float32
    m_flNotifyForceMinTimeY = 0X000564 // float32
    m_flNotifyForceMinTimeZ = 0X000568 // float32
    m_flNotifyForceLastTimeX = 0X00056C // GameTime_t
    m_flNotifyForceLastTimeY = 0X000570 // GameTime_t
    m_flNotifyForceLastTimeZ = 0X000574 // GameTime_t
    m_bAxisNotifiedX = 0X000578 // bool
    m_bAxisNotifiedY = 0X000579 // bool
    m_bAxisNotifiedZ = 0X00057A // bool
    m_nAngularMotionX = 0X00057C // JointMotion_t
    m_nAngularMotionY = 0X000580 // JointMotion_t
    m_nAngularMotionZ = 0X000584 // JointMotion_t
    m_flAngularFrequencyX = 0X000588 // float32
    m_flAngularFrequencyY = 0X00058C // float32
    m_flAngularFrequencyZ = 0X000590 // float32
    m_flAngularDampingRatioX = 0X000594 // float32
    m_flAngularDampingRatioY = 0X000598 // float32
    m_flAngularDampingRatioZ = 0X00059C // float32
    m_flMaxAngularImpulseX = 0X0005A0 // float32
    m_flMaxAngularImpulseY = 0X0005A4 // float32
    m_flMaxAngularImpulseZ = 0X0005A8 // float32
    m_NotifyForceReachedX = 0X0005B0 // CEntityIOOutput
    m_NotifyForceReachedY = 0X0005D8 // CEntityIOOutput
    m_NotifyForceReachedZ = 0X000600 // CEntityIOOutput

 CSplineConstraint: [server.dll]
    No schemes available

 CPhysWheelConstraint: [server.dll]
    m_flSuspensionFrequency = 0X0004F8 // float32
    m_flSuspensionDampingRatio = 0X0004FC // float32
    m_flSuspensionHeightOffset = 0X000500 // float32
    m_bEnableSuspensionLimit = 0X000504 // bool
    m_flMinSuspensionOffset = 0X000508 // float32
    m_flMaxSuspensionOffset = 0X00050C // float32
    m_bEnableSteeringLimit = 0X000510 // bool
    m_flMinSteeringAngle = 0X000514 // float32
    m_flMaxSteeringAngle = 0X000518 // float32
    m_flSteeringAxisFriction = 0X00051C // float32
    m_flSpinAxisFriction = 0X000520 // float32

 CPhysicsEntitySolver: [server.dll]
    m_hMovingEntity = 0X0004A8 // CHandle< CBaseEntity >
    m_hPhysicsBlocker = 0X0004AC // CHandle< CBaseEntity >
    m_separationDuration = 0X0004B0 // float32
    m_cancelTime = 0X0004B4 // GameTime_t

 CPhysicsSpring: [server.dll]
    m_flFrequency = 0X0004A8 // float32
    m_flDampingRatio = 0X0004AC // float32
    m_flRestLength = 0X0004B0 // float32
    m_nameAttachStart = 0X0004B8 // CUtlSymbolLarge
    m_nameAttachEnd = 0X0004C0 // CUtlSymbolLarge
    m_start = 0X0004C8 // Vector
    m_end = 0X0004D4 // Vector
    m_teleportTick = 0X0004E0 // uint32

 CPointPush: [server.dll]
    m_bEnabled = 0X0004A0 // bool
    m_flMagnitude = 0X0004A4 // float32
    m_flRadius = 0X0004A8 // float32
    m_flInnerRadius = 0X0004AC // float32
    m_flConeOfInfluence = 0X0004B0 // float32
    m_iszFilterName = 0X0004B8 // CUtlSymbolLarge
    m_hFilter = 0X0004C0 // CHandle< CBaseFilter >

 CInfoPlayerStart: [server.dll]
    m_bDisabled = 0X0004A0 // bool

 CPointEntityFinder: [server.dll]
    m_hEntity = 0X0004A0 // CHandle< CBaseEntity >
    m_iFilterName = 0X0004A8 // CUtlSymbolLarge
    m_hFilter = 0X0004B0 // CHandle< CBaseFilter >
    m_iRefName = 0X0004B8 // CUtlSymbolLarge
    m_hReference = 0X0004C0 // CHandle< CBaseEntity >
    m_FindMethod = 0X0004C4 // EntFinderMethod_t
    m_OnFoundEntity = 0X0004C8 // CEntityIOOutput

 CPointHMDAnchor: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_flEnableTime = 0X0004A4 // GameTime_t
    m_nPlayerIndex = 0X0004A8 // int32

 CPointHMDAnchorOverride: [server.dll]
    No schemes available

 CPointValueRemapper: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_bUpdateOnClient = 0X0004A1 // bool
    m_nInputType = 0X0004A4 // ValueRemapperInputType_t
    m_iszRemapLineStartName = 0X0004A8 // CUtlSymbolLarge
    m_iszRemapLineEndName = 0X0004B0 // CUtlSymbolLarge
    m_hRemapLineStart = 0X0004B8 // CHandle< CBaseEntity >
    m_hRemapLineEnd = 0X0004BC // CHandle< CBaseEntity >
    m_flMaximumChangePerSecond = 0X0004C0 // float32
    m_flDisengageDistance = 0X0004C4 // float32
    m_flEngageDistance = 0X0004C8 // float32
    m_bRequiresUseKey = 0X0004CC // bool
    m_nOutputType = 0X0004D0 // ValueRemapperOutputType_t
    m_iszOutputEntityName = 0X0004D8 // CUtlSymbolLarge
    m_iszOutputEntity2Name = 0X0004E0 // CUtlSymbolLarge
    m_iszOutputEntity3Name = 0X0004E8 // CUtlSymbolLarge
    m_iszOutputEntity4Name = 0X0004F0 // CUtlSymbolLarge
    m_hOutputEntities = 0X0004F8 // CNetworkUtlVectorBase< CHandle< CBaseEntity > >
    m_nHapticsType = 0X000510 // ValueRemapperHapticsType_t
    m_nMomentumType = 0X000514 // ValueRemapperMomentumType_t
    m_flMomentumModifier = 0X000518 // float32
    m_flSnapValue = 0X00051C // float32
    m_flCurrentMomentum = 0X000520 // float32
    m_nRatchetType = 0X000524 // ValueRemapperRatchetType_t
    m_flRatchetOffset = 0X000528 // float32
    m_flInputOffset = 0X00052C // float32
    m_bEngaged = 0X000530 // bool
    m_bFirstUpdate = 0X000531 // bool
    m_flPreviousValue = 0X000534 // float32
    m_flPreviousUpdateTickTime = 0X000538 // GameTime_t
    m_vecPreviousTestPoint = 0X00053C // Vector
    m_hUsingPlayer = 0X000548 // CHandle< CBasePlayerPawn >
    m_flCustomOutputValue = 0X00054C // float32
    m_iszSoundEngage = 0X000550 // CUtlSymbolLarge
    m_iszSoundDisengage = 0X000558 // CUtlSymbolLarge
    m_iszSoundReachedValueZero = 0X000560 // CUtlSymbolLarge
    m_iszSoundReachedValueOne = 0X000568 // CUtlSymbolLarge
    m_iszSoundMovingLoop = 0X000570 // CUtlSymbolLarge
    m_Position = 0X000580 // CEntityOutputTemplate< float32 >
    m_PositionDelta = 0X0005A8 // CEntityOutputTemplate< float32 >
    m_OnReachedValueZero = 0X0005D0 // CEntityIOOutput
    m_OnReachedValueOne = 0X0005F8 // CEntityIOOutput
    m_OnReachedValueCustom = 0X000620 // CEntityIOOutput
    m_OnEngage = 0X000648 // CEntityIOOutput
    m_OnDisengage = 0X000670 // CEntityIOOutput

 CPointWorldText: [server.dll]
    m_messageText = 0X0006F0 // char[512]
    m_FontName = 0X0008F0 // char[64]
    m_bEnabled = 0X000930 // bool
    m_bFullbright = 0X000931 // bool
    m_flWorldUnitsPerPx = 0X000934 // float32
    m_flFontSize = 0X000938 // float32
    m_flDepthOffset = 0X00093C // float32
    m_Color = 0X000940 // Color
    m_nJustifyHorizontal = 0X000944 // PointWorldTextJustifyHorizontal_t
    m_nJustifyVertical = 0X000948 // PointWorldTextJustifyVertical_t
    m_nReorientMode = 0X00094C // PointWorldTextReorientMode_t

 CPointAngleSensor: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_nLookAtName = 0X0004A8 // CUtlSymbolLarge
    m_hTargetEntity = 0X0004B0 // CHandle< CBaseEntity >
    m_hLookAtEntity = 0X0004B4 // CHandle< CBaseEntity >
    m_flDuration = 0X0004B8 // float32
    m_flDotTolerance = 0X0004BC // float32
    m_flFacingTime = 0X0004C0 // GameTime_t
    m_bFired = 0X0004C4 // bool
    m_OnFacingLookat = 0X0004C8 // CEntityIOOutput
    m_OnNotFacingLookat = 0X0004F0 // CEntityIOOutput
    m_TargetDir = 0X000518 // CEntityOutputTemplate< Vector >
    m_FacingPercentage = 0X000540 // CEntityOutputTemplate< float32 >

 CPointProximitySensor: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_hTargetEntity = 0X0004A4 // CHandle< CBaseEntity >
    m_Distance = 0X0004A8 // CEntityOutputTemplate< float32 >

 CPointAngularVelocitySensor: [server.dll]
    m_hTargetEntity = 0X0004A0 // CHandle< CBaseEntity >
    m_flThreshold = 0X0004A4 // float32
    m_nLastCompareResult = 0X0004A8 // int32
    m_nLastFireResult = 0X0004AC // int32
    m_flFireTime = 0X0004B0 // GameTime_t
    m_flFireInterval = 0X0004B4 // float32
    m_flLastAngVelocity = 0X0004B8 // float32
    m_lastOrientation = 0X0004BC // QAngle
    m_vecAxis = 0X0004C8 // Vector
    m_bUseHelper = 0X0004D4 // bool
    m_AngularVelocity = 0X0004D8 // CEntityOutputTemplate< float32 >
    m_OnLessThan = 0X000500 // CEntityIOOutput
    m_OnLessThanOrEqualTo = 0X000528 // CEntityIOOutput
    m_OnGreaterThan = 0X000550 // CEntityIOOutput
    m_OnGreaterThanOrEqualTo = 0X000578 // CEntityIOOutput
    m_OnEqualTo = 0X0005A0 // CEntityIOOutput

 CPointVelocitySensor: [server.dll]
    m_hTargetEntity = 0X0004A0 // CHandle< CBaseEntity >
    m_vecAxis = 0X0004A4 // Vector
    m_bEnabled = 0X0004B0 // bool
    m_fPrevVelocity = 0X0004B4 // float32
    m_flAvgInterval = 0X0004B8 // float32
    m_Velocity = 0X0004C0 // CEntityOutputTemplate< float32 >

 CPointHurt: [server.dll]
    m_nDamage = 0X0004A0 // int32
    m_bitsDamageType = 0X0004A4 // int32
    m_flRadius = 0X0004A8 // float32
    m_flDelay = 0X0004AC // float32
    m_strTarget = 0X0004B0 // CUtlSymbolLarge
    m_pActivator = 0X0004B8 // CHandle< CBaseEntity >

 CPointTeleport: [server.dll]
    m_vSaveOrigin = 0X0004A0 // Vector
    m_vSaveAngles = 0X0004AC // QAngle
    m_bTeleportParentedEntities = 0X0004B8 // bool

 CEnableMotionFixup: [server.dll]
    No schemes available

 CFuncPropRespawnZone: [server.dll]
    No schemes available

 CRagdollManager: [server.dll]
    m_iCurrentMaxRagdollCount = 0X0004A0 // int8
    m_iMaxRagdollCount = 0X0004A4 // int32
    m_bSaveImportant = 0X0004A8 // bool

 CRevertSaved: [server.dll]
    m_loadTime = 0X0006F0 // float32
    m_Duration = 0X0006F4 // float32
    m_HoldTime = 0X0006F8 // float32

 CSceneListManager: [server.dll]
    m_hListManagers = 0X0004A0 // CUtlVector< CHandle< CSceneListManager > >
    m_iszScenes = 0X0004B8 // CUtlSymbolLarge[16]
    m_hScenes = 0X000538 // CHandle< CBaseEntity >[16]

 CSceneEntity: [server.dll]
    m_iszSceneFile = 0X0004A8 // CUtlSymbolLarge
    m_iszResumeSceneFile = 0X0004B0 // CUtlSymbolLarge
    m_iszTarget1 = 0X0004B8 // CUtlSymbolLarge
    m_iszTarget2 = 0X0004C0 // CUtlSymbolLarge
    m_iszTarget3 = 0X0004C8 // CUtlSymbolLarge
    m_iszTarget4 = 0X0004D0 // CUtlSymbolLarge
    m_iszTarget5 = 0X0004D8 // CUtlSymbolLarge
    m_iszTarget6 = 0X0004E0 // CUtlSymbolLarge
    m_iszTarget7 = 0X0004E8 // CUtlSymbolLarge
    m_iszTarget8 = 0X0004F0 // CUtlSymbolLarge
    m_hTarget1 = 0X0004F8 // CHandle< CBaseEntity >
    m_hTarget2 = 0X0004FC // CHandle< CBaseEntity >
    m_hTarget3 = 0X000500 // CHandle< CBaseEntity >
    m_hTarget4 = 0X000504 // CHandle< CBaseEntity >
    m_hTarget5 = 0X000508 // CHandle< CBaseEntity >
    m_hTarget6 = 0X00050C // CHandle< CBaseEntity >
    m_hTarget7 = 0X000510 // CHandle< CBaseEntity >
    m_hTarget8 = 0X000514 // CHandle< CBaseEntity >
    m_bIsPlayingBack = 0X000518 // bool
    m_bPaused = 0X000519 // bool
    m_bMultiplayer = 0X00051A // bool
    m_bAutogenerated = 0X00051B // bool
    m_flForceClientTime = 0X00051C // float32
    m_flCurrentTime = 0X000520 // float32
    m_flFrameTime = 0X000524 // float32
    m_bCancelAtNextInterrupt = 0X000528 // bool
    m_fPitch = 0X00052C // float32
    m_bAutomated = 0X000530 // bool
    m_nAutomatedAction = 0X000534 // int32
    m_flAutomationDelay = 0X000538 // float32
    m_flAutomationTime = 0X00053C // float32
    m_hWaitingForThisResumeScene = 0X000540 // CHandle< CBaseEntity >
    m_bWaitingForResumeScene = 0X000544 // bool
    m_bPausedViaInput = 0X000545 // bool
    m_bPauseAtNextInterrupt = 0X000546 // bool
    m_bWaitingForActor = 0X000547 // bool
    m_bWaitingForInterrupt = 0X000548 // bool
    m_bInterruptedActorsScenes = 0X000549 // bool
    m_bBreakOnNonIdle = 0X00054A // bool
    m_hActorList = 0X000550 // CNetworkUtlVectorBase< CHandle< CBaseFlex > >
    m_hRemoveActorList = 0X000568 // CUtlVector< CHandle< CBaseEntity > >
    m_nSceneFlushCounter = 0X000590 // int32
    m_nSceneStringIndex = 0X000594 // uint16
    m_OnStart = 0X000598 // CEntityIOOutput
    m_OnCompletion = 0X0005C0 // CEntityIOOutput
    m_OnCanceled = 0X0005E8 // CEntityIOOutput
    m_OnPaused = 0X000610 // CEntityIOOutput
    m_OnResumed = 0X000638 // CEntityIOOutput
    m_OnTrigger = 0X000660 // CEntityIOOutput[16]
    m_hInterruptScene = 0X000970 // CHandle< CSceneEntity >
    m_nInterruptCount = 0X000974 // int32
    m_bSceneMissing = 0X000978 // bool
    m_bInterrupted = 0X000979 // bool
    m_bCompletedEarly = 0X00097A // bool
    m_bInterruptSceneFinished = 0X00097B // bool
    m_bRestoring = 0X00097C // bool
    m_hNotifySceneCompletion = 0X000980 // CUtlVector< CHandle< CSceneEntity > >
    m_hListManagers = 0X000998 // CUtlVector< CHandle< CSceneListManager > >
    m_iszSoundName = 0X0009D8 // CUtlSymbolLarge
    m_hActor = 0X0009E0 // CHandle< CBaseFlex >
    m_hActivator = 0X0009E4 // CHandle< CBaseEntity >
    m_hCamera = 0X0009E8 // CHandle< CBaseEntity >
    m_BusyActor = 0X0009EC // int32
    m_iPlayerDeathBehavior = 0X0009F0 // SceneOnPlayerDeath_t

 CScriptedSequence: [server.dll]
    m_iszEntry = 0X0004A0 // CUtlSymbolLarge
    m_iszPreIdle = 0X0004A8 // CUtlSymbolLarge
    m_iszPlay = 0X0004B0 // CUtlSymbolLarge
    m_iszPostIdle = 0X0004B8 // CUtlSymbolLarge
    m_iszModifierToAddOnPlay = 0X0004C0 // CUtlSymbolLarge
    m_iszNextScript = 0X0004C8 // CUtlSymbolLarge
    m_iszEntity = 0X0004D0 // CUtlSymbolLarge
    m_iszSyncGroup = 0X0004D8 // CUtlSymbolLarge
    m_nMoveTo = 0X0004E0 // ScriptedMoveTo_t
    m_bIsPlayingEntry = 0X0004E4 // bool
    m_bLoopActionSequence = 0X0004E5 // bool
    m_bSynchPostIdles = 0X0004E6 // bool
    m_bIgnoreGravity = 0X0004E7 // bool
    m_bDisableNPCCollisions = 0X0004E8 // bool
    m_bKeepAnimgraphLockedPost = 0X0004E9 // bool
    m_bDontAddModifiers = 0X0004EA // bool
    m_flRadius = 0X0004EC // float32
    m_flRepeat = 0X0004F0 // float32
    m_flPlayAnimFadeInTime = 0X0004F4 // float32
    m_flMoveInterpTime = 0X0004F8 // float32
    m_flAngRate = 0X0004FC // float32
    m_iDelay = 0X000500 // int32
    m_startTime = 0X000504 // GameTime_t
    m_bWaitForBeginSequence = 0X000508 // bool
    m_saved_effects = 0X00050C // int32
    m_savedFlags = 0X000510 // int32
    m_savedCollisionGroup = 0X000514 // int32
    m_interruptable = 0X000518 // bool
    m_sequenceStarted = 0X000519 // bool
    m_bPrevAnimatedEveryTick = 0X00051A // bool
    m_bForcedAnimatedEveryTick = 0X00051B // bool
    m_bPositionRelativeToOtherEntity = 0X00051C // bool
    m_hTargetEnt = 0X000520 // CHandle< CBaseEntity >
    m_hNextCine = 0X000524 // CHandle< CScriptedSequence >
    m_bThinking = 0X000528 // bool
    m_bInitiatedSelfDelete = 0X000529 // bool
    m_bIsTeleportingDueToMoveTo = 0X00052A // bool
    m_bAllowCustomInterruptConditions = 0X00052B // bool
    m_hLastFoundEntity = 0X00052C // CHandle< CBaseEntity >
    m_hForcedTarget = 0X000530 // CHandle< CBaseAnimGraph >
    m_bDontCancelOtherSequences = 0X000534 // bool
    m_bForceSynch = 0X000535 // bool
    m_bTargetWasAsleep = 0X000536 // bool
    m_bPreventUpdateYawOnFinish = 0X000537 // bool
    m_bEnsureOnNavmeshOnFinish = 0X000538 // bool
    m_onDeathBehavior = 0X00053C // ScriptedOnDeath_t
    m_ConflictResponse = 0X000540 // ScriptedConflictResponse_t
    m_OnBeginSequence = 0X000548 // CEntityIOOutput
    m_OnActionStartOrLoop = 0X000570 // CEntityIOOutput
    m_OnEndSequence = 0X000598 // CEntityIOOutput
    m_OnPostIdleEndSequence = 0X0005C0 // CEntityIOOutput
    m_OnCancelSequence = 0X0005E8 // CEntityIOOutput
    m_OnCancelFailedSequence = 0X000610 // CEntityIOOutput
    m_OnScriptEvent = 0X000638 // CEntityIOOutput[8]
    m_matOtherToMain = 0X000780 // CTransform
    m_hInteractionMainEntity = 0X0007A0 // CHandle< CBaseEntity >
    m_iPlayerDeathBehavior = 0X0007A4 // int32

 CSoundOpvarSetEntity: [server.dll]
    m_iszStackName = 0X0004A8 // CUtlSymbolLarge
    m_iszOperatorName = 0X0004B0 // CUtlSymbolLarge
    m_iszOpvarName = 0X0004B8 // CUtlSymbolLarge
    m_nOpvarType = 0X0004C0 // int32
    m_nOpvarIndex = 0X0004C4 // int32
    m_flOpvarValue = 0X0004C8 // float32
    m_OpvarValueString = 0X0004D0 // CUtlSymbolLarge
    m_bSetOnSpawn = 0X0004D8 // bool

 CAISound: [server.dll]
    m_iSoundType = 0X0004A0 // int32
    m_iSoundContext = 0X0004A4 // int32
    m_iVolume = 0X0004A8 // int32
    m_iSoundIndex = 0X0004AC // int32
    m_flDuration = 0X0004B0 // float32
    m_iszProxyEntityName = 0X0004B8 // CUtlSymbolLarge

 CSoundStackSave: [server.dll]
    m_iszStackName = 0X0004A0 // CUtlSymbolLarge

 CSoundEventEntity: [server.dll]
    m_bStartOnSpawn = 0X0004A0 // bool
    m_bToLocalPlayer = 0X0004A1 // bool
    m_bStopOnNew = 0X0004A2 // bool
    m_bSaveRestore = 0X0004A3 // bool
    m_bSavedIsPlaying = 0X0004A4 // bool
    m_flSavedElapsedTime = 0X0004A8 // float32
    m_iszSourceEntityName = 0X0004B0 // CUtlSymbolLarge
    m_iszAttachmentName = 0X0004B8 // CUtlSymbolLarge
    m_onGUIDChanged = 0X0004C0 // CEntityOutputTemplate< uint64 >
    m_onSoundFinished = 0X0004E8 // CEntityIOOutput
    m_iszSoundName = 0X000530 // CUtlSymbolLarge
    m_hSource = 0X000540 // CEntityHandle

 CSoundEventEntityAlias_snd_event_point: [server.dll]
    No schemes available

 CSoundEventAABBEntity: [server.dll]
    m_vMins = 0X000548 // Vector
    m_vMaxs = 0X000554 // Vector

 CSoundEventPathCornerEntity: [server.dll]
    m_iszPathCorner = 0X000548 // CUtlSymbolLarge
    m_iCountMax = 0X000550 // int32
    m_flDistanceMax = 0X000554 // float32
    m_flDistMaxSqr = 0X000558 // float32
    m_flDotProductMax = 0X00055C // float32
    bPlaying = 0X000560 // bool

 CSoundEventParameter: [server.dll]
    m_iszParamName = 0X0004A8 // CUtlSymbolLarge
    m_flFloatValue = 0X0004B0 // float32

 CEnvSoundscapeProxyAlias_snd_soundscape_proxy: [server.dll]
    No schemes available

 CEnvSoundscapeAlias_snd_soundscape: [server.dll]
    No schemes available

 CEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable: [server.dll]
    No schemes available

 CNullEntity: [server.dll]
    No schemes available

 CBaseDMStart: [server.dll]
    m_Master = 0X0004A0 // CUtlSymbolLarge

 CInfoLandmark: [server.dll]
    No schemes available

 CSun: [server.dll]
    m_vDirection = 0X0006F0 // Vector
    m_clrOverlay = 0X0006FC // Color
    m_iszEffectName = 0X000700 // CUtlSymbolLarge
    m_iszSSEffectName = 0X000708 // CUtlSymbolLarge
    m_bOn = 0X000710 // bool
    m_bmaxColor = 0X000711 // bool
    m_flSize = 0X000714 // float32
    m_flRotation = 0X000718 // float32
    m_flHazeScale = 0X00071C // float32
    m_flAlphaHaze = 0X000720 // float32
    m_flAlphaHdr = 0X000724 // float32
    m_flAlphaScale = 0X000728 // float32
    m_flHDRColorScale = 0X00072C // float32
    m_flFarZScale = 0X000730 // float32

 CTankTargetChange: [server.dll]
    m_newTarget = 0X0004A0 // CVariantBase< CVariantDefaultAllocator >
    m_newTargetName = 0X0004B0 // CUtlSymbolLarge

 CTankTrainAI: [server.dll]
    m_hTrain = 0X0004A0 // CHandle< CFuncTrackTrain >
    m_hTargetEntity = 0X0004A4 // CHandle< CBaseEntity >
    m_soundPlaying = 0X0004A8 // int32
    m_startSoundName = 0X0004C0 // CUtlSymbolLarge
    m_engineSoundName = 0X0004C8 // CUtlSymbolLarge
    m_movementSoundName = 0X0004D0 // CUtlSymbolLarge
    m_targetEntityName = 0X0004D8 // CUtlSymbolLarge

 CHandleTest: [server.dll]
    m_Handle = 0X0004A0 // CHandle< CBaseEntity >
    m_bSendHandle = 0X0004A4 // bool

 CHandleDummy: [server.dll]
    No schemes available

 CPlatTrigger: [server.dll]
    m_pPlatform = 0X0006F0 // CHandle< CFuncPlat >

 CFuncTrainControls: [server.dll]
    No schemes available

 CTriggerVolume: [server.dll]
    m_iFilterName = 0X0006F0 // CUtlSymbolLarge
    m_hFilter = 0X0006F8 // CHandle< CBaseFilter >

 CInfoTeleportDestination: [server.dll]
    No schemes available

 CAI_ChangeTarget: [server.dll]
    m_iszNewTarget = 0X0004A0 // CUtlSymbolLarge

 CAI_ChangeHintGroup: [server.dll]
    m_iSearchType = 0X0004A0 // int32
    m_strSearchName = 0X0004A8 // CUtlSymbolLarge
    m_strNewHintGroup = 0X0004B0 // CUtlSymbolLarge
    m_flRadius = 0X0004B8 // float32

 CLogicProximity: [server.dll]
    No schemes available

 CInfoSpawnGroupLandmark: [server.dll]
    No schemes available

 CInfoSpawnGroupLoadUnload: [server.dll]
    m_OnSpawnGroupLoadStarted = 0X0004A0 // CEntityIOOutput
    m_OnSpawnGroupLoadFinished = 0X0004C8 // CEntityIOOutput
    m_OnSpawnGroupUnloadStarted = 0X0004F0 // CEntityIOOutput
    m_OnSpawnGroupUnloadFinished = 0X000518 // CEntityIOOutput
    m_iszSpawnGroupName = 0X000540 // CUtlSymbolLarge
    m_iszSpawnGroupFilterName = 0X000548 // CUtlSymbolLarge
    m_iszLandmarkName = 0X000550 // CUtlSymbolLarge
    m_sFixedSpawnGroupName = 0X000558 // CUtlString
    m_flTimeoutInterval = 0X000560 // float32
    m_bStreamingStarted = 0X000564 // bool
    m_bUnloadingStarted = 0X000565 // bool

 CFuncNavObstruction: [server.dll]
    m_bDisabled = 0X0006F8 // bool

 CAmbientGeneric: [server.dll]
    m_radius = 0X0004A0 // float32
    m_flMaxRadius = 0X0004A4 // float32
    m_iSoundLevel = 0X0004A8 // soundlevel_t
    m_dpv = 0X0004AC // dynpitchvol_t
    m_fActive = 0X000510 // bool
    m_fLooping = 0X000511 // bool
    m_iszSound = 0X000518 // CUtlSymbolLarge
    m_sSourceEntName = 0X000520 // CUtlSymbolLarge
    m_hSoundSource = 0X000528 // CHandle< CBaseEntity >
    m_nSoundSourceEntIndex = 0X00052C // CEntityIndex

 RelationshipOverride_t: [server.dll]
    entity = 0X000008 // CHandle< CBaseEntity >
    classType = 0X00000C // Class_T

 CBaseToggle: [server.dll]
    m_toggle_state = 0X0006F0 // TOGGLE_STATE
    m_flMoveDistance = 0X0006F4 // float32
    m_flWait = 0X0006F8 // float32
    m_flLip = 0X0006FC // float32
    m_bAlwaysFireBlockedOutputs = 0X000700 // bool
    m_vecPosition1 = 0X000704 // Vector
    m_vecPosition2 = 0X000710 // Vector
    m_vecMoveAng = 0X00071C // QAngle
    m_vecAngle1 = 0X000728 // QAngle
    m_vecAngle2 = 0X000734 // QAngle
    m_flHeight = 0X000740 // float32
    m_hActivator = 0X000744 // CHandle< CBaseEntity >
    m_vecFinalDest = 0X000748 // Vector
    m_vecFinalAngle = 0X000754 // QAngle
    m_movementType = 0X000760 // int32
    m_sMaster = 0X000768 // CUtlSymbolLarge

 CBaseButton: [server.dll]
    m_angMoveEntitySpace = 0X000770 // QAngle
    m_fStayPushed = 0X00077C // bool
    m_fRotating = 0X00077D // bool
    m_ls = 0X000780 // locksound_t
    m_sUseSound = 0X0007A0 // CUtlSymbolLarge
    m_sLockedSound = 0X0007A8 // CUtlSymbolLarge
    m_sUnlockedSound = 0X0007B0 // CUtlSymbolLarge
    m_bLocked = 0X0007B8 // bool
    m_bDisabled = 0X0007B9 // bool
    m_flUseLockedTime = 0X0007BC // GameTime_t
    m_bSolidBsp = 0X0007C0 // bool
    m_OnDamaged = 0X0007C8 // CEntityIOOutput
    m_OnPressed = 0X0007F0 // CEntityIOOutput
    m_OnUseLocked = 0X000818 // CEntityIOOutput
    m_OnIn = 0X000840 // CEntityIOOutput
    m_OnOut = 0X000868 // CEntityIOOutput
    m_nState = 0X000890 // int32
    m_hConstraint = 0X000894 // CEntityHandle
    m_hConstraintParent = 0X000898 // CEntityHandle
    m_bForceNpcExclude = 0X00089C // bool
    m_sGlowEntity = 0X0008A0 // CUtlSymbolLarge
    m_glowEntity = 0X0008A8 // CHandle< CBaseModelEntity >
    m_usable = 0X0008AC // bool
    m_szDisplayText = 0X0008B0 // CUtlSymbolLarge

 CPhysicalButton: [server.dll]
    No schemes available

 CRotButton: [server.dll]
    No schemes available

 CMomentaryRotButton: [server.dll]
    m_Position = 0X0008B8 // CEntityOutputTemplate< float32 >
    m_OnUnpressed = 0X0008E0 // CEntityIOOutput
    m_OnFullyOpen = 0X000908 // CEntityIOOutput
    m_OnFullyClosed = 0X000930 // CEntityIOOutput
    m_OnReachedPosition = 0X000958 // CEntityIOOutput
    m_lastUsed = 0X000980 // int32
    m_start = 0X000984 // QAngle
    m_end = 0X000990 // QAngle
    m_IdealYaw = 0X00099C // float32
    m_sNoise = 0X0009A0 // CUtlSymbolLarge
    m_bUpdateTarget = 0X0009A8 // bool
    m_direction = 0X0009AC // int32
    m_returnSpeed = 0X0009B0 // float32
    m_flStartPosition = 0X0009B4 // float32

 CRagdollMagnet: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_radius = 0X0004A4 // float32
    m_force = 0X0004A8 // float32
    m_axis = 0X0004AC // Vector

 CBaseDoor: [server.dll]
    m_angMoveEntitySpace = 0X000780 // QAngle
    m_vecMoveDirParentSpace = 0X00078C // Vector
    m_ls = 0X000798 // locksound_t
    m_bForceClosed = 0X0007B8 // bool
    m_bDoorGroup = 0X0007B9 // bool
    m_bLocked = 0X0007BA // bool
    m_bIgnoreDebris = 0X0007BB // bool
    m_eSpawnPosition = 0X0007BC // FuncDoorSpawnPos_t
    m_flBlockDamage = 0X0007C0 // float32
    m_NoiseMoving = 0X0007C8 // CUtlSymbolLarge
    m_NoiseArrived = 0X0007D0 // CUtlSymbolLarge
    m_NoiseMovingClosed = 0X0007D8 // CUtlSymbolLarge
    m_NoiseArrivedClosed = 0X0007E0 // CUtlSymbolLarge
    m_ChainTarget = 0X0007E8 // CUtlSymbolLarge
    m_OnBlockedClosing = 0X0007F0 // CEntityIOOutput
    m_OnBlockedOpening = 0X000818 // CEntityIOOutput
    m_OnUnblockedClosing = 0X000840 // CEntityIOOutput
    m_OnUnblockedOpening = 0X000868 // CEntityIOOutput
    m_OnFullyClosed = 0X000890 // CEntityIOOutput
    m_OnFullyOpen = 0X0008B8 // CEntityIOOutput
    m_OnClose = 0X0008E0 // CEntityIOOutput
    m_OnOpen = 0X000908 // CEntityIOOutput
    m_OnLockedUse = 0X000930 // CEntityIOOutput
    m_bLoopMoveSound = 0X000958 // bool
    m_bCreateNavObstacle = 0X000970 // bool
    m_isChaining = 0X000971 // bool
    m_bIsUsable = 0X000972 // bool

 CEntityBlocker: [server.dll]
    No schemes available

 CEntityDissolve: [server.dll]
    m_flFadeInStart = 0X0006F0 // float32
    m_flFadeInLength = 0X0006F4 // float32
    m_flFadeOutModelStart = 0X0006F8 // float32
    m_flFadeOutModelLength = 0X0006FC // float32
    m_flFadeOutStart = 0X000700 // float32
    m_flFadeOutLength = 0X000704 // float32
    m_flStartTime = 0X000708 // GameTime_t
    m_nDissolveType = 0X00070C // EntityDisolveType_t
    m_vDissolverOrigin = 0X000710 // Vector
    m_nMagnitude = 0X00071C // uint32

 CEnvProjectedTexture: [server.dll]
    m_hTargetEntity = 0X0006F0 // CHandle< CBaseEntity >
    m_bState = 0X0006F4 // bool
    m_bAlwaysUpdate = 0X0006F5 // bool
    m_flLightFOV = 0X0006F8 // float32
    m_bEnableShadows = 0X0006FC // bool
    m_bSimpleProjection = 0X0006FD // bool
    m_bLightOnlyTarget = 0X0006FE // bool
    m_bLightWorld = 0X0006FF // bool
    m_bCameraSpace = 0X000700 // bool
    m_flBrightnessScale = 0X000704 // float32
    m_LightColor = 0X000708 // Color
    m_flIntensity = 0X00070C // float32
    m_flLinearAttenuation = 0X000710 // float32
    m_flQuadraticAttenuation = 0X000714 // float32
    m_bVolumetric = 0X000718 // bool
    m_flNoiseStrength = 0X00071C // float32
    m_flFlashlightTime = 0X000720 // float32
    m_nNumPlanes = 0X000724 // uint32
    m_flPlaneOffset = 0X000728 // float32
    m_flVolumetricIntensity = 0X00072C // float32
    m_flColorTransitionTime = 0X000730 // float32
    m_flAmbient = 0X000734 // float32
    m_SpotlightTextureName = 0X000738 // char[512]
    m_nSpotlightTextureFrame = 0X000938 // int32
    m_nShadowQuality = 0X00093C // uint32
    m_flNearZ = 0X000940 // float32
    m_flFarZ = 0X000944 // float32
    m_flProjectionSize = 0X000948 // float32
    m_flRotation = 0X00094C // float32
    m_bFlipHorizontal = 0X000950 // bool

 CEnvDecal: [server.dll]
    m_hDecalMaterial = 0X0006F0 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_flWidth = 0X0006F8 // float32
    m_flHeight = 0X0006FC // float32
    m_flDepth = 0X000700 // float32
    m_nRenderOrder = 0X000704 // uint32
    m_bProjectOnWorld = 0X000708 // bool
    m_bProjectOnCharacters = 0X000709 // bool
    m_bProjectOnWater = 0X00070A // bool
    m_flDepthSortBias = 0X00070C // float32

 CMessage: [server.dll]
    m_iszMessage = 0X0004A0 // CUtlSymbolLarge
    m_MessageVolume = 0X0004A8 // float32
    m_MessageAttenuation = 0X0004AC // int32
    m_Radius = 0X0004B0 // float32
    m_sNoise = 0X0004B8 // CUtlSymbolLarge
    m_OnShowMessage = 0X0004C0 // CEntityIOOutput

 CEnvMicrophone: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_hMeasureTarget = 0X0004A4 // CHandle< CBaseEntity >
    m_nSoundMask = 0X0004A8 // int32
    m_flSensitivity = 0X0004AC // float32
    m_flSmoothFactor = 0X0004B0 // float32
    m_flMaxRange = 0X0004B4 // float32
    m_iszSpeakerName = 0X0004B8 // CUtlSymbolLarge
    m_hSpeaker = 0X0004C0 // CHandle< CBaseEntity >
    m_bAvoidFeedback = 0X0004C4 // bool
    m_iSpeakerDSPPreset = 0X0004C8 // int32
    m_iszListenFilter = 0X0004D0 // CUtlSymbolLarge
    m_hListenFilter = 0X0004D8 // CHandle< CBaseFilter >
    m_SoundLevel = 0X0004E0 // CEntityOutputTemplate< float32 >
    m_OnRoutedSound = 0X000508 // CEntityIOOutput
    m_OnHeardSound = 0X000530 // CEntityIOOutput
    m_szLastSound = 0X000558 // char[256]
    m_iLastRoutedFrame = 0X000658 // int32

 CBreakable: [server.dll]
    m_Material = 0X000700 // Materials
    m_hBreaker = 0X000704 // CHandle< CBaseEntity >
    m_Explosion = 0X000708 // Explosions
    m_iszSpawnObject = 0X000710 // CUtlSymbolLarge
    m_flPressureDelay = 0X000718 // float32
    m_iMinHealthDmg = 0X00071C // int32
    m_iszPropData = 0X000720 // CUtlSymbolLarge
    m_impactEnergyScale = 0X000728 // float32
    m_nOverrideBlockLOS = 0X00072C // EOverrideBlockLOS_t
    m_OnBreak = 0X000730 // CEntityIOOutput
    m_OnHealthChanged = 0X000758 // CEntityOutputTemplate< float32 >
    m_flDmgModBullet = 0X000780 // float32
    m_flDmgModClub = 0X000784 // float32
    m_flDmgModExplosive = 0X000788 // float32
    m_flDmgModFire = 0X00078C // float32
    m_iszPhysicsDamageTableName = 0X000790 // CUtlSymbolLarge
    m_iszBasePropData = 0X000798 // CUtlSymbolLarge
    m_iInteractions = 0X0007A0 // int32
    m_PerformanceMode = 0X0007A4 // PerformanceMode_t
    m_hPhysicsAttacker = 0X0007A8 // CHandle< CBasePlayerPawn >
    m_flLastPhysicsInfluenceTime = 0X0007AC // GameTime_t

 CFuncMoveLinear: [server.dll]
    m_authoredPosition = 0X000770 // MoveLinearAuthoredPos_t
    m_angMoveEntitySpace = 0X000774 // QAngle
    m_vecMoveDirParentSpace = 0X000780 // Vector
    m_soundStart = 0X000790 // CUtlSymbolLarge
    m_soundStop = 0X000798 // CUtlSymbolLarge
    m_currentSound = 0X0007A0 // CUtlSymbolLarge
    m_flBlockDamage = 0X0007A8 // float32
    m_flStartPosition = 0X0007AC // float32
    m_flMoveDistance = 0X0007B0 // float32
    m_OnFullyOpen = 0X0007C0 // CEntityIOOutput
    m_OnFullyClosed = 0X0007E8 // CEntityIOOutput
    m_bCreateNavObstacle = 0X000810 // bool

 CFuncRotating: [server.dll]
    m_vecMoveAng = 0X0006F0 // QAngle
    m_flFanFriction = 0X0006FC // float32
    m_flAttenuation = 0X000700 // float32
    m_flVolume = 0X000704 // float32
    m_flTargetSpeed = 0X000708 // float32
    m_flMaxSpeed = 0X00070C // float32
    m_flBlockDamage = 0X000710 // float32
    m_flTimeScale = 0X000714 // float32
    m_NoiseRunning = 0X000718 // CUtlSymbolLarge
    m_bReversed = 0X000720 // bool
    m_angStart = 0X00072C // QAngle
    m_bStopAtStartPos = 0X000738 // bool
    m_vecClientOrigin = 0X00073C // Vector
    m_vecClientAngles = 0X000748 // QAngle

 CItemGenericTriggerHelper: [server.dll]
    m_hParentItem = 0X0006F0 // CHandle< CItemGeneric >

 CMarkupVolume: [server.dll]
    m_bEnabled = 0X0006F0 // bool

 CMarkupVolumeTagged: [server.dll]
    m_bIsGroup = 0X000728 // bool
    m_bGroupByPrefab = 0X000729 // bool
    m_bGroupByVolume = 0X00072A // bool
    m_bGroupOtherGroups = 0X00072B // bool
    m_bIsInGroup = 0X00072C // bool

 CMarkupVolumeWithRef: [server.dll]
    m_bUseRef = 0X000730 // bool
    m_vRefPos = 0X000734 // Vector
    m_flRefDot = 0X000740 // float32

 CFuncBrush: [server.dll]
    m_iSolidity = 0X0006F0 // BrushSolidities_e
    m_iDisabled = 0X0006F4 // int32
    m_bSolidBsp = 0X0006F8 // bool
    m_iszExcludedClass = 0X000700 // CUtlSymbolLarge
    m_bInvertExclusion = 0X000708 // bool
    m_bScriptedMovement = 0X000709 // bool

 CPathTrack: [server.dll]
    m_pnext = 0X0004A0 // CPathTrack*
    m_pprevious = 0X0004A8 // CPathTrack*
    m_paltpath = 0X0004B0 // CPathTrack*
    m_flRadius = 0X0004B8 // float32
    m_length = 0X0004BC // float32
    m_altName = 0X0004C0 // CUtlSymbolLarge
    m_nIterVal = 0X0004C8 // int32
    m_eOrientationType = 0X0004CC // TrackOrientationType_t
    m_OnPass = 0X0004D0 // CEntityIOOutput

 CPhysBox: [server.dll]
    m_damageType = 0X0007B0 // int32
    m_massScale = 0X0007B4 // float32
    m_damageToEnableMotion = 0X0007B8 // int32
    m_flForceToEnableMotion = 0X0007BC // float32
    m_angPreferredCarryAngles = 0X0007C0 // QAngle
    m_bNotSolidToWorld = 0X0007CC // bool
    m_bEnableUseOutput = 0X0007CD // bool
    m_iExploitableByPlayer = 0X0007D0 // int32
    m_flTouchOutputPerEntityDelay = 0X0007D4 // float32
    m_OnDamaged = 0X0007D8 // CEntityIOOutput
    m_OnAwakened = 0X000800 // CEntityIOOutput
    m_OnMotionEnabled = 0X000828 // CEntityIOOutput
    m_OnPlayerUse = 0X000850 // CEntityIOOutput
    m_OnStartTouch = 0X000878 // CEntityIOOutput
    m_hCarryingPlayer = 0X0008A0 // CHandle< CBasePlayerPawn >

 CPhysExplosion: [server.dll]
    m_bExplodeOnSpawn = 0X0004A0 // bool
    m_flMagnitude = 0X0004A4 // float32
    m_flDamage = 0X0004A8 // float32
    m_radius = 0X0004AC // float32
    m_targetEntityName = 0X0004B0 // CUtlSymbolLarge
    m_flInnerRadius = 0X0004B8 // float32
    m_flPushScale = 0X0004BC // float32
    m_bConvertToDebrisWhenPossible = 0X0004C0 // bool
    m_OnPushedPlayer = 0X0004C8 // CEntityIOOutput

 CPhysImpact: [server.dll]
    m_damage = 0X0004A0 // float32
    m_distance = 0X0004A4 // float32
    m_directionEntityName = 0X0004A8 // CUtlSymbolLarge

 CRopeKeyframe: [server.dll]
    m_RopeFlags = 0X0006F8 // uint16
    m_iNextLinkName = 0X000700 // CUtlSymbolLarge
    m_Slack = 0X000708 // int16
    m_Width = 0X00070C // float32
    m_TextureScale = 0X000710 // float32
    m_nSegments = 0X000714 // uint8
    m_bConstrainBetweenEndpoints = 0X000715 // bool
    m_strRopeMaterialModel = 0X000718 // CUtlSymbolLarge
    m_iRopeMaterialModelIndex = 0X000720 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_Subdiv = 0X000728 // uint8
    m_nChangeCount = 0X000729 // uint8
    m_RopeLength = 0X00072A // int16
    m_fLockedPoints = 0X00072C // uint8
    m_bCreatedFromMapFile = 0X00072D // bool
    m_flScrollSpeed = 0X000730 // float32
    m_bStartPointValid = 0X000734 // bool
    m_bEndPointValid = 0X000735 // bool
    m_hStartPoint = 0X000738 // CHandle< CBaseEntity >
    m_hEndPoint = 0X00073C // CHandle< CBaseEntity >
    m_iStartAttachment = 0X000740 // AttachmentHandle_t
    m_iEndAttachment = 0X000741 // AttachmentHandle_t

 CSoundEnt: [server.dll]
    m_iFreeSound = 0X0004A0 // int32
    m_iActiveSound = 0X0004A4 // int32
    m_cLastActiveSounds = 0X0004A8 // int32
    m_SoundPool = 0X0004AC // CSound[128]

 CSpotlightEnd: [server.dll]
    m_flLightScale = 0X0006F0 // float32
    m_Radius = 0X0006F4 // float32
    m_vSpotlightDir = 0X0006F8 // Vector
    m_vSpotlightOrg = 0X000704 // Vector

 CFuncTrackTrain: [server.dll]
    m_ppath = 0X0006F0 // CHandle< CPathTrack >
    m_length = 0X0006F4 // float32
    m_controlMins = 0X0006F8 // Vector
    m_controlMaxs = 0X000704 // Vector
    m_lastBlockPos = 0X000710 // Vector
    m_lastBlockTick = 0X00071C // int32
    m_flVolume = 0X000720 // float32
    m_flBank = 0X000724 // float32
    m_oldSpeed = 0X000728 // float32
    m_flBlockDamage = 0X00072C // float32
    m_height = 0X000730 // float32
    m_maxSpeed = 0X000734 // float32
    m_dir = 0X000738 // float32
    m_iszSoundMove = 0X000740 // CUtlSymbolLarge
    m_iszSoundMovePing = 0X000748 // CUtlSymbolLarge
    m_iszSoundStart = 0X000750 // CUtlSymbolLarge
    m_iszSoundStop = 0X000758 // CUtlSymbolLarge
    m_strPathTarget = 0X000760 // CUtlSymbolLarge
    m_flMoveSoundMinDuration = 0X000768 // float32
    m_flMoveSoundMaxDuration = 0X00076C // float32
    m_flNextMoveSoundTime = 0X000770 // GameTime_t
    m_flMoveSoundMinPitch = 0X000774 // float32
    m_flMoveSoundMaxPitch = 0X000778 // float32
    m_eOrientationType = 0X00077C // TrainOrientationType_t
    m_eVelocityType = 0X000780 // TrainVelocityType_t
    m_OnStart = 0X000790 // CEntityIOOutput
    m_OnNext = 0X0007B8 // CEntityIOOutput
    m_OnArrivedAtDestinationNode = 0X0007E0 // CEntityIOOutput
    m_bManualSpeedChanges = 0X000808 // bool
    m_flDesiredSpeed = 0X00080C // float32
    m_flSpeedChangeTime = 0X000810 // GameTime_t
    m_flAccelSpeed = 0X000814 // float32
    m_flDecelSpeed = 0X000818 // float32
    m_bAccelToSpeed = 0X00081C // bool
    m_flTimeScale = 0X000820 // float32
    m_flNextMPSoundTime = 0X000824 // GameTime_t

 CBaseTrigger: [server.dll]
    m_bDisabled = 0X000770 // bool
    m_iFilterName = 0X000778 // CUtlSymbolLarge
    m_hFilter = 0X000780 // CHandle< CBaseFilter >
    m_OnStartTouch = 0X000788 // CEntityIOOutput
    m_OnStartTouchAll = 0X0007B0 // CEntityIOOutput
    m_OnEndTouch = 0X0007D8 // CEntityIOOutput
    m_OnEndTouchAll = 0X000800 // CEntityIOOutput
    m_OnTouching = 0X000828 // CEntityIOOutput
    m_OnNotTouching = 0X000850 // CEntityIOOutput
    m_hTouchingEntities = 0X000878 // CUtlVector< CHandle< CBaseEntity > >
    m_bClientSidePredicted = 0X000890 // bool

 CTriggerMultiple: [server.dll]
    m_OnTrigger = 0X000898 // CEntityIOOutput

 CTriggerSndSosOpvar: [server.dll]
    m_hTouchingPlayers = 0X000898 // CUtlVector< CHandle< CBaseEntity > >
    m_flPosition = 0X0008B0 // Vector
    m_flCenterSize = 0X0008BC // float32
    m_flMinVal = 0X0008C0 // float32
    m_flMaxVal = 0X0008C4 // float32
    m_flWait = 0X0008C8 // float32
    m_opvarName = 0X0008D0 // CUtlSymbolLarge
    m_stackName = 0X0008D8 // CUtlSymbolLarge
    m_operatorName = 0X0008E0 // CUtlSymbolLarge
    m_bVolIs2D = 0X0008E8 // bool
    m_opvarNameChar = 0X0008E9 // char[256]
    m_stackNameChar = 0X0009E9 // char[256]
    m_operatorNameChar = 0X000AE9 // char[256]
    m_VecNormPos = 0X000BEC // Vector
    m_flNormCenterSize = 0X000BF8 // float32

 CTriggerHurt: [server.dll]
    m_flOriginalDamage = 0X000898 // float32
    m_flDamage = 0X00089C // float32
    m_flDamageCap = 0X0008A0 // float32
    m_flLastDmgTime = 0X0008A4 // GameTime_t
    m_flForgivenessDelay = 0X0008A8 // float32
    m_bitsDamageInflict = 0X0008AC // int32
    m_damageModel = 0X0008B0 // int32
    m_bNoDmgForce = 0X0008B4 // bool
    m_vDamageForce = 0X0008B8 // Vector
    m_thinkAlways = 0X0008C4 // bool
    m_hurtThinkPeriod = 0X0008C8 // float32
    m_OnHurt = 0X0008D0 // CEntityIOOutput
    m_OnHurtPlayer = 0X0008F8 // CEntityIOOutput
    m_hurtEntities = 0X000920 // CUtlVector< CHandle< CBaseEntity > >

 CTriggerHurtGhost: [server.dll]
    No schemes available

 CTriggerCallback: [server.dll]
    No schemes available

 CTriggerLerpObject: [server.dll]
    m_iszLerpTarget = 0X000898 // CUtlSymbolLarge
    m_hLerpTarget = 0X0008A0 // CHandle< CBaseEntity >
    m_iszLerpTargetAttachment = 0X0008A8 // CUtlSymbolLarge
    m_hLerpTargetAttachment = 0X0008B0 // AttachmentHandle_t
    m_flLerpDuration = 0X0008B4 // float32
    m_bLerpRestoreMoveType = 0X0008B8 // bool
    m_bSingleLerpObject = 0X0008B9 // bool
    m_vecLerpingObjects = 0X0008C0 // CUtlVector< lerpdata_t >
    m_iszLerpEffect = 0X0008D8 // CUtlSymbolLarge
    m_iszLerpSound = 0X0008E0 // CUtlSymbolLarge
    m_OnLerpStarted = 0X0008E8 // CEntityIOOutput
    m_OnLerpFinished = 0X000910 // CEntityIOOutput

 CChangeLevel: [server.dll]
    m_sMapName = 0X000898 // CUtlString
    m_sLandmarkName = 0X0008A0 // CUtlString
    m_OnChangeLevel = 0X0008A8 // CEntityIOOutput
    m_bTouched = 0X0008D0 // bool
    m_bNoTouch = 0X0008D1 // bool
    m_bNewChapter = 0X0008D2 // bool
    m_bOnChangeLevelFired = 0X0008D3 // bool

 CTriggerTeleport: [server.dll]
    m_iLandmark = 0X000898 // CUtlSymbolLarge
    m_bUseLandmarkAngles = 0X0008A0 // bool
    m_bMirrorPlayer = 0X0008A1 // bool

 CTriggerFan: [server.dll]
    m_vFanOrigin = 0X000898 // Vector
    m_vFanEnd = 0X0008A4 // Vector
    m_vNoise = 0X0008B0 // Vector
    m_flForce = 0X0008BC // float32
    m_flPlayerForce = 0X0008C0 // float32
    m_flRampTime = 0X0008C4 // float32
    m_bFalloff = 0X0008C8 // bool
    m_bPushPlayer = 0X0008C9 // bool
    m_bRampDown = 0X0008CA // bool
    m_bAddNoise = 0X0008CB // bool
    m_RampTimer = 0X0008D0 // CountdownTimer

 CTriggerBuoyancy: [server.dll]
    m_BuoyancyHelper = 0X000898 // CBuoyancyHelper
    m_flFluidDensity = 0X0008E0 // float32

 CNavWalkable: [server.dll]
    No schemes available

 CFuncNavBlocker: [server.dll]
    m_bDisabled = 0X0006F0 // bool
    m_nBlockedTeamNumber = 0X0006F4 // int32

 CNavLinkAreaEntity: [server.dll]
    m_flWidth = 0X0004A0 // float32
    m_vLocatorOffset = 0X0004A4 // Vector
    m_qLocatorAnglesOffset = 0X0004B0 // QAngle
    m_strMovementForward = 0X0004C0 // CUtlSymbolLarge
    m_strMovementReverse = 0X0004C8 // CUtlSymbolLarge
    m_nNavLinkIdForward = 0X0004D0 // int32
    m_nNavLinkIdReverse = 0X0004D4 // int32
    m_bEnabled = 0X0004D8 // bool
    m_strFilterName = 0X0004E0 // CUtlSymbolLarge
    m_hFilter = 0X0004E8 // CHandle< CBaseFilter >
    m_OnNavLinkStart = 0X0004F0 // CEntityIOOutput
    m_OnNavLinkFinish = 0X000518 // CEntityIOOutput

 CNavSpaceInfo: [server.dll]
    m_bCreateTacticalConnections = 0X0004A0 // bool
    m_bCreateFlightSpace = 0X0004A1 // bool
    m_flPhysicsOverheadBufferDist = 0X0004A4 // float32

 CBeam: [server.dll]
    m_flFrameRate = 0X0006F0 // float32
    m_flHDRColorScale = 0X0006F4 // float32
    m_flFireTime = 0X0006F8 // GameTime_t
    m_flDamage = 0X0006FC // float32
    m_nNumBeamEnts = 0X000700 // uint8
    m_hBaseMaterial = 0X000708 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_nHaloIndex = 0X000710 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_nBeamType = 0X000718 // BeamType_t
    m_nBeamFlags = 0X00071C // uint32
    m_hAttachEntity = 0X000720 // CHandle< CBaseEntity >[10]
    m_nAttachIndex = 0X000748 // AttachmentHandle_t[10]
    m_fWidth = 0X000754 // float32
    m_fEndWidth = 0X000758 // float32
    m_fFadeLength = 0X00075C // float32
    m_fHaloScale = 0X000760 // float32
    m_fAmplitude = 0X000764 // float32
    m_fStartFrame = 0X000768 // float32
    m_fSpeed = 0X00076C // float32
    m_flFrame = 0X000770 // float32
    m_nClipStyle = 0X000774 // BeamClipStyle_t
    m_bTurnedOff = 0X000778 // bool
    m_vecEndPos = 0X00077C // Vector
    m_hEndEntity = 0X000788 // CHandle< CBaseEntity >
    m_nDissolveType = 0X00078C // int32

 CFuncLadder: [server.dll]
    m_vecLadderDir = 0X0006F0 // Vector
    m_Dismounts = 0X000700 // CUtlVector< CHandle< CInfoLadderDismount > >
    m_vecLocalTop = 0X000718 // Vector
    m_vecPlayerMountPositionTop = 0X000724 // Vector
    m_vecPlayerMountPositionBottom = 0X000730 // Vector
    m_flAutoRideSpeed = 0X00073C // float32
    m_bDisabled = 0X000740 // bool
    m_bFakeLadder = 0X000741 // bool
    m_bHasSlack = 0X000742 // bool
    m_surfacePropName = 0X000748 // CUtlSymbolLarge
    m_OnPlayerGotOnLadder = 0X000750 // CEntityIOOutput
    m_OnPlayerGotOffLadder = 0X000778 // CEntityIOOutput

 CFuncShatterglass: [server.dll]
    m_hGlassMaterialDamaged = 0X0006F0 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_hGlassMaterialUndamaged = 0X0006F8 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_hConcreteMaterialEdgeFace = 0X000700 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_hConcreteMaterialEdgeCaps = 0X000708 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_hConcreteMaterialEdgeFins = 0X000710 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_matPanelTransform = 0X000718 // matrix3x4_t
    m_matPanelTransformWsTemp = 0X000748 // matrix3x4_t
    m_vecShatterGlassShards = 0X000778 // CUtlVector< uint32 >
    m_PanelSize = 0X000790 // Vector2D
    m_vecPanelNormalWs = 0X000798 // Vector
    m_nNumShardsEverCreated = 0X0007A4 // int32
    m_flLastShatterSoundEmitTime = 0X0007A8 // GameTime_t
    m_flLastCleanupTime = 0X0007AC // GameTime_t
    m_flInitAtTime = 0X0007B0 // GameTime_t
    m_flGlassThickness = 0X0007B4 // float32
    m_flSpawnInvulnerability = 0X0007B8 // float32
    m_bBreakSilent = 0X0007BC // bool
    m_bBreakShardless = 0X0007BD // bool
    m_bBroken = 0X0007BE // bool
    m_bHasRateLimitedShards = 0X0007BF // bool
    m_bGlassNavIgnore = 0X0007C0 // bool
    m_bGlassInFrame = 0X0007C1 // bool
    m_bStartBroken = 0X0007C2 // bool
    m_iInitialDamageType = 0X0007C3 // uint8
    m_szDamagePositioningEntityName01 = 0X0007C8 // CUtlSymbolLarge
    m_szDamagePositioningEntityName02 = 0X0007D0 // CUtlSymbolLarge
    m_szDamagePositioningEntityName03 = 0X0007D8 // CUtlSymbolLarge
    m_szDamagePositioningEntityName04 = 0X0007E0 // CUtlSymbolLarge
    m_vInitialDamagePositions = 0X0007E8 // CUtlVector< Vector >
    m_vExtraDamagePositions = 0X000800 // CUtlVector< Vector >
    m_OnBroken = 0X000818 // CEntityIOOutput
    m_iSurfaceType = 0X000841 // uint8

 CPrecipitationVData: [server.dll]
    m_szParticlePrecipitationEffect = 0X000028 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_flInnerDistance = 0X000108 // float32
    m_nAttachType = 0X00010C // ParticleAttachment_t
    m_bBatchSameVolumeType = 0X000110 // bool
    m_nRTEnvCP = 0X000114 // int32
    m_nRTEnvCPComponent = 0X000118 // int32
    m_szModifier = 0X000120 // CUtlString

 CRagdoll: [server.dll]
    m_ragdoll = 0X000008 // ragdoll_t
    m_mins = 0X000040 // Vector
    m_maxs = 0X00004C // Vector
    m_origin = 0X000058 // Vector
    m_lastUpdate = 0X000064 // float32
    m_allAsleep = 0X000068 // bool
    m_vecLastOrigin = 0X00006C // Vector
    m_flLastOriginChangeTime = 0X000078 // float32
    m_flAwakeTime = 0X00007C // float32

 CSprite: [server.dll]
    m_hSpriteMaterial = 0X0006F0 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_hAttachedToEntity = 0X0006F8 // CHandle< CBaseEntity >
    m_nAttachment = 0X0006FC // AttachmentHandle_t
    m_flSpriteFramerate = 0X000700 // float32
    m_flFrame = 0X000704 // float32
    m_flDieTime = 0X000708 // GameTime_t
    m_nBrightness = 0X000718 // uint32
    m_flBrightnessDuration = 0X00071C // float32
    m_flSpriteScale = 0X000720 // float32
    m_flScaleDuration = 0X000724 // float32
    m_bWorldSpaceScale = 0X000728 // bool
    m_flGlowProxySize = 0X00072C // float32
    m_flHDRColorScale = 0X000730 // float32
    m_flLastTime = 0X000734 // GameTime_t
    m_flMaxFrame = 0X000738 // float32
    m_flStartScale = 0X00073C // float32
    m_flDestScale = 0X000740 // float32
    m_flScaleTimeStart = 0X000744 // GameTime_t
    m_nStartBrightness = 0X000748 // int32
    m_nDestBrightness = 0X00074C // int32
    m_flBrightnessTimeStart = 0X000750 // GameTime_t
    m_nSpriteWidth = 0X000754 // int32
    m_nSpriteHeight = 0X000758 // int32

 CSpriteOriented: [server.dll]
    No schemes available

 CBaseClientUIEntity: [server.dll]
    m_bEnabled = 0X0006F0 // bool
    m_DialogXMLName = 0X0006F8 // CUtlSymbolLarge
    m_PanelClassName = 0X000700 // CUtlSymbolLarge
    m_PanelID = 0X000708 // CUtlSymbolLarge
    m_CustomOutput0 = 0X000710 // CEntityIOOutput
    m_CustomOutput1 = 0X000738 // CEntityIOOutput
    m_CustomOutput2 = 0X000760 // CEntityIOOutput
    m_CustomOutput3 = 0X000788 // CEntityIOOutput
    m_CustomOutput4 = 0X0007B0 // CEntityIOOutput
    m_CustomOutput5 = 0X0007D8 // CEntityIOOutput
    m_CustomOutput6 = 0X000800 // CEntityIOOutput
    m_CustomOutput7 = 0X000828 // CEntityIOOutput
    m_CustomOutput8 = 0X000850 // CEntityIOOutput
    m_CustomOutput9 = 0X000878 // CEntityIOOutput

 CPointClientUIDialog: [server.dll]
    m_hActivator = 0X0008A0 // CHandle< CBaseEntity >
    m_bStartEnabled = 0X0008A4 // bool

 CPointClientUIWorldPanel: [server.dll]
    m_bIgnoreInput = 0X0008A0 // bool
    m_bLit = 0X0008A1 // bool
    m_bFollowPlayerAcrossTeleport = 0X0008A2 // bool
    m_flWidth = 0X0008A4 // float32
    m_flHeight = 0X0008A8 // float32
    m_flDPI = 0X0008AC // float32
    m_flInteractDistance = 0X0008B0 // float32
    m_flDepthOffset = 0X0008B4 // float32
    m_unOwnerContext = 0X0008B8 // uint32
    m_unHorizontalAlign = 0X0008BC // uint32
    m_unVerticalAlign = 0X0008C0 // uint32
    m_unOrientation = 0X0008C4 // uint32
    m_bAllowInteractionFromAllSceneWorlds = 0X0008C8 // bool
    m_vecCSSClasses = 0X0008D0 // CNetworkUtlVectorBase< CUtlSymbolLarge >
    m_bOpaque = 0X0008E8 // bool
    m_bNoDepth = 0X0008E9 // bool
    m_bRenderBackface = 0X0008EA // bool
    m_bUseOffScreenIndicator = 0X0008EB // bool
    m_bExcludeFromSaveGames = 0X0008EC // bool
    m_bGrabbable = 0X0008ED // bool
    m_bOnlyRenderToTexture = 0X0008EE // bool
    m_bDisableMipGen = 0X0008EF // bool
    m_nExplicitImageLayout = 0X0008F0 // int32

 CPointClientUIWorldTextPanel: [server.dll]
    m_messageText = 0X0008F8 // char[512]

 CPointHintUi: [server.dll]
    No schemes available

 CInfoOffscreenPanoramaTexture: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_nResolutionX = 0X0004A4 // int32
    m_nResolutionY = 0X0004A8 // int32
    m_szLayoutFileName = 0X0004B0 // CUtlSymbolLarge
    m_RenderAttrName = 0X0004B8 // CUtlSymbolLarge
    m_TargetEntities = 0X0004C0 // CNetworkUtlVectorBase< CHandle< CBaseModelEntity > >
    m_nTargetChangeCount = 0X0004D8 // int32
    m_vecCSSClasses = 0X0004E0 // CNetworkUtlVectorBase< CUtlSymbolLarge >
    m_szTargetsName = 0X0004F8 // CUtlSymbolLarge
    m_AdditionalTargetEntities = 0X000500 // CUtlVector< CHandle< CBaseModelEntity > >

 CEconItemView: [server.dll]
    m_iItemDefinitionIndex = 0X000038 // uint16
    m_iEntityQuality = 0X00003C // int32
    m_iEntityLevel = 0X000040 // uint32
    m_iItemID = 0X000048 // uint64
    m_iItemIDHigh = 0X000050 // uint32
    m_iItemIDLow = 0X000054 // uint32
    m_iAccountID = 0X000058 // uint32
    m_iInventoryPosition = 0X00005C // uint32
    m_bInitialized = 0X000068 // bool
    m_AttributeList = 0X000070 // CAttributeList
    m_NetworkedDynamicAttributes = 0X0000D0 // CAttributeList
    m_szCustomName = 0X000130 // char[161]
    m_szCustomNameOverride = 0X0001D1 // char[161]

 CInfoPlayerTerrorist: [server.dll]
    No schemes available

 CInfoPlayerCounterterrorist: [server.dll]
    No schemes available

 CInfoDeathmatchSpawn: [server.dll]
    No schemes available

 CInfoArmsRaceCounterterrorist: [server.dll]
    No schemes available

 CInfoArmsRaceTerrorist: [server.dll]
    No schemes available

 CInfoEnemyTerroristSpawn: [server.dll]
    No schemes available

 CPointGiveAmmo: [server.dll]
    m_pActivator = 0X0004A0 // CHandle< CBaseEntity >

 CCSPlayerController: [server.dll]
    m_pInGameMoneyServices = 0X000678 // CCSPlayerController_InGameMoneyServices*
    m_pInventoryServices = 0X000680 // CCSPlayerController_InventoryServices*
    m_pActionTrackingServices = 0X000688 // CCSPlayerController_ActionTrackingServices*
    m_pDamageServices = 0X000690 // CCSPlayerController_DamageServices*
    m_iPing = 0X000698 // uint32
    m_bHasCommunicationAbuseMute = 0X00069C // bool
    m_szCrosshairCodes = 0X0006A0 // CUtlSymbolLarge
    m_iPendingTeamNum = 0X0006A8 // uint8
    m_flForceTeamTime = 0X0006AC // GameTime_t
    m_iCompTeammateColor = 0X0006B0 // int32
    m_bEverPlayedOnTeam = 0X0006B4 // bool
    m_bAttemptedToGetColor = 0X0006B5 // bool
    m_iTeammatePreferredColor = 0X0006B8 // int32
    m_bTeamChanged = 0X0006BC // bool
    m_bInSwitchTeam = 0X0006BD // bool
    m_bHasSeenJoinGame = 0X0006BE // bool
    m_bJustBecameSpectator = 0X0006BF // bool
    m_bSwitchTeamsOnNextRoundReset = 0X0006C0 // bool
    m_szClan = 0X0006C8 // CUtlSymbolLarge
    m_szClanName = 0X0006D0 // char[32]
    m_iCoachingTeam = 0X0006F0 // int32
    m_nPlayerDominated = 0X0006F8 // uint64
    m_nPlayerDominatingMe = 0X000700 // uint64
    m_iCompetitiveRanking = 0X000708 // int32
    m_iCompetitiveWins = 0X00070C // int32
    m_iCompetitiveRankType = 0X000710 // int8
    m_nEndMatchNextMapVote = 0X000714 // int32
    m_unActiveQuestId = 0X000718 // uint16
    m_nQuestProgressReason = 0X00071C // QuestProgress::Reason
    m_unPlayerTvControlFlags = 0X000720 // uint32
    m_iDraftIndex = 0X000790 // int32
    m_msQueuedModeDisconnectionTimestamp = 0X000794 // uint32
    m_uiAbandonRecordedReason = 0X000798 // uint32
    m_bEverFullyConnected = 0X00079C // bool
    m_bAbandonAllowsSurrender = 0X00079D // bool
    m_bDisconnection1MinWarningPrinted = 0X00079E // bool
    m_bScoreReported = 0X00079F // bool
    m_nDisconnectionTick = 0X0007A0 // int32
    m_bControllingBot = 0X0007B0 // bool
    m_bHasControlledBotThisRound = 0X0007B1 // bool
    m_bHasBeenControlledByPlayerThisRound = 0X0007B2 // bool
    m_nBotsControlledThisRound = 0X0007B4 // int32
    m_bCanControlObservedBot = 0X0007B8 // bool
    m_hPlayerPawn = 0X0007BC // CHandle< CCSPlayerPawn >
    m_hObserverPawn = 0X0007C0 // CHandle< CCSObserverPawn >
    m_DesiredObserverMode = 0X0007C4 // int32
    m_hDesiredObserverTarget = 0X0007C8 // CEntityHandle
    m_bPawnIsAlive = 0X0007CC // bool
    m_iPawnHealth = 0X0007D0 // uint32
    m_iPawnArmor = 0X0007D4 // int32
    m_bPawnHasDefuser = 0X0007D8 // bool
    m_bPawnHasHelmet = 0X0007D9 // bool
    m_nPawnCharacterDefIndex = 0X0007DA // uint16
    m_iPawnLifetimeStart = 0X0007DC // int32
    m_iPawnLifetimeEnd = 0X0007E0 // int32
    m_iPawnGunGameLevel = 0X0007E4 // int32
    m_iPawnBotDifficulty = 0X0007E8 // int32
    m_hOriginalControllerOfCurrentPawn = 0X0007EC // CHandle< CCSPlayerController >
    m_iScore = 0X0007F0 // int32
    m_iRoundScore = 0X0007F4 // int32
    m_vecKills = 0X0007F8 // CNetworkUtlVectorBase< EKillTypes_t >
    m_iMVPs = 0X000810 // int32
    m_nUpdateCounter = 0X000814 // int32
    m_lastHeldVoteTimer = 0X00F8B8 // IntervalTimer
    m_bShowHints = 0X00F8D0 // bool
    m_iNextTimeCheck = 0X00F8D4 // int32

 CFootstepControl: [server.dll]
    m_source = 0X000898 // CUtlSymbolLarge
    m_destination = 0X0008A0 // CUtlSymbolLarge

 CTriggerSafeMoneyGather: [server.dll]
    m_vecCashBundles = 0X000898 // CUtlVector< CHandle< CBaseEntity > >

 CCSEnvGunfire: [server.dll]
    m_iMinBurstSize = 0X0004A0 // int32
    m_iMaxBurstSize = 0X0004A4 // int32
    m_flMinBurstDelay = 0X0004A8 // float32
    m_flMaxBurstDelay = 0X0004AC // float32
    m_flRateOfFire = 0X0004B0 // float32
    m_iszShootSound = 0X0004B8 // CUtlSymbolLarge
    m_iszTracerType = 0X0004C0 // CUtlSymbolLarge
    m_iszWeaponName = 0X0004C8 // CUtlSymbolLarge
    m_bDisabled = 0X0004D0 // bool
    m_iShotsRemaining = 0X0004D4 // int32
    m_iSpread = 0X0004D8 // int32
    m_vecSpread = 0X0004DC // Vector
    m_vecTargetPosition = 0X0004E8 // Vector
    m_flTargetDist = 0X0004F4 // float32
    m_flBias = 0X0004F8 // float32
    m_bCollide = 0X0004FC // bool
    m_hTarget = 0X000500 // CHandle< CBaseEntity >
    m_bAllowNullTarget = 0X000504 // bool
    m_bAlwaysWallbangTracer = 0X000505 // bool
    m_flDamageScaleValue = 0X000508 // float32
    m_flAdditionalSpread = 0X00050C // float32

 CInfoGasCanisterLaunchPoint: [server.dll]
    No schemes available

 CDangerZone: [server.dll]
    m_vecDangerZoneOriginStartedAt = 0X0004A0 // Vector
    m_flBombLaunchTime = 0X0004AC // GameTime_t
    m_flExtraRadius = 0X0004B0 // float32
    m_flExtraRadiusStartTime = 0X0004B4 // GameTime_t
    m_flExtraRadiusTotalLerpTime = 0X0004B8 // float32
    m_nDropOrder = 0X0004BC // int32
    m_iWave = 0X0004C0 // int32
    m_nMyZoneIndex = 0X0004C4 // int32
    m_nZoneNeighbors = 0X0004C8 // int32[6]

 CGrassBurn: [server.dll]
    m_flGrassBurnClearTime = 0X0004A0 // float32

 CWeaponCSBaseVData: [server.dll]
    m_WeaponType = 0X000320 // CSWeaponType
    m_WeaponCategory = 0X000324 // CSWeaponCategory
    m_szViewModel = 0X000328 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szPlayerModel = 0X000408 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szWorldDroppedModel = 0X0004E8 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szAimsightLensMaskModel = 0X0005C8 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szMagazineModel = 0X0006A8 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szHeatEffect = 0X000788 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szEjectBrassEffect = 0X000868 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szMuzzleFlashParticleAlt = 0X000948 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szMuzzleFlashThirdPersonParticle = 0X000A28 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szMuzzleFlashThirdPersonParticleAlt = 0X000B08 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_GearSlot = 0X000BE8 // gear_slot_t
    m_GearSlotPosition = 0X000BEC // int32
    m_DefaultLoadoutPosition = 0X000BF0 // loadout_positions_t
    m_sWrongTeamMsg = 0X000BF8 // CUtlString
    m_nPrice = 0X000C00 // int32
    m_nKillAward = 0X000C04 // int32
    m_nPrimaryReserveAmmoMax = 0X000C08 // int32
    m_nSecondaryReserveAmmoMax = 0X000C0C // int32
    m_bMeleeWeapon = 0X000C10 // bool
    m_bHasBurstMode = 0X000C11 // bool
    m_bIsRevolver = 0X000C12 // bool
    m_bCannotShootUnderwater = 0X000C13 // bool
    m_szName = 0X000C18 // CUtlString
    m_szAnimExtension = 0X000C20 // CUtlString
    m_eSilencerType = 0X000C28 // CSWeaponSilencerType
    m_nCrosshairMinDistance = 0X000C2C // int32
    m_nCrosshairDeltaDistance = 0X000C30 // int32
    m_flCycleTime = 0X000C34 // CFiringModeFloat
    m_flMaxSpeed = 0X000C3C // CFiringModeFloat
    m_flSpread = 0X000C44 // CFiringModeFloat
    m_flInaccuracyCrouch = 0X000C4C // CFiringModeFloat
    m_flInaccuracyStand = 0X000C54 // CFiringModeFloat
    m_flInaccuracyJump = 0X000C5C // CFiringModeFloat
    m_flInaccuracyLand = 0X000C64 // CFiringModeFloat
    m_flInaccuracyLadder = 0X000C6C // CFiringModeFloat
    m_flInaccuracyFire = 0X000C74 // CFiringModeFloat
    m_flInaccuracyMove = 0X000C7C // CFiringModeFloat
    m_flRecoilAngle = 0X000C84 // CFiringModeFloat
    m_flRecoilAngleVariance = 0X000C8C // CFiringModeFloat
    m_flRecoilMagnitude = 0X000C94 // CFiringModeFloat
    m_flRecoilMagnitudeVariance = 0X000C9C // CFiringModeFloat
    m_nTracerFrequency = 0X000CA4 // CFiringModeInt
    m_flInaccuracyJumpInitial = 0X000CAC // float32
    m_flInaccuracyJumpApex = 0X000CB0 // float32
    m_flInaccuracyReload = 0X000CB4 // float32
    m_nRecoilSeed = 0X000CB8 // int32
    m_nSpreadSeed = 0X000CBC // int32
    m_flTimeToIdleAfterFire = 0X000CC0 // float32
    m_flIdleInterval = 0X000CC4 // float32
    m_flAttackMovespeedFactor = 0X000CC8 // float32
    m_flHeatPerShot = 0X000CCC // float32
    m_flInaccuracyPitchShift = 0X000CD0 // float32
    m_flInaccuracyAltSoundThreshold = 0X000CD4 // float32
    m_flBotAudibleRange = 0X000CD8 // float32
    m_szUseRadioSubtitle = 0X000CE0 // CUtlString
    m_bUnzoomsAfterShot = 0X000CE8 // bool
    m_bHideViewModelWhenZoomed = 0X000CE9 // bool
    m_nZoomLevels = 0X000CEC // int32
    m_nZoomFOV1 = 0X000CF0 // int32
    m_nZoomFOV2 = 0X000CF4 // int32
    m_flZoomTime0 = 0X000CF8 // float32
    m_flZoomTime1 = 0X000CFC // float32
    m_flZoomTime2 = 0X000D00 // float32
    m_flIronSightPullUpSpeed = 0X000D04 // float32
    m_flIronSightPutDownSpeed = 0X000D08 // float32
    m_flIronSightFOV = 0X000D0C // float32
    m_flIronSightPivotForward = 0X000D10 // float32
    m_flIronSightLooseness = 0X000D14 // float32
    m_angPivotAngle = 0X000D18 // QAngle
    m_vecIronSightEyePos = 0X000D24 // Vector
    m_nDamage = 0X000D30 // int32
    m_flHeadshotMultiplier = 0X000D34 // float32
    m_flArmorRatio = 0X000D38 // float32
    m_flPenetration = 0X000D3C // float32
    m_flRange = 0X000D40 // float32
    m_flRangeModifier = 0X000D44 // float32
    m_flFlinchVelocityModifierLarge = 0X000D48 // float32
    m_flFlinchVelocityModifierSmall = 0X000D4C // float32
    m_flRecoveryTimeCrouch = 0X000D50 // float32
    m_flRecoveryTimeStand = 0X000D54 // float32
    m_flRecoveryTimeCrouchFinal = 0X000D58 // float32
    m_flRecoveryTimeStandFinal = 0X000D5C // float32
    m_nRecoveryTransitionStartBullet = 0X000D60 // int32
    m_nRecoveryTransitionEndBullet = 0X000D64 // int32
    m_flThrowVelocity = 0X000D68 // float32
    m_vSmokeColor = 0X000D6C // Vector
    m_szAnimClass = 0X000D78 // CUtlString

 CTabletBlockerShim: [server.dll]
    No schemes available

 CTabletBlocker: [server.dll]
    No schemes available

 CTriggerTripWire: [server.dll]
    No schemes available

 CCSSprite: [server.dll]
    No schemes available

 CPointGamestatsCounter: [server.dll]
    m_strStatisticName = 0X0004A0 // CUtlSymbolLarge
    m_bDisabled = 0X0004A8 // bool

 CEnvHudHint: [server.dll]
    m_iszMessage = 0X0004A0 // CUtlSymbolLarge

 CBombTarget: [server.dll]
    m_OnBombExplode = 0X000898 // CEntityIOOutput
    m_OnBombPlanted = 0X0008C0 // CEntityIOOutput
    m_OnBombDefused = 0X0008E8 // CEntityIOOutput
    m_bIsBombSiteB = 0X000910 // bool
    m_bIsHeistBombTarget = 0X000911 // bool
    m_bBombPlantedHere = 0X000912 // bool
    m_szMountTarget = 0X000918 // CUtlSymbolLarge
    m_hInstructorHint = 0X000920 // CHandle< CBaseEntity >

 CInfoInstructorHintBombTargetA: [server.dll]
    No schemes available

 CInfoInstructorHintBombTargetB: [server.dll]
    No schemes available

 CHostageRescueZoneShim: [server.dll]
    No schemes available

 CHostageRescueZone: [server.dll]
    No schemes available

 CInfoInstructorHintHostageRescueZone: [server.dll]
    No schemes available

 CBuyZone: [server.dll]
    m_LegacyTeamNum = 0X000898 // int32

 CFuncConveyor: [server.dll]
    m_szConveyorModels = 0X0006F0 // CUtlSymbolLarge
    m_flTransitionDurationSeconds = 0X0006F8 // float32
    m_angMoveEntitySpace = 0X0006FC // QAngle
    m_vecMoveDirEntitySpace = 0X000708 // Vector
    m_flTargetSpeed = 0X000714 // float32
    m_nTransitionStartTick = 0X000718 // GameTick_t
    m_nTransitionDurationTicks = 0X00071C // int32
    m_flTransitionStartSpeed = 0X000720 // float32
    m_hConveyorModels = 0X000728 // CNetworkUtlVectorBase< CHandle< CBaseEntity > >

 CTriggerBombReset: [server.dll]
    No schemes available

 CCSPlace: [server.dll]
    m_name = 0X0006F8 // CUtlSymbolLarge

 CPlayerSprayDecal: [server.dll]
    m_nUniqueID = 0X0006F0 // int32
    m_unAccountID = 0X0006F4 // uint32
    m_unTraceID = 0X0006F8 // uint32
    m_rtGcTime = 0X0006FC // uint32
    m_vecEndPos = 0X000700 // Vector
    m_vecStart = 0X00070C // Vector
    m_vecLeft = 0X000718 // Vector
    m_vecNormal = 0X000724 // Vector
    m_nPlayer = 0X000730 // int32
    m_nEntity = 0X000734 // int32
    m_nHitbox = 0X000738 // int32
    m_flCreationTime = 0X00073C // float32
    m_nTintID = 0X000740 // int32
    m_nVersion = 0X000744 // uint8
    m_ubSignature = 0X000745 // uint8[128]

 CTriggerCustomBounds: [server.dll]
    No schemes available

 CTriggerSurvivalPlayArea: [server.dll]
    No schemes available

 CInfoMapRegion: [server.dll]
    m_flRadius = 0X0004A0 // float32
    m_strLocToken = 0X0004A8 // CUtlSymbolLarge
    m_szLocToken = 0X0004B0 // char[128]

 CInferno: [server.dll]
    m_fireXDelta = 0X000700 // int32[64]
    m_fireYDelta = 0X000800 // int32[64]
    m_fireZDelta = 0X000900 // int32[64]
    m_fireParentXDelta = 0X000A00 // int32[64]
    m_fireParentYDelta = 0X000B00 // int32[64]
    m_fireParentZDelta = 0X000C00 // int32[64]
    m_bFireIsBurning = 0X000D00 // bool[64]
    m_BurnNormal = 0X000D40 // Vector[64]
    m_fireCount = 0X001040 // int32
    m_nInfernoType = 0X001044 // int32
    m_nFireEffectTickBegin = 0X001048 // int32
    m_nFireLifetime = 0X00104C // float32
    m_bInPostEffectTime = 0X001050 // bool
    m_nFiresExtinguishCount = 0X001054 // int32
    m_bWasCreatedInSmoke = 0X001058 // bool
    m_extent = 0X001260 // Extent
    m_damageTimer = 0X001278 // CountdownTimer
    m_damageRampTimer = 0X001290 // CountdownTimer
    m_splashVelocity = 0X0012A8 // Vector
    m_InitialSplashVelocity = 0X0012B4 // Vector
    m_startPos = 0X0012C0 // Vector
    m_vecOriginalSpawnLocation = 0X0012CC // Vector
    m_activeTimer = 0X0012D8 // IntervalTimer
    m_fireSpawnOffset = 0X0012E8 // int32
    m_nMaxFlames = 0X0012EC // int32
    m_BookkeepingTimer = 0X0012F0 // CountdownTimer
    m_NextSpreadTimer = 0X001308 // CountdownTimer
    m_nSourceItemDefIndex = 0X001320 // uint16

 CFireCrackerBlast: [server.dll]
    No schemes available

 CBarnLight: [server.dll]
    m_bEnabled = 0X0006F0 // bool
    m_nColorMode = 0X0006F4 // int32
    m_Color = 0X0006F8 // Color
    m_flColorTemperature = 0X0006FC // float32
    m_flBrightness = 0X000700 // float32
    m_flBrightnessScale = 0X000704 // float32
    m_nDirectLight = 0X000708 // int32
    m_nBakedShadowIndex = 0X00070C // int32
    m_nLuminaireShape = 0X000710 // int32
    m_flLuminaireSize = 0X000714 // float32
    m_flLuminaireAnisotropy = 0X000718 // float32
    m_LightStyleString = 0X000720 // CUtlString
    m_flLightStyleStartTime = 0X000728 // GameTime_t
    m_QueuedLightStyleStrings = 0X000730 // CNetworkUtlVectorBase< CUtlString >
    m_LightStyleEvents = 0X000748 // CNetworkUtlVectorBase< CUtlString >
    m_LightStyleTargets = 0X000760 // CNetworkUtlVectorBase< CHandle< CBaseModelEntity > >
    m_StyleEvent = 0X000778 // CEntityIOOutput[4]
    m_StyleRadianceVar = 0X000818 // CUtlString
    m_StyleVar = 0X000820 // CUtlString
    m_hLightCookie = 0X000848 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_flShape = 0X000850 // float32
    m_flSoftX = 0X000854 // float32
    m_flSoftY = 0X000858 // float32
    m_flSkirt = 0X00085C // float32
    m_flSkirtNear = 0X000860 // float32
    m_vSizeParams = 0X000864 // Vector
    m_flRange = 0X000870 // float32
    m_vShear = 0X000874 // Vector
    m_nBakeSpecularToCubemaps = 0X000880 // int32
    m_vBakeSpecularToCubemapsSize = 0X000884 // Vector
    m_nCastShadows = 0X000890 // int32
    m_nShadowMapSize = 0X000894 // int32
    m_nShadowPriority = 0X000898 // int32
    m_bContactShadow = 0X00089C // bool
    m_nBounceLight = 0X0008A0 // int32
    m_flBounceScale = 0X0008A4 // float32
    m_flMinRoughness = 0X0008A8 // float32
    m_nFog = 0X0008AC // int32
    m_flFogStrength = 0X0008B0 // float32
    m_nFogShadows = 0X0008B4 // int32
    m_flFogScale = 0X0008B8 // float32
    m_flFadeSizeStart = 0X0008BC // float32
    m_flFadeSizeEnd = 0X0008C0 // float32
    m_flShadowFadeSizeStart = 0X0008C4 // float32
    m_flShadowFadeSizeEnd = 0X0008C8 // float32
    m_bPrecomputedFieldsValid = 0X0008CC // bool
    m_vPrecomputedBoundsMins = 0X0008D0 // Vector
    m_vPrecomputedBoundsMaxs = 0X0008DC // Vector
    m_vPrecomputedOBBOrigin = 0X0008E8 // Vector
    m_vPrecomputedOBBAngles = 0X0008F4 // QAngle
    m_vPrecomputedOBBExtent = 0X000900 // Vector
    m_bPvsModifyEntity = 0X00090C // bool

 CRectLight: [server.dll]
    m_bShowLight = 0X000918 // bool

 COmniLight: [server.dll]
    m_flInnerAngle = 0X000918 // float32
    m_flOuterAngle = 0X00091C // float32
    m_bShowLight = 0X000920 // bool

 CCSTeam: [server.dll]
    m_nLastRecievedShorthandedRoundBonus = 0X000558 // int32
    m_nShorthandedRoundBonusStartRound = 0X00055C // int32
    m_bSurrendered = 0X000560 // bool
    m_szTeamMatchStat = 0X000561 // char[512]
    m_numMapVictories = 0X000764 // int32
    m_scoreFirstHalf = 0X000768 // int32
    m_scoreSecondHalf = 0X00076C // int32
    m_scoreOvertime = 0X000770 // int32
    m_szClanTeamname = 0X000774 // char[129]
    m_iClanID = 0X0007F8 // uint32
    m_szTeamFlagImage = 0X0007FC // char[8]
    m_szTeamLogoImage = 0X000804 // char[8]
    m_flNextResourceTime = 0X00080C // float32
    m_iLastUpdateSentAt = 0X000810 // int32
    m_flLastPlayerSortTime = 0X000814 // float32
    m_nLastGGLeader_CT = 0X000818 // CPlayerSlot
    m_nLastGGLeader_T = 0X00081C // CPlayerSlot
    m_nGGLeaderSlot_CT = 0X000820 // CPlayerSlot
    m_nGGLeaderSlot_T = 0X000824 // CPlayerSlot
    m_bGGHasLeader_CT = 0X000828 // bool
    m_bGGHasLeader_T = 0X000829 // bool

 CMapInfo: [server.dll]
    m_iBuyingStatus = 0X0004A0 // int32
    m_flBombRadius = 0X0004A4 // float32
    m_iPetPopulation = 0X0004A8 // int32
    m_bUseNormalSpawnsForDM = 0X0004AC // bool
    m_bDisableAutoGeneratedDMSpawns = 0X0004AD // bool
    m_flBotMaxVisionDistance = 0X0004B0 // float32
    m_iHostageCount = 0X0004B4 // int32
    m_bFadePlayerVisibilityFarZ = 0X0004B8 // bool

 CCSBot: [server.dll]
    m_lastCoopSpawnPoint = 0X0000D0 // CHandle< SpawnPointCoopEnemy >
    m_eyePosition = 0X0000E0 // Vector
    m_name = 0X0000EC // char[64]
    m_combatRange = 0X00012C // float32
    m_isRogue = 0X000130 // bool
    m_rogueTimer = 0X000138 // CountdownTimer
    m_diedLastRound = 0X000154 // bool
    m_safeTime = 0X000158 // float32
    m_wasSafe = 0X00015C // bool
    m_blindFire = 0X000164 // bool
    m_surpriseTimer = 0X000168 // CountdownTimer
    m_bAllowActive = 0X000180 // bool
    m_isFollowing = 0X000181 // bool
    m_leader = 0X000184 // CHandle< CCSPlayerPawn >
    m_followTimestamp = 0X000188 // float32
    m_allowAutoFollowTime = 0X00018C // float32
    m_hurryTimer = 0X000190 // CountdownTimer
    m_alertTimer = 0X0001A8 // CountdownTimer
    m_sneakTimer = 0X0001C0 // CountdownTimer
    m_panicTimer = 0X0001D8 // CountdownTimer
    m_stateTimestamp = 0X0004D8 // float32
    m_isAttacking = 0X0004DC // bool
    m_isOpeningDoor = 0X0004DD // bool
    m_taskEntity = 0X0004E4 // CHandle< CBaseEntity >
    m_goalPosition = 0X0004F4 // Vector
    m_goalEntity = 0X000500 // CHandle< CBaseEntity >
    m_avoid = 0X000504 // CHandle< CBaseEntity >
    m_avoidTimestamp = 0X000508 // float32
    m_isStopping = 0X00050C // bool
    m_hasVisitedEnemySpawn = 0X00050D // bool
    m_stillTimer = 0X000510 // IntervalTimer
    m_bEyeAnglesUnderPathFinderControl = 0X000520 // bool
    m_pathIndex = 0X006618 // int32
    m_areaEnteredTimestamp = 0X00661C // GameTime_t
    m_repathTimer = 0X006620 // CountdownTimer
    m_avoidFriendTimer = 0X006638 // CountdownTimer
    m_isFriendInTheWay = 0X006650 // bool
    m_politeTimer = 0X006658 // CountdownTimer
    m_isWaitingBehindFriend = 0X006670 // bool
    m_pathLadderEnd = 0X00669C // float32
    m_mustRunTimer = 0X0066E8 // CountdownTimer
    m_waitTimer = 0X006700 // CountdownTimer
    m_updateTravelDistanceTimer = 0X006718 // CountdownTimer
    m_playerTravelDistance = 0X006730 // float32[64]
    m_travelDistancePhase = 0X006830 // uint8
    m_hostageEscortCount = 0X0069C8 // uint8
    m_hostageEscortCountTimestamp = 0X0069CC // float32
    m_desiredTeam = 0X0069D0 // int32
    m_hasJoined = 0X0069D4 // bool
    m_isWaitingForHostage = 0X0069D5 // bool
    m_inhibitWaitingForHostageTimer = 0X0069D8 // CountdownTimer
    m_waitForHostageTimer = 0X0069F0 // CountdownTimer
    m_noisePosition = 0X006A08 // Vector
    m_noiseTravelDistance = 0X006A14 // float32
    m_noiseTimestamp = 0X006A18 // float32
    m_noiseSource = 0X006A20 // CBasePlayerPawn*
    m_noiseBendTimer = 0X006A38 // CountdownTimer
    m_bentNoisePosition = 0X006A50 // Vector
    m_bendNoisePositionValid = 0X006A5C // bool
    m_lookAroundStateTimestamp = 0X006A60 // float32
    m_lookAheadAngle = 0X006A64 // float32
    m_forwardAngle = 0X006A68 // float32
    m_inhibitLookAroundTimestamp = 0X006A6C // float32
    m_lookAtSpot = 0X006A74 // Vector
    m_lookAtSpotDuration = 0X006A84 // float32
    m_lookAtSpotTimestamp = 0X006A88 // float32
    m_lookAtSpotAngleTolerance = 0X006A8C // float32
    m_lookAtSpotClearIfClose = 0X006A90 // bool
    m_lookAtSpotAttack = 0X006A91 // bool
    m_lookAtDesc = 0X006A98 // char*
    m_peripheralTimestamp = 0X006AA0 // float32
    m_approachPointCount = 0X006C28 // uint8
    m_approachPointViewPosition = 0X006C2C // Vector
    m_viewSteadyTimer = 0X006C38 // IntervalTimer
    m_tossGrenadeTimer = 0X006C50 // CountdownTimer
    m_isAvoidingGrenade = 0X006C70 // CountdownTimer
    m_spotCheckTimestamp = 0X006C90 // float32
    m_checkedHidingSpotCount = 0X007098 // int32
    m_lookPitch = 0X00709C // float32
    m_lookPitchVel = 0X0070A0 // float32
    m_lookYaw = 0X0070A4 // float32
    m_lookYawVel = 0X0070A8 // float32
    m_targetSpot = 0X0070AC // Vector
    m_targetSpotVelocity = 0X0070B8 // Vector
    m_targetSpotPredicted = 0X0070C4 // Vector
    m_aimError = 0X0070D0 // QAngle
    m_aimGoal = 0X0070DC // QAngle
    m_targetSpotTime = 0X0070E8 // GameTime_t
    m_aimFocus = 0X0070EC // float32
    m_aimFocusInterval = 0X0070F0 // float32
    m_aimFocusNextUpdate = 0X0070F4 // GameTime_t
    m_ignoreEnemiesTimer = 0X007100 // CountdownTimer
    m_enemy = 0X007118 // CHandle< CCSPlayerPawnBase >
    m_isEnemyVisible = 0X00711C // bool
    m_visibleEnemyParts = 0X00711D // uint8
    m_lastEnemyPosition = 0X007120 // Vector
    m_lastSawEnemyTimestamp = 0X00712C // float32
    m_firstSawEnemyTimestamp = 0X007130 // float32
    m_currentEnemyAcquireTimestamp = 0X007134 // float32
    m_enemyDeathTimestamp = 0X007138 // float32
    m_friendDeathTimestamp = 0X00713C // float32
    m_isLastEnemyDead = 0X007140 // bool
    m_nearbyEnemyCount = 0X007144 // int32
    m_bomber = 0X007350 // CHandle< CCSPlayerPawnBase >
    m_nearbyFriendCount = 0X007354 // int32
    m_closestVisibleFriend = 0X007358 // CHandle< CCSPlayerPawnBase >
    m_closestVisibleHumanFriend = 0X00735C // CHandle< CCSPlayerPawnBase >
    m_attentionInterval = 0X007360 // IntervalTimer
    m_attacker = 0X007370 // CHandle< CCSPlayerPawnBase >
    m_attackedTimestamp = 0X007374 // float32
    m_burnedByFlamesTimer = 0X007378 // IntervalTimer
    m_lastVictimID = 0X007388 // int32
    m_isAimingAtEnemy = 0X00738C // bool
    m_isRapidFiring = 0X00738D // bool
    m_equipTimer = 0X007390 // IntervalTimer
    m_zoomTimer = 0X0073A0 // CountdownTimer
    m_fireWeaponTimestamp = 0X0073B8 // GameTime_t
    m_lookForWeaponsOnGroundTimer = 0X0073C0 // CountdownTimer
    m_bIsSleeping = 0X0073D8 // bool
    m_isEnemySniperVisible = 0X0073D9 // bool
    m_sawEnemySniperTimer = 0X0073E0 // CountdownTimer
    m_enemyQueueIndex = 0X007498 // uint8
    m_enemyQueueCount = 0X007499 // uint8
    m_enemyQueueAttendIndex = 0X00749A // uint8
    m_isStuck = 0X00749B // bool
    m_stuckTimestamp = 0X00749C // GameTime_t
    m_stuckSpot = 0X0074A0 // Vector
    m_wiggleTimer = 0X0074B0 // CountdownTimer
    m_stuckJumpTimer = 0X0074C8 // CountdownTimer
    m_nextCleanupCheckTimestamp = 0X0074E0 // GameTime_t
    m_avgVel = 0X0074E4 // float32[10]
    m_avgVelIndex = 0X00750C // int32
    m_avgVelCount = 0X007510 // int32
    m_lastOrigin = 0X007514 // Vector
    m_lastRadioRecievedTimestamp = 0X007524 // float32
    m_lastRadioSentTimestamp = 0X007528 // float32
    m_radioSubject = 0X00752C // CHandle< CCSPlayerPawnBase >
    m_radioPosition = 0X007530 // Vector
    m_voiceEndTimestamp = 0X00753C // float32
    m_lastValidReactionQueueFrame = 0X007548 // int32

 CFogVolume: [server.dll]
    m_fogName = 0X0006F0 // CUtlSymbolLarge
    m_postProcessName = 0X0006F8 // CUtlSymbolLarge
    m_colorCorrectionName = 0X000700 // CUtlSymbolLarge
    m_bDisabled = 0X000710 // bool
    m_bInFogVolumesList = 0X000711 // bool

 CInfoDynamicShadowHint: [server.dll]
    m_bDisabled = 0X0004A0 // bool
    m_flRange = 0X0004A4 // float32
    m_nImportance = 0X0004A8 // int32
    m_nLightChoice = 0X0004AC // int32
    m_hLight = 0X0004B0 // CHandle< CBaseEntity >

 CInfoDynamicShadowHintBox: [server.dll]
    m_vBoxMins = 0X0004B8 // Vector
    m_vBoxMaxs = 0X0004C4 // Vector

 CEnvSky: [server.dll]
    m_hSkyMaterial = 0X0006F0 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_bStartDisabled = 0X0006F8 // bool
    m_vTintColor = 0X0006F9 // Color
    m_flBrightnessScale = 0X000700 // float32
    m_nFogType = 0X000704 // int32
    m_flFogMinStart = 0X000708 // float32
    m_flFogMinEnd = 0X00070C // float32
    m_flFogMaxStart = 0X000710 // float32
    m_flFogMaxEnd = 0X000714 // float32
    m_bEnabled = 0X000718 // bool

 CTonemapController2Alias_env_tonemap_controller2: [server.dll]
    No schemes available

 CTonemapTrigger: [server.dll]
    m_tonemapControllerName = 0X000898 // CUtlSymbolLarge
    m_hTonemapController = 0X0008A0 // CEntityHandle

 CFogTrigger: [server.dll]
    m_fog = 0X000898 // fogparams_t

 CLightEntity: [server.dll]
    m_CLightComponent = 0X0006F0 // CLightComponent*

 CLightSpotEntity: [server.dll]
    No schemes available

 CLightOrthoEntity: [server.dll]
    No schemes available

 CLightDirectionalEntity: [server.dll]
    No schemes available

 CLightEnvironmentEntity: [server.dll]
    No schemes available

 CPostProcessingVolume: [server.dll]
    m_hPostSettings = 0X0008A8 // CStrongHandle< InfoForResourceTypeCPostProcessingResource >
    m_flFadeDuration = 0X0008B0 // float32
    m_flMinLogExposure = 0X0008B4 // float32
    m_flMaxLogExposure = 0X0008B8 // float32
    m_flMinExposure = 0X0008BC // float32
    m_flMaxExposure = 0X0008C0 // float32
    m_flExposureCompensation = 0X0008C4 // float32
    m_flExposureFadeSpeedUp = 0X0008C8 // float32
    m_flExposureFadeSpeedDown = 0X0008CC // float32
    m_flTonemapEVSmoothingRange = 0X0008D0 // float32
    m_bMaster = 0X0008D4 // bool
    m_bExposureControl = 0X0008D5 // bool
    m_flRate = 0X0008D8 // float32
    m_flTonemapPercentTarget = 0X0008DC // float32
    m_flTonemapPercentBrightPixels = 0X0008E0 // float32
    m_flTonemapMinAvgLum = 0X0008E4 // float32

 CEnvParticleGlow: [server.dll]
    m_flAlphaScale = 0X000C68 // float32
    m_flRadiusScale = 0X000C6C // float32
    m_flSelfIllumScale = 0X000C70 // float32
    m_ColorTint = 0X000C74 // Color
    m_hTextureOverride = 0X000C78 // CStrongHandle< InfoForResourceTypeCTextureBase >

 CTextureBasedAnimatable: [server.dll]
    m_bLoop = 0X0006F0 // bool
    m_flFPS = 0X0006F4 // float32
    m_hPositionKeys = 0X0006F8 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hRotationKeys = 0X000700 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_vAnimationBoundsMin = 0X000708 // Vector
    m_vAnimationBoundsMax = 0X000714 // Vector
    m_flStartTime = 0X000720 // float32
    m_flStartFrame = 0X000724 // float32

 CWorld: [server.dll]
    No schemes available

 CBaseAnimGraph: [server.dll]
    m_pRagdollPose = 0X000700 // PhysicsRagdollPose_t*
    m_bClientRagdoll = 0X000708 // bool
    m_vecForce = 0X00070C // Vector
    m_nForceBone = 0X000718 // int32
    m_bShouldAnimateDuringGameplayPause = 0X00071C // bool
    m_bAnimGraphUpdateEnabled = 0X00071D // bool
    m_bInitiallyPopulateInterpHistory = 0X00071E // bool
    m_flMaxSlopeDistance = 0X000720 // float32
    m_vLastSlopeCheckPos = 0X000724 // Vector
    m_pChoreoServices = 0X000730 // IChoreoServices*
    m_bAnimGraphDirty = 0X000738 // bool

 CBaseProp: [server.dll]
    m_bModelOverrodeBlockLOS = 0X000820 // bool
    m_iShapeType = 0X000824 // int32
    m_bConformToCollisionBounds = 0X000828 // bool
    m_mPreferredCatchTransform = 0X00082C // matrix3x4_t

 CBreakableProp: [server.dll]
    m_OnBreak = 0X000870 // CEntityIOOutput
    m_OnHealthChanged = 0X000898 // CEntityOutputTemplate< float32 >
    m_OnTakeDamage = 0X0008C0 // CEntityIOOutput
    m_impactEnergyScale = 0X0008E8 // float32
    m_iMinHealthDmg = 0X0008EC // int32
    m_preferredCarryAngles = 0X0008F0 // QAngle
    m_flPressureDelay = 0X0008FC // float32
    m_hBreaker = 0X000900 // CHandle< CBaseEntity >
    m_PerformanceMode = 0X000904 // PerformanceMode_t
    m_flDmgModBullet = 0X000908 // float32
    m_flDmgModClub = 0X00090C // float32
    m_flDmgModExplosive = 0X000910 // float32
    m_flDmgModFire = 0X000914 // float32
    m_iszPhysicsDamageTableName = 0X000918 // CUtlSymbolLarge
    m_iszBasePropData = 0X000920 // CUtlSymbolLarge
    m_iInteractions = 0X000928 // int32
    m_flPreventDamageBeforeTime = 0X00092C // GameTime_t
    m_bHasBreakPiecesOrCommands = 0X000930 // bool
    m_explodeDamage = 0X000934 // float32
    m_explodeRadius = 0X000938 // float32
    m_explosionDelay = 0X000940 // float32
    m_explosionBuildupSound = 0X000948 // CUtlSymbolLarge
    m_explosionCustomEffect = 0X000950 // CUtlSymbolLarge
    m_explosionCustomSound = 0X000958 // CUtlSymbolLarge
    m_explosionModifier = 0X000960 // CUtlSymbolLarge
    m_hPhysicsAttacker = 0X000968 // CHandle< CBasePlayerPawn >
    m_flLastPhysicsInfluenceTime = 0X00096C // GameTime_t
    m_bOriginalBlockLOS = 0X000970 // bool
    m_flDefaultFadeScale = 0X000974 // float32
    m_hLastAttacker = 0X000978 // CHandle< CBaseEntity >
    m_hFlareEnt = 0X00097C // CHandle< CBaseEntity >
    m_bUsePuntSound = 0X000980 // bool
    m_iszPuntSound = 0X000988 // CUtlSymbolLarge
    m_noGhostCollision = 0X000990 // bool

 CDynamicProp: [server.dll]
    m_bCreateNavObstacle = 0X0009A0 // bool
    m_bUseHitboxesForRenderBox = 0X0009A1 // bool
    m_bUseAnimGraph = 0X0009A2 // bool
    m_pOutputAnimBegun = 0X0009A8 // CEntityIOOutput
    m_pOutputAnimOver = 0X0009D0 // CEntityIOOutput
    m_pOutputAnimLoopCycleOver = 0X0009F8 // CEntityIOOutput
    m_OnAnimReachedStart = 0X000A20 // CEntityIOOutput
    m_OnAnimReachedEnd = 0X000A48 // CEntityIOOutput
    m_iszDefaultAnim = 0X000A70 // CUtlSymbolLarge
    m_nDefaultAnimLoopMode = 0X000A78 // AnimLoopMode_t
    m_bAnimateOnServer = 0X000A7C // bool
    m_bRandomizeCycle = 0X000A7D // bool
    m_bStartDisabled = 0X000A7E // bool
    m_bScriptedMovement = 0X000A7F // bool
    m_bFiredStartEndOutput = 0X000A80 // bool
    m_bForceNpcExclude = 0X000A81 // bool
    m_bCreateNonSolid = 0X000A82 // bool
    m_bIsOverrideProp = 0X000A83 // bool
    m_iInitialGlowState = 0X000A84 // int32
    m_nGlowRange = 0X000A88 // int32
    m_nGlowRangeMin = 0X000A8C // int32
    m_glowColor = 0X000A90 // Color
    m_nGlowTeam = 0X000A94 // int32

 CDynamicPropAlias_dynamic_prop: [server.dll]
    No schemes available

 CDynamicPropAlias_prop_dynamic_override: [server.dll]
    No schemes available

 CDynamicPropAlias_cable_dynamic: [server.dll]
    No schemes available

 CColorCorrectionVolume: [server.dll]
    m_bEnabled = 0X000898 // bool
    m_MaxWeight = 0X00089C // float32
    m_FadeDuration = 0X0008A0 // float32
    m_bStartDisabled = 0X0008A4 // bool
    m_Weight = 0X0008A8 // float32
    m_lookupFilename = 0X0008AC // char[512]
    m_LastEnterWeight = 0X000AAC // float32
    m_LastEnterTime = 0X000AB0 // GameTime_t
    m_LastExitWeight = 0X000AB4 // float32
    m_LastExitTime = 0X000AB8 // GameTime_t

 CPointCommentaryNode: [server.dll]
    m_iszPreCommands = 0X000820 // CUtlSymbolLarge
    m_iszPostCommands = 0X000828 // CUtlSymbolLarge
    m_iszCommentaryFile = 0X000830 // CUtlSymbolLarge
    m_iszViewTarget = 0X000838 // CUtlSymbolLarge
    m_hViewTarget = 0X000840 // CHandle< CBaseEntity >
    m_hViewTargetAngles = 0X000844 // CHandle< CBaseEntity >
    m_iszViewPosition = 0X000848 // CUtlSymbolLarge
    m_hViewPosition = 0X000850 // CHandle< CBaseEntity >
    m_hViewPositionMover = 0X000854 // CHandle< CBaseEntity >
    m_bPreventMovement = 0X000858 // bool
    m_bUnderCrosshair = 0X000859 // bool
    m_bUnstoppable = 0X00085A // bool
    m_flFinishedTime = 0X00085C // GameTime_t
    m_vecFinishOrigin = 0X000860 // Vector
    m_vecOriginalAngles = 0X00086C // QAngle
    m_vecFinishAngles = 0X000878 // QAngle
    m_bPreventChangesWhileMoving = 0X000884 // bool
    m_bDisabled = 0X000885 // bool
    m_vecTeleportOrigin = 0X000888 // Vector
    m_flAbortedPlaybackAt = 0X000894 // GameTime_t
    m_pOnCommentaryStarted = 0X000898 // CEntityIOOutput
    m_pOnCommentaryStopped = 0X0008C0 // CEntityIOOutput
    m_bActive = 0X0008E8 // bool
    m_flStartTime = 0X0008EC // GameTime_t
    m_flStartTimeInCommentary = 0X0008F0 // float32
    m_iszTitle = 0X0008F8 // CUtlSymbolLarge
    m_iszSpeakers = 0X000900 // CUtlSymbolLarge
    m_iNodeNumber = 0X000908 // int32
    m_iNodeNumberMax = 0X00090C // int32
    m_bListenedTo = 0X000910 // bool

 CCommentaryViewPosition: [server.dll]
    No schemes available

 CFuncWater: [server.dll]
    No schemes available

 CRotDoor: [server.dll]
    m_bSolidBsp = 0X000978 // bool

 CItemSoda: [server.dll]
    No schemes available

 CPrecipitation: [server.dll]
    No schemes available

 CEnvBeam: [server.dll]
    m_active = 0X000790 // int32
    m_spriteTexture = 0X000798 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_iszStartEntity = 0X0007A0 // CUtlSymbolLarge
    m_iszEndEntity = 0X0007A8 // CUtlSymbolLarge
    m_life = 0X0007B0 // float32
    m_boltWidth = 0X0007B4 // float32
    m_noiseAmplitude = 0X0007B8 // float32
    m_speed = 0X0007BC // int32
    m_restrike = 0X0007C0 // float32
    m_iszSpriteName = 0X0007C8 // CUtlSymbolLarge
    m_frameStart = 0X0007D0 // int32
    m_vEndPointWorld = 0X0007D4 // Vector
    m_vEndPointRelative = 0X0007E0 // Vector
    m_radius = 0X0007EC // float32
    m_TouchType = 0X0007F0 // Touch_t
    m_iFilterName = 0X0007F8 // CUtlSymbolLarge
    m_hFilter = 0X000800 // CHandle< CBaseEntity >
    m_iszDecal = 0X000808 // CUtlSymbolLarge
    m_OnTouchedByEntity = 0X000810 // CEntityIOOutput

 CPushable: [server.dll]
    No schemes available

 CFuncLadderAlias_func_useableladder: [server.dll]
    No schemes available

 CFuncMonitor: [server.dll]
    m_targetCamera = 0X000710 // CUtlString
    m_nResolutionEnum = 0X000718 // int32
    m_bRenderShadows = 0X00071C // bool
    m_bUseUniqueColorTarget = 0X00071D // bool
    m_brushModelName = 0X000720 // CUtlString
    m_hTargetCamera = 0X000728 // CHandle< CBaseEntity >
    m_bEnabled = 0X00072C // bool
    m_bDraw3DSkybox = 0X00072D // bool
    m_bStartEnabled = 0X00072E // bool

 CFuncMoveLinearAlias_momentary_door: [server.dll]
    No schemes available

 CFuncWaterAnalog: [server.dll]
    No schemes available

 CGunTarget: [server.dll]
    m_on = 0X000770 // bool
    m_hTargetEnt = 0X000774 // CHandle< CBaseEntity >
    m_OnDeath = 0X000778 // CEntityIOOutput

 CTriggerGameEvent: [server.dll]
    m_strStartTouchEventName = 0X000898 // CUtlString
    m_strEndTouchEventName = 0X0008A0 // CUtlString
    m_strTriggerID = 0X0008A8 // CUtlString

 CSimpleMarkupVolumeTagged: [server.dll]
    No schemes available

 CMarkupVolumeTagged_Nav: [server.dll]
    No schemes available

 CMarkupVolumeTagged_NavGame: [server.dll]
    m_bFloodFillAttribute = 0X000748 // bool

 CFuncElectrifiedVolume: [server.dll]
    m_EffectName = 0X000710 // CUtlSymbolLarge
    m_EffectInterpenetrateName = 0X000718 // CUtlSymbolLarge
    m_EffectZapName = 0X000720 // CUtlSymbolLarge
    m_iszEffectSource = 0X000728 // CUtlSymbolLarge

 CPathCornerCrash: [server.dll]
    No schemes available

 CConstraintAnchor: [server.dll]
    m_massScale = 0X000820 // float32

 COrnamentProp: [server.dll]
    m_initialOwner = 0X000A98 // CUtlSymbolLarge

 CRopeKeyframeAlias_move_rope: [server.dll]
    No schemes available

 CSceneEntityAlias_logic_choreographed_scene: [server.dll]
    No schemes available

 CInstancedSceneEntity: [server.dll]
    m_hOwner = 0X000A00 // CHandle< CBaseEntity >
    m_bHadOwner = 0X000A04 // bool
    m_flPostSpeakDelay = 0X000A08 // float32
    m_flPreDelay = 0X000A0C // float32
    m_bIsBackground = 0X000A10 // bool

 CTriggerSoundscape: [server.dll]
    m_hSoundscape = 0X000898 // CHandle< CEnvSoundscapeTriggerable >
    m_SoundscapeName = 0X0008A0 // CUtlSymbolLarge
    m_spectators = 0X0008A8 // CUtlVector< CHandle< CBasePlayerPawn > >

 CSpriteAlias_env_glow: [server.dll]
    No schemes available

 CFuncTankTrain: [server.dll]
    m_OnDeath = 0X000828 // CEntityIOOutput

 CBasePlatTrain: [server.dll]
    m_NoiseMoving = 0X000770 // CUtlSymbolLarge
    m_NoiseArrived = 0X000778 // CUtlSymbolLarge
    m_volume = 0X000788 // float32
    m_flTWidth = 0X00078C // float32
    m_flTLength = 0X000790 // float32

 CFuncPlat: [server.dll]
    m_sNoise = 0X000798 // CUtlSymbolLarge

 CFuncPlatRot: [server.dll]
    m_end = 0X0007A0 // QAngle
    m_start = 0X0007AC // QAngle

 CFuncTrain: [server.dll]
    m_hCurrentTarget = 0X000798 // CHandle< CBaseEntity >
    m_activated = 0X00079C // bool
    m_hEnemy = 0X0007A0 // CHandle< CBaseEntity >
    m_flBlockDamage = 0X0007A4 // float32
    m_flNextBlockTime = 0X0007A8 // GameTime_t
    m_iszLastTarget = 0X0007B0 // CUtlSymbolLarge

 CFuncTrackChange: [server.dll]
    m_trackTop = 0X0007B8 // CPathTrack*
    m_trackBottom = 0X0007C0 // CPathTrack*
    m_train = 0X0007C8 // CFuncTrackTrain*
    m_trackTopName = 0X0007D0 // CUtlSymbolLarge
    m_trackBottomName = 0X0007D8 // CUtlSymbolLarge
    m_trainName = 0X0007E0 // CUtlSymbolLarge
    m_code = 0X0007E8 // TRAIN_CODE
    m_targetState = 0X0007EC // int32
    m_use = 0X0007F0 // int32

 CFuncTrackAuto: [server.dll]
    No schemes available

 CTriggerRemove: [server.dll]
    m_OnRemove = 0X000898 // CEntityIOOutput

 CScriptTriggerHurt: [server.dll]
    m_vExtent = 0X000938 // Vector

 CScriptTriggerMultiple: [server.dll]
    m_vExtent = 0X0008C0 // Vector

 CTriggerOnce: [server.dll]
    No schemes available

 CScriptTriggerOnce: [server.dll]
    m_vExtent = 0X0008C0 // Vector

 CTriggerLook: [server.dll]
    m_hLookTarget = 0X0008C0 // CHandle< CBaseEntity >
    m_flFieldOfView = 0X0008C4 // float32
    m_flLookTime = 0X0008C8 // float32
    m_flLookTimeTotal = 0X0008CC // float32
    m_flLookTimeLast = 0X0008D0 // GameTime_t
    m_flTimeoutDuration = 0X0008D4 // float32
    m_bTimeoutFired = 0X0008D8 // bool
    m_bIsLooking = 0X0008D9 // bool
    m_b2DFOV = 0X0008DA // bool
    m_bUseVelocity = 0X0008DB // bool
    m_hActivator = 0X0008DC // CHandle< CBaseEntity >
    m_bTestOcclusion = 0X0008E0 // bool
    m_OnTimeout = 0X0008E8 // CEntityIOOutput
    m_OnStartLook = 0X000910 // CEntityIOOutput
    m_OnEndLook = 0X000938 // CEntityIOOutput

 CTriggerPush: [server.dll]
    m_angPushEntitySpace = 0X000898 // QAngle
    m_vecPushDirEntitySpace = 0X0008A4 // Vector
    m_bTriggerOnStartTouch = 0X0008B0 // bool
    m_flAlternateTicksFix = 0X0008B4 // float32
    m_flPushSpeed = 0X0008B8 // float32

 CScriptTriggerPush: [server.dll]
    m_vExtent = 0X0008C0 // Vector

 CTriggerToggleSave: [server.dll]
    m_bDisabled = 0X000898 // bool

 CTriggerSave: [server.dll]
    m_bForceNewLevelUnit = 0X000898 // bool
    m_fDangerousTimer = 0X00089C // float32
    m_minHitPoints = 0X0008A0 // int32

 CTriggerGravity: [server.dll]
    No schemes available

 CTriggerProximity: [server.dll]
    m_hMeasureTarget = 0X000898 // CHandle< CBaseEntity >
    m_iszMeasureTarget = 0X0008A0 // CUtlSymbolLarge
    m_fRadius = 0X0008A8 // float32
    m_nTouchers = 0X0008AC // int32
    m_NearestEntityDistance = 0X0008B0 // CEntityOutputTemplate< float32 >

 CTriggerImpact: [server.dll]
    m_flMagnitude = 0X0008C0 // float32
    m_flNoise = 0X0008C4 // float32
    m_flViewkick = 0X0008C8 // float32
    m_pOutputForce = 0X0008D0 // CEntityOutputTemplate< Vector >

 CServerRagdollTrigger: [server.dll]
    No schemes available

 CTriggerActiveWeaponDetect: [server.dll]
    m_OnTouchedActiveWeapon = 0X000898 // CEntityIOOutput
    m_iszWeaponClassName = 0X0008C0 // CUtlSymbolLarge

 CTriggerPhysics: [server.dll]
    m_gravityScale = 0X0008A8 // float32
    m_linearLimit = 0X0008AC // float32
    m_linearDamping = 0X0008B0 // float32
    m_angularLimit = 0X0008B4 // float32
    m_angularDamping = 0X0008B8 // float32
    m_linearForce = 0X0008BC // float32
    m_flFrequency = 0X0008C0 // float32
    m_flDampingRatio = 0X0008C4 // float32
    m_vecLinearForcePointAt = 0X0008C8 // Vector
    m_bCollapseToForcePoint = 0X0008D4 // bool
    m_vecLinearForcePointAtWorld = 0X0008D8 // Vector
    m_vecLinearForceDirection = 0X0008E4 // Vector
    m_bConvertToDebrisWhenPossible = 0X0008F0 // bool

 CTriggerDetectBulletFire: [server.dll]
    m_bPlayerFireOnly = 0X000898 // bool
    m_OnDetectedBulletFire = 0X0008A0 // CEntityIOOutput

 CTriggerDetectExplosion: [server.dll]
    m_OnDetectedExplosion = 0X0008D0 // CEntityIOOutput

 CScriptNavBlocker: [server.dll]
    m_vExtent = 0X000700 // Vector

 CBaseFlex: [server.dll]
    m_flexWeight = 0X000820 // CNetworkUtlVectorBase< float32 >
    m_vLookTargetPosition = 0X000838 // Vector
    m_blinktoggle = 0X000844 // bool
    m_flAllowResponsesEndTime = 0X000898 // GameTime_t
    m_flLastFlexAnimationTime = 0X00089C // GameTime_t
    m_nNextSceneEventId = 0X0008A0 // uint32
    m_bUpdateLayerPriorities = 0X0008A4 // bool

 CBasePropDoor: [server.dll]
    m_flAutoReturnDelay = 0X000AA8 // float32
    m_hDoorList = 0X000AB0 // CUtlVector< CHandle< CBasePropDoor > >
    m_nHardwareType = 0X000AC8 // int32
    m_bNeedsHardware = 0X000ACC // bool
    m_eDoorState = 0X000AD0 // DoorState_t
    m_bLocked = 0X000AD4 // bool
    m_closedPosition = 0X000AD8 // Vector
    m_closedAngles = 0X000AE4 // QAngle
    m_hBlocker = 0X000AF0 // CHandle< CBaseEntity >
    m_bFirstBlocked = 0X000AF4 // bool
    m_ls = 0X000AF8 // locksound_t
    m_bForceClosed = 0X000B18 // bool
    m_vecLatchWorldPosition = 0X000B1C // Vector
    m_hActivator = 0X000B28 // CHandle< CBaseEntity >
    m_sndParamAngularSpeed = 0X000B34 // uint32
    m_SoundMoving = 0X000B38 // CUtlSymbolLarge
    m_SoundOpen = 0X000B40 // CUtlSymbolLarge
    m_SoundClose = 0X000B48 // CUtlSymbolLarge
    m_SoundLock = 0X000B50 // CUtlSymbolLarge
    m_SoundUnlock = 0X000B58 // CUtlSymbolLarge
    m_SoundLatch = 0X000B60 // CUtlSymbolLarge
    m_SoundPound = 0X000B68 // CUtlSymbolLarge
    m_SoundJiggle = 0X000B70 // CUtlSymbolLarge
    m_SoundLockedAnim = 0X000B78 // CUtlSymbolLarge
    m_numCloseAttempts = 0X000B80 // int32
    m_nPhysicsMaterial = 0X000B84 // CUtlStringToken
    m_SlaveName = 0X000B88 // CUtlSymbolLarge
    m_hMaster = 0X000B90 // CHandle< CBasePropDoor >
    m_OnBlockedClosing = 0X000B98 // CEntityIOOutput
    m_OnBlockedOpening = 0X000BC0 // CEntityIOOutput
    m_OnUnblockedClosing = 0X000BE8 // CEntityIOOutput
    m_OnUnblockedOpening = 0X000C10 // CEntityIOOutput
    m_OnFullyClosed = 0X000C38 // CEntityIOOutput
    m_OnFullyOpen = 0X000C60 // CEntityIOOutput
    m_OnClose = 0X000C88 // CEntityIOOutput
    m_OnOpen = 0X000CB0 // CEntityIOOutput
    m_OnLockedUse = 0X000CD8 // CEntityIOOutput
    m_OnAjarOpen = 0X000D00 // CEntityIOOutput

 CEnvLaser: [server.dll]
    m_iszLaserTarget = 0X000790 // CUtlSymbolLarge
    m_pSprite = 0X000798 // CSprite*
    m_iszSpriteName = 0X0007A0 // CUtlSymbolLarge
    m_firePosition = 0X0007A8 // Vector
    m_flStartFrame = 0X0007B4 // float32

 CFish: [server.dll]
    m_pool = 0X000820 // CHandle< CFishPool >
    m_id = 0X000824 // uint32
    m_x = 0X000828 // float32
    m_y = 0X00082C // float32
    m_z = 0X000830 // float32
    m_angle = 0X000834 // float32
    m_angleChange = 0X000838 // float32
    m_forward = 0X00083C // Vector
    m_perp = 0X000848 // Vector
    m_poolOrigin = 0X000854 // Vector
    m_waterLevel = 0X000860 // float32
    m_speed = 0X000864 // float32
    m_desiredSpeed = 0X000868 // float32
    m_calmSpeed = 0X00086C // float32
    m_panicSpeed = 0X000870 // float32
    m_avoidRange = 0X000874 // float32
    m_turnTimer = 0X000878 // CountdownTimer
    m_turnClockwise = 0X000890 // bool
    m_goTimer = 0X000898 // CountdownTimer
    m_moveTimer = 0X0008B0 // CountdownTimer
    m_panicTimer = 0X0008C8 // CountdownTimer
    m_disperseTimer = 0X0008E0 // CountdownTimer
    m_proximityTimer = 0X0008F8 // CountdownTimer
    m_visible = 0X000910 // CUtlVector< CFish* >

 CItem: [server.dll]
    m_OnPlayerTouch = 0X000828 // CEntityIOOutput
    m_bActivateWhenAtRest = 0X000850 // bool
    m_OnCacheInteraction = 0X000858 // CEntityIOOutput
    m_OnPlayerPickup = 0X000880 // CEntityIOOutput
    m_OnGlovePulled = 0X0008A8 // CEntityIOOutput
    m_vOriginalSpawnOrigin = 0X0008D0 // Vector
    m_vOriginalSpawnAngles = 0X0008DC // QAngle
    m_bPhysStartAsleep = 0X0008E8 // bool

 CRagdollProp: [server.dll]
    m_ragdoll = 0X000828 // ragdoll_t
    m_bStartDisabled = 0X000860 // bool
    m_ragPos = 0X000868 // CNetworkUtlVectorBase< Vector >
    m_ragAngles = 0X000880 // CNetworkUtlVectorBase< QAngle >
    m_hRagdollSource = 0X000898 // CHandle< CBaseEntity >
    m_lastUpdateTickCount = 0X00089C // uint32
    m_allAsleep = 0X0008A0 // bool
    m_bFirstCollisionAfterLaunch = 0X0008A1 // bool
    m_hDamageEntity = 0X0008A4 // CHandle< CBaseEntity >
    m_hKiller = 0X0008A8 // CHandle< CBaseEntity >
    m_hPhysicsAttacker = 0X0008AC // CHandle< CBasePlayerPawn >
    m_flLastPhysicsInfluenceTime = 0X0008B0 // GameTime_t
    m_flFadeOutStartTime = 0X0008B4 // GameTime_t
    m_flFadeTime = 0X0008B8 // float32
    m_vecLastOrigin = 0X0008BC // Vector
    m_flAwakeTime = 0X0008C8 // GameTime_t
    m_flLastOriginChangeTime = 0X0008CC // GameTime_t
    m_nBloodColor = 0X0008D0 // int32
    m_strOriginClassName = 0X0008D8 // CUtlSymbolLarge
    m_strSourceClassName = 0X0008E0 // CUtlSymbolLarge
    m_bHasBeenPhysgunned = 0X0008E8 // bool
    m_bShouldTeleportPhysics = 0X0008E9 // bool
    m_flBlendWeight = 0X0008EC // float32
    m_flDefaultFadeScale = 0X0008F0 // float32
    m_ragdollMins = 0X0008F8 // CUtlVector< Vector >
    m_ragdollMaxs = 0X000910 // CUtlVector< Vector >
    m_bShouldDeleteActivationRecord = 0X000928 // bool
    m_bValidatePoweredRagdollPose = 0X000988 // bool

 CPhysMagnet: [server.dll]
    m_OnMagnetAttach = 0X000820 // CEntityIOOutput
    m_OnMagnetDetach = 0X000848 // CEntityIOOutput
    m_massScale = 0X000870 // float32
    m_forceLimit = 0X000874 // float32
    m_torqueLimit = 0X000878 // float32
    m_MagnettedEntities = 0X000880 // CUtlVector< magnetted_objects_t >
    m_bActive = 0X000898 // bool
    m_bHasHitSomething = 0X000899 // bool
    m_flTotalMass = 0X00089C // float32
    m_flRadius = 0X0008A0 // float32
    m_flNextSuckTime = 0X0008A4 // GameTime_t
    m_iMaxObjectsAttached = 0X0008A8 // int32

 CPhysicsProp: [server.dll]
    m_MotionEnabled = 0X0009A0 // CEntityIOOutput
    m_OnAwakened = 0X0009C8 // CEntityIOOutput
    m_OnAwake = 0X0009F0 // CEntityIOOutput
    m_OnAsleep = 0X000A18 // CEntityIOOutput
    m_OnPlayerUse = 0X000A40 // CEntityIOOutput
    m_OnPlayerPickup = 0X000A68 // CEntityIOOutput
    m_OnOutOfWorld = 0X000A90 // CEntityIOOutput
    m_massScale = 0X000AB8 // float32
    m_inertiaScale = 0X000ABC // float32
    m_damageType = 0X000AC0 // int32
    m_damageToEnableMotion = 0X000AC4 // int32
    m_flForceToEnableMotion = 0X000AC8 // float32
    m_bThrownByPlayer = 0X000ACC // bool
    m_bDroppedByPlayer = 0X000ACD // bool
    m_bTouchedByPlayer = 0X000ACE // bool
    m_bFirstCollisionAfterLaunch = 0X000ACF // bool
    m_iExploitableByPlayer = 0X000AD0 // int32
    m_bHasBeenAwakened = 0X000AD4 // bool
    m_bIsOverrideProp = 0X000AD5 // bool
    m_fNextCheckDisableMotionContactsTime = 0X000AD8 // GameTime_t
    m_iInitialGlowState = 0X000ADC // int32
    m_nGlowRange = 0X000AE0 // int32
    m_nGlowRangeMin = 0X000AE4 // int32
    m_glowColor = 0X000AE8 // Color
    m_bForceNavIgnore = 0X000AEC // bool
    m_bNoNavmeshBlocker = 0X000AED // bool
    m_bForceNpcExclude = 0X000AEE // bool
    m_bShouldAutoConvertBackFromDebris = 0X000AEF // bool
    m_bMuteImpactEffects = 0X000AF0 // bool
    m_bAcceptDamageFromHeldObjects = 0X000AF8 // bool
    m_bEnableUseOutput = 0X000AF9 // bool
    m_bAwake = 0X000AFA // bool
    m_nCollisionGroupOverride = 0X000AFC // int32

 CPhysicsPropOverride: [server.dll]
    No schemes available

 CPhysicsPropRespawnable: [server.dll]
    m_vOriginalSpawnOrigin = 0X000B00 // Vector
    m_vOriginalSpawnAngles = 0X000B0C // QAngle
    m_vOriginalMins = 0X000B18 // Vector
    m_vOriginalMaxs = 0X000B24 // Vector
    m_flRespawnDuration = 0X000B30 // float32

 CWaterBullet: [server.dll]
    No schemes available

 CShatterGlassShardPhysics: [server.dll]
    m_bDebris = 0X000B00 // bool
    m_hParentShard = 0X000B04 // uint32
    m_ShardDesc = 0X000B08 // shard_model_desc_t

 CEconEntity: [server.dll]
    m_AttributeManager = 0X0008C0 // CAttributeContainer
    m_OriginalOwnerXuidLow = 0X000B88 // uint32
    m_OriginalOwnerXuidHigh = 0X000B8C // uint32
    m_nFallbackPaintKit = 0X000B90 // int32
    m_nFallbackSeed = 0X000B94 // int32
    m_flFallbackWear = 0X000B98 // float32
    m_nFallbackStatTrak = 0X000B9C // int32
    m_hOldProvidee = 0X000BA0 // CHandle< CBaseEntity >
    m_iOldOwnerClass = 0X000BA4 // int32

 CEconWearable: [server.dll]
    m_nForceSkin = 0X000BA8 // int32
    m_bAlwaysAllow = 0X000BAC // bool

 CBaseGrenade: [server.dll]
    m_OnPlayerPickup = 0X0008B8 // CEntityIOOutput
    m_OnExplode = 0X0008E0 // CEntityIOOutput
    m_bHasWarnedAI = 0X000908 // bool
    m_bIsSmokeGrenade = 0X000909 // bool
    m_bIsLive = 0X00090A // bool
    m_DmgRadius = 0X00090C // float32
    m_flDetonateTime = 0X000910 // GameTime_t
    m_flWarnAITime = 0X000914 // float32
    m_flDamage = 0X000918 // float32
    m_iszBounceSound = 0X000920 // CUtlSymbolLarge
    m_ExplosionSound = 0X000928 // CUtlString
    m_hThrower = 0X000934 // CHandle< CBaseEntity >
    m_flNextAttack = 0X000950 // GameTime_t
    m_hOriginalThrower = 0X000954 // CHandle< CBaseEntity >

 CCoopBonusCoin: [server.dll]
    No schemes available

 CBRC4Target: [server.dll]
    m_hPlayerThatActivatedMe = 0X000848 // CHandle< CBaseEntity >
    m_bBrokenOpen = 0X00084C // bool
    m_flRadius = 0X000850 // float32

 CParadropChopper: [server.dll]
    m_vecDropPos = 0X000824 // Vector
    m_flLastDistFromDrop = 0X000830 // float32
    m_bDroppedParadrop = 0X000834 // bool
    m_pSoundLoop = 0X000838 // CSoundPatch*
    m_flSpawnTime = 0X000840 // float32
    m_flFlightTime = 0X000844 // float32
    m_bPlayerIsFinishedRappelling = 0X000848 // bool
    m_flPlayerFinishedRappellingTime = 0X00084C // GameTime_t
    m_strFlyoverDropEvent = 0X000850 // CUtlString
    m_hCallingPlayer = 0X000858 // CHandle< CBaseEntity >
    m_bCalledByPlayer = 0X00085C // bool

 CSurvivalSpawnChopper: [server.dll]
    m_pSoundLoop = 0X000820 // CSoundPatch*
    m_flSpawnTimeStamp = 0X000828 // GameTime_t
    m_flFlightPathRotationOffset = 0X00082C // float32
    m_bFlipX = 0X000830 // bool
    m_bFlipY = 0X000831 // bool
    m_bCircling = 0X000832 // bool
    m_flLastPassengerCheckTime = 0X000834 // GameTime_t

 CItemCash: [server.dll]
    m_bufCashOriginalSource = 0X0008F8 // char[64]
    m_nBundleSize = 0X000938 // int32
    m_flAllowPickupTime = 0X000940 // float32

 CDronegun: [server.dll]
    m_vecAttentionTarget = 0X000830 // Vector
    m_vecTargetOffset = 0X00083C // Vector
    m_bHasTarget = 0X000848 // bool
    m_vecAttentionCurrent = 0X00084C // Vector
    m_nPoseParamPitch = 0X000858 // int32
    m_nPoseParamYaw = 0X00085C // int32
    m_bVarInit = 0X000860 // bool
    m_flDisorientEndTime = 0X000864 // GameTime_t
    m_hEnvGunfire = 0X000880 // CHandle< CBaseEntity >
    m_flLastShootTime = 0X000884 // GameTime_t
    m_flLastSound1 = 0X000888 // GameTime_t
    m_flLastSound2 = 0X00088C // GameTime_t
    m_flLastSound3 = 0X000890 // GameTime_t
    m_nAttachMuzzle = 0X000894 // AttachmentHandle_t

 CDrone: [server.dll]
    m_hMoveToThisEntity = 0X000B18 // CEntityHandle
    m_hDeliveryCargo = 0X000B1C // CEntityHandle
    m_hRecentCargo = 0X000B20 // CEntityHandle
    m_bPilotTakeoverAllowed = 0X000B24 // bool
    m_hPotentialCargo = 0X000B28 // CEntityHandle
    m_hCurrentPilot = 0X000B2C // CEntityHandle
    m_vecTagPositions = 0X000B30 // Vector[24]
    m_vecTagIncrements = 0X000C50 // int32[24]
    m_flLastUpdateTargetScanTime = 0X000CB0 // GameTime_t
    m_bWasControlledByPlayer = 0X000CB4 // bool
    m_bHovering = 0X000CB5 // bool
    m_pStateSound = 0X000CB8 // CSoundPatch*
    m_vecGroundOffset = 0X000CC0 // Vector
    m_bQueuingOrders = 0X000CE8 // bool
    m_flLastOrdersChangeTimestamp = 0X000CEC // GameTime_t
    m_vecLastKnownAcceleration = 0X000CF0 // Vector
    m_vecLastKnownVelocity = 0X000CFC // Vector
    m_vecLastKnownAngImpulse = 0X000D08 // RotationVector
    m_flLastKnownSpeed = 0X000D14 // float32
    m_flMaxSpeed = 0X000D18 // float32
    m_vecCurrentDestination = 0X000D1C // Vector
    m_flLastKnownDistanceToDestination = 0X000D28 // float32
    m_flLastKnownWaypointAccuracy = 0X000D2C // float32
    m_vecWaypointQueue = 0X000D30 // CUtlVector< Vector >
    m_vecSparsePositionHistory = 0X000D48 // CUtlVector< Vector >
    m_vecPositionHistory = 0X000D60 // CUtlVector< Vector >
    m_vecUnstuckQueue = 0X000D78 // CUtlVector< Vector >
    m_flLastKnownGroundHeight = 0X000D90 // float32
    m_GroundCheckTimer = 0X000D98 // CountdownTimer
    m_ActInjuredTimer = 0X000DB0 // CountdownTimer
    m_flPowerCutUntil = 0X000DC8 // GameTime_t
    m_WanderTimer = 0X000DD0 // CountdownTimer
    m_flLastTimeSawAttackTarget = 0X000DE8 // GameTime_t
    m_vecLastKnownAttackTargetPosition = 0X000DEC // Vector
    m_hAttackTarget = 0X000DF8 // CHandle< CBaseEntity >
    m_IntervalThinkTimer = 0X000E00 // CountdownTimer
    m_bDoIntervalThink = 0X000E18 // bool
    m_flLastDroppedGrenadeAt = 0X000E1C // GameTime_t
    m_flSpawnTimeStamp = 0X000E20 // GameTime_t
    m_bInPlayArea = 0X000E24 // bool
    m_vecSpawnPosition = 0X000E28 // Vector
    m_vecLastKnownMoveToEntityPosition = 0X000E34 // Vector
    m_tCargoCollisionGroup = 0X000E40 // int32
    m_flTimeArrivedAtMoveToEntity = 0X000E44 // GameTime_t
    m_vecAvoidanceDir = 0X000E48 // Vector
    m_flAvoidanceTime = 0X000E54 // GameTime_t
    m_bUpgraded = 0X000E58 // bool
    m_hCargoOwner = 0X000E5C // CHandle< CBasePlayerPawn >
    m_vecPlayerControlThrust = 0X000E68 // Vector
    m_flRopeLength = 0X000E74 // float32
    m_bDidDropOnRoofWarning = 0X000E78 // bool
    m_flSelfDestructTime = 0X000E7C // GameTime_t
    m_bSelfDestructFire = 0X000E80 // bool
    m_bSelfDestructSpark = 0X000E81 // bool
    m_hLastKnownPilot = 0X000E84 // CEntityHandle
    m_bHasAlwaysBeenInZone = 0X000E88 // bool
    m_nJammedAmount = 0X000E8C // int32
    m_hPlayerThatOrderedMe = 0X000E90 // CHandle< CBaseEntity >

 CCSPropExplodingBarrel: [server.dll]
    m_hBarrelTop = 0X000B08 // CEntityHandle
    m_bExploded = 0X000B0C // bool
    m_nAccumulatedDamage = 0X000B10 // int32

 CCSPropExplodingBarrelTop: [server.dll]
    m_flOverrideAlpha = 0X000B00 // float32

 CEnvGasCanister: [server.dll]
    m_bLanded = 0X000820 // bool
    m_flDamageRadius = 0X000824 // float32
    m_flDamage = 0X000828 // float32
    m_bIncomingSoundStarted = 0X00082C // bool
    m_bHasDetonated = 0X00082D // bool
    m_bLaunched = 0X00082E // bool
    m_OnLaunched = 0X000830 // CEntityOutputTemplate< CHandle< CBaseEntity > >
    m_OnImpacted = 0X000858 // CEntityIOOutput
    m_OnOpened = 0X000880 // CEntityIOOutput
    m_vecImpactPosition = 0X0008A8 // Vector
    m_vecStartPosition = 0X0008B4 // Vector
    m_vecEnterWorldPosition = 0X0008C0 // Vector
    m_vecDirection = 0X0008CC // Vector
    m_vecStartAngles = 0X0008D8 // QAngle
    m_flFlightTime = 0X0008E4 // float32
    m_flFlightSpeed = 0X0008E8 // float32
    m_flLaunchTime = 0X0008EC // GameTime_t
    m_flInitialZSpeed = 0X0008F0 // float32
    m_flZAcceleration = 0X0008F4 // float32
    m_flHorizSpeed = 0X0008F8 // float32
    m_bLaunchedFromWithinWorld = 0X0008FC // bool
    m_vecParabolaDirection = 0X000900 // Vector
    m_flWorldEnterTime = 0X00090C // float32
    m_vecSkyboxOrigin = 0X000910 // Vector
    m_flSkyboxScale = 0X00091C // float32
    m_bInSkybox = 0X000920 // bool
    m_bDoImpactEffects = 0X000921 // bool
    m_nMyZoneIndex = 0X000924 // int32
    m_hSkyboxCopy = 0X000928 // CHandle< CBaseEntity >
    m_flLaunchHeight = 0X00092C // float32

 CPropCounter: [server.dll]
    m_flDisplayValue = 0X000820 // float32
    m_nInitialValue = 0X000824 // int32

 CBaseViewModel: [server.dll]
    m_vecLastFacing = 0X000828 // Vector
    m_nViewModelIndex = 0X000834 // uint32
    m_nAnimationParity = 0X000838 // uint32
    m_flAnimationStartTime = 0X00083C // float32
    m_hWeapon = 0X000840 // CHandle< CBasePlayerWeapon >
    m_sVMName = 0X000848 // CUtlSymbolLarge
    m_sAnimationPrefix = 0X000850 // CUtlSymbolLarge
    m_hOldLayerSequence = 0X000858 // HSequence
    m_oldLayer = 0X00085C // int32
    m_oldLayerStartTime = 0X000860 // float32
    m_hControlPanel = 0X000864 // CEntityHandle

 CPredictedViewModel: [server.dll]
    No schemes available

 CPlantedC4: [server.dll]
    m_bPlantedAtQuestTarget = 0X000820 // bool
    m_bBombTicking = 0X000821 // bool
    m_flC4Blow = 0X000824 // GameTime_t
    m_nBombSite = 0X000828 // int32
    m_nSourceSoundscapeHash = 0X00082C // int32
    m_OnBombDefused = 0X000830 // CEntityIOOutput
    m_OnBombBeginDefuse = 0X000858 // CEntityIOOutput
    m_OnBombDefuseAborted = 0X000880 // CEntityIOOutput
    m_bCannotBeDefused = 0X0008A8 // bool
    m_entitySpottedState = 0X0008B0 // EntitySpottedState_t
    m_nSpotRules = 0X0008C8 // int32
    m_bTrainingPlacedByPlayer = 0X0008CC // bool
    m_bHasExploded = 0X0008CD // bool
    m_flTimerLength = 0X0008D0 // float32
    m_bBeingDefused = 0X0008D4 // bool
    m_fLastDefuseTime = 0X0008DC // GameTime_t
    m_flDefuseLength = 0X0008E4 // float32
    m_flDefuseCountDown = 0X0008E8 // GameTime_t
    m_bBombDefused = 0X0008EC // bool
    m_hBombDefuser = 0X0008F0 // CHandle< CCSPlayerPawnBase >
    m_hControlPanel = 0X0008F4 // CEntityHandle
    m_iProgressBarTime = 0X0008F8 // int32
    m_bVoiceAlertFired = 0X0008FC // bool
    m_bVoiceAlertPlayed = 0X0008FD // bool[4]
    m_flNextBotBeepTime = 0X000904 // GameTime_t
    m_bPlantedAfterPickup = 0X00090C // bool
    m_angCatchUpToPlayerEye = 0X000910 // QAngle
    m_flLastSpinDetectionTime = 0X00091C // GameTime_t

 CBaseCSGrenadeProjectile: [server.dll]
    m_vInitialVelocity = 0X000958 // Vector
    m_nBounces = 0X000964 // int32
    m_nExplodeEffectIndex = 0X000968 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_nExplodeEffectTickBegin = 0X000970 // int32
    m_vecExplodeEffectOrigin = 0X000974 // Vector
    m_unOGSExtraFlags = 0X000980 // uint8
    m_bDetonationRecorded = 0X000981 // bool
    m_flDetonateTime = 0X000984 // GameTime_t
    m_nItemIndex = 0X000988 // uint16
    m_vecOriginalSpawnLocation = 0X00098C // Vector
    m_flLastBounceSoundTime = 0X000998 // GameTime_t

 CItemDogtags: [server.dll]
    m_OwningPlayer = 0X0008F8 // CHandle< CCSPlayerPawnBase >
    m_KillingPlayer = 0X0008FC // CHandle< CCSPlayerPawnBase >

 CBreachChargeProjectile: [server.dll]
    m_bShouldExplode = 0X000958 // bool
    m_weaponThatThrewMe = 0X00095C // CHandle< CBaseEntity >
    m_nParentBoneIndex = 0X000960 // int32
    m_vecParentBonePos = 0X000964 // Vector
    m_bDefused = 0X000970 // bool
    m_bUnstuckFromPlayer = 0X000971 // bool
    m_bResolvedParent = 0X000972 // bool
    m_vecLastKnownValidPos = 0X000974 // Vector
    m_hDesiredParent = 0X000980 // CEntityHandle

 CBumpMineProjectile: [server.dll]
    m_bShouldExplode = 0X000958 // bool
    m_nParentBoneIndex = 0X00095C // int32
    m_vecParentBonePos = 0X000960 // Vector
    m_bArmed = 0X00096C // bool
    m_bDefused = 0X00096D // bool
    m_bUnstuckFromPlayer = 0X00096E // bool
    m_vecTargetedObjects = 0X000970 // CUtlVector< CHandle< CBaseEntity > >
    m_bResolvedParent = 0X0009B0 // bool
    m_vecLastKnownValidPos = 0X0009B4 // Vector
    m_hDesiredParent = 0X0009C0 // CEntityHandle
    m_bBeingUsed = 0X0009C4 // bool

 CTripWireFireProjectile: [server.dll]
    m_flAttachTime = 0X000958 // GameTime_t
    m_vecTripWireEndPositions = 0X00095C // Vector[10]
    m_bTripWireEndPositionsUsed = 0X0009D4 // bool[10]
    m_hStuckToEnt = 0X0009E0 // CHandle< CBaseEntity >
    m_nLastStuckToEntModelIndex = 0X0009E4 // int32
    m_xformStuckToEnt = 0X0009F0 // CTransform
    m_vecTrapSetPosition = 0X000A10 // Vector
    m_nWireSoundsPlayed = 0X000A1C // int32

 CPhysicsPropMultiplayer: [server.dll]
    No schemes available

 CBrBaseItem: [server.dll]
    No schemes available

 CPhysPropLootCrate: [server.dll]
    m_bRenderInPSPM = 0X000B28 // bool
    m_bRenderInTablet = 0X000B29 // bool
    m_flSpawnTime = 0X000B2C // GameTime_t
    m_bTakeDamageFromDangerZone = 0X000B30 // bool
    m_pszCrateName = 0X000B38 // char*
    m_hCrateOwner = 0X000B40 // CHandle< CBasePlayerPawn >
    m_bOwnedByPlayer = 0X000B44 // bool
    m_flDampingOriginalSpeed = 0X000B48 // float32
    m_flDampingOriginalRot = 0X000B4C // float32

 CPhysPropMetalCrate: [server.dll]
    No schemes available

 CPhysPropMoneyCrate: [server.dll]
    m_nCurrentCashCount = 0X000B50 // int32
    m_nCashCount = 0X000B54 // int32
    m_flTimeLastUsed = 0X000B58 // GameTime_t

 CPhysPropParadropCrate: [server.dll]
    m_bFalling = 0X000B50 // bool
    m_nNumThinksAtZeroVerticalVelocity = 0X000B54 // int32

 CPhysPropAmmoBox: [server.dll]
    m_nUsesRemaining = 0X000B28 // int32
    m_flTimeLastUsed = 0X000B2C // GameTime_t

 CPhysPropWeaponUpgrade: [server.dll]
    m_nEventPriority = 0X000B28 // int32
    m_flTimeLastUsed = 0X000B2C // GameTime_t

 CPhysPropRadarJammer: [server.dll]
    m_flSpawnTime = 0X000B30 // GameTime_t
    m_flLastSoundTime = 0X000B34 // GameTime_t
    m_vecJammedHexCenters = 0X000B38 // CUtlVector< int32 >
    m_vecLastJammedOrigin = 0X000B50 // Vector

 CSensorGrenadeProjectile: [server.dll]
    m_fExpireTime = 0X0009A0 // GameTime_t
    m_fNextDetectPlayerSound = 0X0009A4 // GameTime_t
    m_hDisplayGrenade = 0X0009A8 // CHandle< CBaseEntity >

 CFlashbangProjectile: [server.dll]
    m_flTimeToDetonate = 0X0009A0 // float32
    m_numOpponentsHit = 0X0009A4 // uint8
    m_numTeammatesHit = 0X0009A5 // uint8

 CHEGrenadeProjectile: [server.dll]
    No schemes available

 CPlantedC4Survival: [server.dll]
    No schemes available

 CChicken: [server.dll]
    m_AttributeManager = 0X000AB8 // CAttributeContainer
    m_OriginalOwnerXuidLow = 0X000D80 // uint32
    m_OriginalOwnerXuidHigh = 0X000D84 // uint32
    m_updateTimer = 0X000D88 // CountdownTimer
    m_stuckAnchor = 0X000DA0 // Vector
    m_stuckTimer = 0X000DB0 // CountdownTimer
    m_collisionStuckTimer = 0X000DC8 // CountdownTimer
    m_isOnGround = 0X000DE0 // bool
    m_activity = 0X000DE4 // ChickenActivity
    m_activityTimer = 0X000DE8 // CountdownTimer
    m_turnRate = 0X000E00 // float32
    m_fleeFrom = 0X000E04 // CHandle< CBaseEntity >
    m_moveRateThrottleTimer = 0X000E08 // CountdownTimer
    m_startleTimer = 0X000E20 // CountdownTimer
    m_vocalizeTimer = 0X000E38 // CountdownTimer
    m_flWhenZombified = 0X000E50 // GameTime_t
    m_jumpedThisFrame = 0X000E54 // bool
    m_leader = 0X000E58 // CHandle< CCSPlayerPawnBase >
    m_reuseTimer = 0X000E60 // CountdownTimer
    m_hasBeenUsed = 0X000E78 // bool
    m_jumpTimer = 0X000E80 // CountdownTimer
    m_flLastJumpTime = 0X000E98 // float32
    m_bInJump = 0X000E9C // bool
    m_isWaitingForLeader = 0X000E9D // bool
    m_repathTimer = 0X002EA8 // CountdownTimer
    m_inhibitDoorTimer = 0X002EC0 // CountdownTimer
    m_inhibitObstacleAvoidanceTimer = 0X002F50 // CountdownTimer
    m_vecPathGoal = 0X002F70 // Vector
    m_flActiveFollowStartTime = 0X002F7C // float32
    m_followMinuteTimer = 0X002F80 // CountdownTimer
    m_vecLastEggPoopPosition = 0X002F98 // Vector
    m_vecEggsPooped = 0X002FA8 // CUtlVector< CHandle< CBaseEntity > >
    m_BlockDirectionTimer = 0X002FC8 // CountdownTimer

 CHostageCarriableProp: [server.dll]
    No schemes available

 CItemAssaultSuit: [server.dll]
    No schemes available

 CItemHeavyAssaultSuit: [server.dll]
    No schemes available

 CItemKevlar: [server.dll]
    No schemes available

 CItemDefuser: [server.dll]
    m_entitySpottedState = 0X0008F8 // EntitySpottedState_t
    m_nSpotRules = 0X000910 // int32

 CBasePlayerWeapon: [server.dll]
    m_iState = 0X000BA8 // WeaponState_t
    m_bRemoveable = 0X000BAC // bool
    m_nNextPrimaryAttackTick = 0X000BB0 // GameTick_t
    m_flNextPrimaryAttackTickRatio = 0X000BB4 // float32
    m_nNextSecondaryAttackTick = 0X000BB8 // GameTick_t
    m_flNextSecondaryAttackTickRatio = 0X000BBC // float32
    m_iClip1 = 0X000BC0 // int32
    m_iClip2 = 0X000BC4 // int32
    m_pReserveAmmo = 0X000BC8 // int32[2]
    m_OnPlayerUse = 0X000BD0 // CEntityIOOutput

 CBaseFlexAlias_funCBaseFlex: [server.dll]
    No schemes available

 CScriptItem: [server.dll]
    m_OnPlayerPickup = 0X0008F8 // CEntityIOOutput
    m_MoveTypeOverride = 0X000920 // MoveType_t

 CRagdollPropAlias_physics_prop_ragdoll: [server.dll]
    No schemes available

 CRagdollPropAttached: [server.dll]
    m_boneIndexAttached = 0X0009C8 // uint32
    m_ragdollAttachedObjectIndex = 0X0009CC // uint32
    m_attachmentPointBoneSpace = 0X0009D0 // Vector
    m_attachmentPointRagdollSpace = 0X0009DC // Vector
    m_bShouldDetach = 0X0009E8 // bool
    m_bShouldDeleteAttachedActivationRecord = 0X0009F8 // bool

 CPropDoorRotating: [server.dll]
    m_vecAxis = 0X000D28 // Vector
    m_flDistance = 0X000D34 // float32
    m_eSpawnPosition = 0X000D38 // PropDoorRotatingSpawnPos_t
    m_eOpenDirection = 0X000D3C // PropDoorRotatingOpenDirection_e
    m_eCurrentOpenDirection = 0X000D40 // PropDoorRotatingOpenDirection_e
    m_flAjarAngle = 0X000D44 // float32
    m_angRotationAjarDeprecated = 0X000D48 // QAngle
    m_angRotationClosed = 0X000D54 // QAngle
    m_angRotationOpenForward = 0X000D60 // QAngle
    m_angRotationOpenBack = 0X000D6C // QAngle
    m_angGoal = 0X000D78 // QAngle
    m_vecForwardBoundsMin = 0X000D84 // Vector
    m_vecForwardBoundsMax = 0X000D90 // Vector
    m_vecBackBoundsMin = 0X000D9C // Vector
    m_vecBackBoundsMax = 0X000DA8 // Vector
    m_hEntityBlocker = 0X000DB4 // CHandle< CEntityBlocker >

 CPropDoorRotatingBreakable: [server.dll]
    m_bBreakable = 0X000DB8 // bool
    m_isAbleToCloseAreaPortals = 0X000DB9 // bool
    m_currentDamageState = 0X000DBC // int32
    m_damageStates = 0X000DC0 // CUtlVector< CUtlSymbolLarge >

 CBaseCombatCharacter: [server.dll]
    m_bForceServerRagdoll = 0X0008B0 // bool
    m_hMyWearables = 0X0008B8 // CNetworkUtlVectorBase< CHandle< CEconWearable > >
    m_flFieldOfView = 0X0008D0 // float32
    m_impactEnergyScale = 0X0008D4 // float32
    m_LastHitGroup = 0X0008D8 // HitGroup_t
    m_bApplyStressDamage = 0X0008DC // bool
    m_bloodColor = 0X0008E0 // int32
    m_registeredNavTeam = 0X000940 // int32
    m_navMeshID = 0X000944 // int32
    m_iDamageCount = 0X000948 // int32
    m_pVecRelationships = 0X000950 // CUtlVector< RelationshipOverride_t >*
    m_strRelationships = 0X000958 // CUtlSymbolLarge
    m_eHull = 0X000960 // Hull_t
    m_nNavHullIdx = 0X000964 // uint32

 CItemGeneric: [server.dll]
    m_bHasTriggerRadius = 0X000900 // bool
    m_bHasPickupRadius = 0X000901 // bool
    m_flPickupRadiusSqr = 0X000904 // float32
    m_flTriggerRadiusSqr = 0X000908 // float32
    m_flLastPickupCheck = 0X00090C // GameTime_t
    m_bPlayerCounterListenerAdded = 0X000910 // bool
    m_bPlayerInTriggerRadius = 0X000911 // bool
    m_hSpawnParticleEffect = 0X000918 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_pAmbientSoundEffect = 0X000920 // CUtlSymbolLarge
    m_bAutoStartAmbientSound = 0X000928 // bool
    m_pSpawnScriptFunction = 0X000930 // CUtlSymbolLarge
    m_hPickupParticleEffect = 0X000938 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_pPickupSoundEffect = 0X000940 // CUtlSymbolLarge
    m_pPickupScriptFunction = 0X000948 // CUtlSymbolLarge
    m_hTimeoutParticleEffect = 0X000950 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_pTimeoutSoundEffect = 0X000958 // CUtlSymbolLarge
    m_pTimeoutScriptFunction = 0X000960 // CUtlSymbolLarge
    m_pPickupFilterName = 0X000968 // CUtlSymbolLarge
    m_hPickupFilter = 0X000970 // CHandle< CBaseFilter >
    m_OnPickup = 0X000978 // CEntityIOOutput
    m_OnTimeout = 0X0009A0 // CEntityIOOutput
    m_OnTriggerStartTouch = 0X0009C8 // CEntityIOOutput
    m_OnTriggerTouch = 0X0009F0 // CEntityIOOutput
    m_OnTriggerEndTouch = 0X000A18 // CEntityIOOutput
    m_pAllowPickupScriptFunction = 0X000A40 // CUtlSymbolLarge
    m_flPickupRadius = 0X000A48 // float32
    m_flTriggerRadius = 0X000A4C // float32
    m_pTriggerSoundEffect = 0X000A50 // CUtlSymbolLarge
    m_bGlowWhenInTrigger = 0X000A58 // bool
    m_glowColor = 0X000A59 // Color
    m_bUseable = 0X000A5D // bool
    m_hTriggerHelper = 0X000A60 // CHandle< CItemGenericTriggerHelper >

 CBasePlayerPawn: [server.dll]
    m_pWeaponServices = 0X000968 // CPlayer_WeaponServices*
    m_pItemServices = 0X000970 // CPlayer_ItemServices*
    m_pAutoaimServices = 0X000978 // CPlayer_AutoaimServices*
    m_pObserverServices = 0X000980 // CPlayer_ObserverServices*
    m_pWaterServices = 0X000988 // CPlayer_WaterServices*
    m_pUseServices = 0X000990 // CPlayer_UseServices*
    m_pFlashlightServices = 0X000998 // CPlayer_FlashlightServices*
    m_pCameraServices = 0X0009A0 // CPlayer_CameraServices*
    m_pMovementServices = 0X0009A8 // CPlayer_MovementServices*
    m_fixAngleChangeType = 0X0009B8 // FixAngleSet_t
    m_fixAngleChangeAngle = 0X0009BC // QAngle
    m_fixAngleChangeTick = 0X0009C8 // int32
    v_angle = 0X0009CC // QAngle
    m_iHideHUD = 0X0009D8 // uint32
    m_skybox3d = 0X0009E0 // sky3dparams_t
    m_fTimeLastHurt = 0X000A70 // GameTime_t
    m_flDeathTime = 0X000A74 // GameTime_t
    m_fNextSuicideTime = 0X000A78 // GameTime_t
    m_fInitHUD = 0X000A7C // bool
    m_pExpresser = 0X000A80 // CAI_Expresser*
    m_hController = 0X000A88 // CHandle< CBasePlayerController >
    m_fHltvReplayDelay = 0X000A90 // float32
    m_fHltvReplayEnd = 0X000A94 // float32
    m_iHltvReplayEntity = 0X000A98 // CEntityIndex

 CCSGOViewModel: [server.dll]
    m_bShouldIgnoreOffsetAndAccuracy = 0X000868 // bool
    m_nWeaponParity = 0X00086C // uint32
    m_nOldWeaponParity = 0X000870 // uint32

 CWeaponCSBase: [server.dll]
    m_flFireSequenceStartTime = 0X000C20 // float32
    m_nFireSequenceStartTimeChange = 0X000C24 // int32
    m_nFireSequenceStartTimeAck = 0X000C28 // int32
    m_bPlayerFireEventIsPrimary = 0X000C2C // bool
    m_seqIdle = 0X000C30 // HSequence
    m_seqFirePrimary = 0X000C34 // HSequence
    m_seqFireSecondary = 0X000C38 // HSequence
    m_bPlayerAmmoStockOnPickup = 0X000C48 // bool
    m_bRequireUseToTouch = 0X000C49 // bool
    m_flLastTimeInAir = 0X000C4C // GameTime_t
    m_flLastDeployTime = 0X000C50 // GameTime_t
    m_nViewModelIndex = 0X000C54 // uint32
    m_bReloadsWithClips = 0X000C58 // bool
    m_flTimeWeaponIdle = 0X000C5C // GameTime_t
    m_bFireOnEmpty = 0X000C60 // bool
    m_OnPlayerPickup = 0X000C68 // CEntityIOOutput
    m_weaponMode = 0X000C90 // CSWeaponMode
    m_flTurningInaccuracyDelta = 0X000C94 // float32
    m_vecTurningInaccuracyEyeDirLast = 0X000C98 // Vector
    m_flTurningInaccuracy = 0X000CA4 // float32
    m_fAccuracyPenalty = 0X000CA8 // float32
    m_flLastAccuracyUpdateTime = 0X000CAC // GameTime_t
    m_fAccuracySmoothedForZoom = 0X000CB0 // float32
    m_fScopeZoomEndTime = 0X000CB4 // GameTime_t
    m_iRecoilIndex = 0X000CB8 // int32
    m_flRecoilIndex = 0X000CBC // float32
    m_bBurstMode = 0X000CC0 // bool
    m_flPostponeFireReadyTime = 0X000CC4 // GameTime_t
    m_bInReload = 0X000CC8 // bool
    m_bReloadVisuallyComplete = 0X000CC9 // bool
    m_flDroppedAtTime = 0X000CCC // GameTime_t
    m_bIsHauledBack = 0X000CD0 // bool
    m_bSilencerOn = 0X000CD1 // bool
    m_flTimeSilencerSwitchComplete = 0X000CD4 // GameTime_t
    m_iOriginalTeamNumber = 0X000CD8 // int32
    m_flNextAttackRenderTimeOffset = 0X000CDC // float32
    m_bCanBePickedUp = 0X000CE8 // bool
    m_bUseCanOverrideNextOwnerTouchTime = 0X000CE9 // bool
    m_nextOwnerTouchTime = 0X000CEC // GameTime_t
    m_nextPrevOwnerTouchTime = 0X000CF0 // GameTime_t
    m_hPrevOwner = 0X000CF4 // CHandle< CCSPlayerPawnBase >
    m_donated = 0X000D14 // bool
    m_fLastShotTime = 0X000D18 // GameTime_t
    m_bWasOwnedByCT = 0X000D1C // bool
    m_bWasOwnedByTerrorist = 0X000D1D // bool
    m_bFiredOutOfAmmoEvent = 0X000D1E // bool
    m_numRemoveUnownedWeaponThink = 0X000D20 // int32
    m_IronSightController = 0X000D28 // CIronSightController
    m_iIronSightMode = 0X000D40 // int32
    m_flLastLOSTraceFailureTime = 0X000D44 // GameTime_t
    m_iNumEmptyAttacks = 0X000D48 // int32

 CWeaponCSBaseGun: [server.dll]
    m_zoomLevel = 0X000D50 // int32
    m_iBurstShotsRemaining = 0X000D54 // int32
    m_silencedModelIndex = 0X000D60 // int32
    m_inPrecache = 0X000D64 // bool
    m_bNeedsBoltAction = 0X000D65 // bool
    m_bSkillReloadAvailable = 0X000D66 // bool
    m_bSkillReloadLiftedReloadKey = 0X000D67 // bool
    m_bSkillBoltInterruptAvailable = 0X000D68 // bool
    m_bSkillBoltLiftedFireKey = 0X000D69 // bool

 CC4: [server.dll]
    m_vecLastValidPlayerHeldPosition = 0X000D50 // Vector
    m_vecLastValidDroppedPosition = 0X000D5C // Vector
    m_bDoValidDroppedPositionCheck = 0X000D68 // bool
    m_bStartedArming = 0X000D69 // bool
    m_fArmedTime = 0X000D6C // GameTime_t
    m_bBombPlacedAnimation = 0X000D70 // bool
    m_bShowC4LED = 0X000D71 // bool
    m_bIsPlantingViaUse = 0X000D72 // bool
    m_entitySpottedState = 0X000D78 // EntitySpottedState_t
    m_nSpotRules = 0X000D90 // int32
    m_bPlayedArmingBeeps = 0X000D94 // bool[7]
    m_bBombPlanted = 0X000D9B // bool
    m_bDroppedFromDeath = 0X000D9C // bool

 CDEagle: [server.dll]
    No schemes available

 CWeaponElite: [server.dll]
    No schemes available

 CWeaponNOVA: [server.dll]
    No schemes available

 CWeaponSawedoff: [server.dll]
    No schemes available

 CWeaponTaser: [server.dll]
    m_fFireTime = 0X000D70 // GameTime_t

 CWeaponXM1014: [server.dll]
    No schemes available

 CKnife: [server.dll]
    No schemes available

 CKnifeGG: [server.dll]
    No schemes available

 CMelee: [server.dll]
    m_flThrowAt = 0X000D50 // GameTime_t
    m_hThrower = 0X000D54 // CHandle< CBaseEntity >
    m_bDidThrowDamage = 0X000D58 // bool

 CWeaponZoneRepulsor: [server.dll]
    No schemes available

 CWeaponShield: [server.dll]
    m_flBulletDamageAbsorbed = 0X000D70 // float32
    m_flLastBulletHitSoundTime = 0X000D74 // GameTime_t
    m_flDisplayHealth = 0X000D78 // float32

 CMolotovProjectile: [server.dll]
    m_bIsIncGrenade = 0X0009A0 // bool
    m_bDetonated = 0X0009AC // bool
    m_stillTimer = 0X0009B0 // IntervalTimer
    m_bHasBouncedOffPlayer = 0X000A90 // bool

 CDecoyProjectile: [server.dll]
    m_shotsRemaining = 0X0009A8 // int32
    m_fExpireTime = 0X0009AC // GameTime_t
    m_decoyWeaponDefIndex = 0X0009B8 // uint16

 CSmokeGrenadeProjectile: [server.dll]
    m_nSmokeEffectTickBegin = 0X0009B8 // int32
    m_bDidSmokeEffect = 0X0009BC // bool
    m_nRandomSeed = 0X0009C0 // int32
    m_vSmokeColor = 0X0009C4 // Vector
    m_vSmokeDetonationPos = 0X0009D0 // Vector
    m_VoxelFrameData = 0X0009E0 // CUtlVector< uint8 >
    m_flLastBounce = 0X0009F8 // GameTime_t
    m_fllastSimulationTime = 0X0009FC // GameTime_t

 CBaseCSGrenade: [server.dll]
    m_bRedraw = 0X000D70 // bool
    m_bIsHeldByPlayer = 0X000D71 // bool
    m_bPinPulled = 0X000D72 // bool
    m_eThrowStatus = 0X000D74 // EGrenadeThrowState
    m_fThrowTime = 0X000D78 // GameTime_t
    m_flThrowStrength = 0X000D7C // float32
    m_flThrowStrengthApproach = 0X000D80 // float32
    m_fDropTime = 0X000D84 // GameTime_t

 CWeaponBaseItem: [server.dll]
    m_SequenceCompleteTimer = 0X000D50 // CountdownTimer
    m_bRedraw = 0X000D68 // bool

 CItem_Healthshot: [server.dll]
    No schemes available

 CFists: [server.dll]
    m_bPlayingUninterruptableAct = 0X000D50 // bool
    m_nUninterruptableActivity = 0X000D54 // PlayerAnimEvent_t
    m_bRestorePrevWep = 0X000D58 // bool
    m_hWeaponBeforePrevious = 0X000D5C // CHandle< CBasePlayerWeapon >
    m_hWeaponPrevious = 0X000D60 // CHandle< CBasePlayerWeapon >
    m_bDelayedHardPunchIncoming = 0X000D64 // bool
    m_bDestroyAfterTaunt = 0X000D65 // bool

 CTablet: [server.dll]
    m_bPendingBuyMenu = 0X000D58 // bool
    m_flUpgradeExpirationTime = 0X000D5C // GameTime_t[4]
    m_vecLocalHexFlags = 0X000D6C // int32[42]
    m_nContractKillGridIndex = 0X000E14 // int32
    m_nContractKillGridHighResIndex = 0X000E18 // int32
    m_bTabletReceptionIsBlocked = 0X000E1C // bool
    m_flScanProgress = 0X000E20 // float32
    m_flBootTime = 0X000E24 // GameTime_t
    m_flShowMapTime = 0X000E28 // GameTime_t
    m_vecNearestMetalCratePos = 0X000E2C // Vector
    m_skinState = 0X000E38 // tablet_skin_state_t
    m_vecNotificationIds = 0X000E3C // int32[8]
    m_vecNotificationTimestamps = 0X000E5C // GameTime_t[8]
    m_nLastPurchaseIndex = 0X000E7C // int32
    m_vecPlayerPositionHistory = 0X000E80 // Vector[24]
    m_vecLastPlayerPosition = 0X000FA0 // Vector2D
    m_flNextCheckForIncomingDronesTime = 0X000FA8 // GameTime_t
    m_flLastPlayerOccupiedGridUpdate = 0X000FAC // GameTime_t
    m_flLastTabletBlockedTime = 0X000FB0 // GameTime_t
    m_flLastClosePoseParamVal = 0X001060 // float32

 CBreachCharge: [server.dll]
    No schemes available

 CBumpMine: [server.dll]
    No schemes available

 CTripWireFire: [server.dll]
    No schemes available

 CPhysPropWeaponRefillHeavyArmor: [server.dll]
    No schemes available

 CPhysPropWeaponUpgradeArmor: [server.dll]
    No schemes available

 CPhysPropWeaponUpgradeHelmet: [server.dll]
    No schemes available

 CPhysPropWeaponUpgradeArmorHelmet: [server.dll]
    No schemes available

 CPhysPropWeaponUpgradeExoJump: [server.dll]
    No schemes available

 CPhysPropWeaponUpgradeParachute: [server.dll]
    No schemes available

 CPhysPropWeaponUpgradeContractKill: [server.dll]
    No schemes available

 CPhysPropMapPlacedLongUseEntity: [server.dll]
    m_iszStartUseSound = 0X000B30 // CUtlSymbolLarge
    m_nPingType = 0X000B38 // int32
    m_nLongUseActionType = 0X000B3C // int32
    m_flLongUseDuration = 0X000B40 // float32
    m_OnUseCompleted = 0X000B48 // CEntityIOOutput

 CPhysPropWeaponUpgradeTablet: [server.dll]
    No schemes available

 CPhysPropWeaponUpgradeTabletHighres: [server.dll]
    No schemes available

 CPhysPropWeaponUpgradeTabletZoneIntel: [server.dll]
    No schemes available

 CPhysPropWeaponUpgradeTabletDroneIntel: [server.dll]
    No schemes available

 CSensorGrenade: [server.dll]
    No schemes available

 CCSPlayerPawnBase: [server.dll]
    m_CTouchExpansionComponent = 0X000AB0 // CTouchExpansionComponent
    m_pActionTrackingServices = 0X000AD0 // CCSPlayer_ActionTrackingServices*
    m_pViewModelServices = 0X000AD8 // CCSPlayer_ViewModelServices*
    m_iDisplayHistoryBits = 0X000AE0 // uint32
    m_flLastAttackedTeammate = 0X000AE4 // float32
    m_hOriginalController = 0X000AE8 // CHandle< CCSPlayerController >
    m_blindUntilTime = 0X000AEC // GameTime_t
    m_blindStartTime = 0X000AF0 // GameTime_t
    m_allowAutoFollowTime = 0X000AF4 // GameTime_t
    m_bHasFemaleVoice = 0X000AF8 // bool
    m_entitySpottedState = 0X000B00 // EntitySpottedState_t
    m_nSpotRules = 0X000B18 // int32
    m_flTimeOfLastInjury = 0X000B1C // float32
    m_nRelativeDirectionOfLastInjury = 0X000B20 // RelativeDamagedDirection_t
    m_iPlayerState = 0X000B24 // CSPlayerState
    m_chickenIdleSoundTimer = 0X000B30 // CountdownTimer
    m_chickenJumpSoundTimer = 0X000B48 // CountdownTimer
    m_vecLastBookmarkedPosition = 0X000C00 // Vector
    m_flLastDistanceTraveledNotice = 0X000C0C // float32
    m_flAccumulatedDistanceTraveled = 0X000C10 // float32
    m_flLastFriendlyFireDamageReductionRatio = 0X000C14 // float32
    m_bRespawning = 0X000C18 // bool
    m_iNumGunGameTRBombTotalPoints = 0X000C1C // int32
    m_bShouldProgressGunGameTRBombModeWeapon = 0X000C20 // bool
    m_nLastPickupPriority = 0X000C24 // int32
    m_flLastPickupPriorityTime = 0X000C28 // float32
    m_passiveItems = 0X000C2C // bool[4]
    m_bIsScoped = 0X000C30 // bool
    m_bIsWalking = 0X000C31 // bool
    m_bResumeZoom = 0X000C32 // bool
    m_bIsDefusing = 0X000C33 // bool
    m_bIsGrabbingHostage = 0X000C34 // bool
    m_iBlockingUseActionInProgress = 0X000C38 // CSPlayerBlockingUseAction_t
    m_fImmuneToGunGameDamageTime = 0X000C3C // GameTime_t
    m_bGunGameImmunity = 0X000C40 // bool
    m_bMadeFinalGunGameProgressiveKill = 0X000C41 // bool
    m_iGunGameProgressiveWeaponIndex = 0X000C44 // int32
    m_iNumGunGameTRKillPoints = 0X000C48 // int32
    m_iNumGunGameKillsWithCurrentWeapon = 0X000C4C // int32
    m_unTotalRoundDamageDealt = 0X000C50 // uint32
    m_fMolotovDamageTime = 0X000C54 // float32
    m_bHasMovedSinceSpawn = 0X000C58 // bool
    m_bCanMoveDuringFreezePeriod = 0X000C59 // bool
    m_isCurrentGunGameLeader = 0X000C5A // bool
    m_isCurrentGunGameTeamLeader = 0X000C5B // bool
    m_flGuardianTooFarDistFrac = 0X000C5C // float32
    m_flNextGuardianTooFarHurtTime = 0X000C60 // float32
    m_flDetectedByEnemySensorTime = 0X000C64 // GameTime_t
    m_bIsSpawnRappelling = 0X000C68 // bool
    m_vecSpawnRappellingRopeOrigin = 0X000C6C // Vector
    m_nSurvivalTeam = 0X000C78 // int32
    m_hSurvivalAssassinationTarget = 0X000C7C // CHandle< CCSPlayerPawnBase >
    m_nCompletedSurvivalAssassinations = 0X000C80 // int32
    m_flDealtDamageToEnemyMostRecentTimestamp = 0X000C84 // float32
    m_flHealthShotBoostExpirationTime = 0X000C88 // float32
    m_flLastEquippedHelmetTime = 0X000C8C // GameTime_t
    m_flLastEquippedArmorTime = 0X000C90 // GameTime_t
    m_nHeavyAssaultSuitCooldownRemaining = 0X000C94 // int32
    m_bResetArmorNextSpawn = 0X000C98 // bool
    m_flLastExoJumpTime = 0X000C9C // float32
    m_flLastBumpMineBumpTime = 0X000CA0 // GameTime_t
    m_flEmitSoundTime = 0X000CB0 // GameTime_t
    m_bEscaped = 0X000CB4 // bool
    m_bIsVIP = 0X000CB5 // bool
    m_iNumSpawns = 0X000CB8 // int32
    m_iShouldHaveCash = 0X000CBC // int32
    m_bJustKilledTeammate = 0X000CC0 // bool
    m_bPunishedForTK = 0X000CC1 // bool
    m_bInvalidSteamLogonDelayed = 0X000CC2 // bool
    m_iTeamKills = 0X000CC4 // int32
    m_flLastAction = 0X000CC8 // GameTime_t
    m_flNameChangeHistory = 0X000CCC // float32[5]
    m_fLastGivenDefuserTime = 0X000CE0 // float32
    m_fLastGivenBombTime = 0X000CE4 // float32
    m_bHasNightVision = 0X000CE8 // bool
    m_bNightVisionOn = 0X000CE9 // bool
    m_fNextRadarUpdateTime = 0X000CEC // float32
    m_flLastMoneyUpdateTime = 0X000CF0 // float32
    m_MenuStringBuffer = 0X000CF4 // char[1024]
    m_pIntroCamera = 0X0010F4 // CHandle< CBaseEntity >
    m_fIntroCamTime = 0X0010F8 // float32
    m_nMyCollisionGroup = 0X0010FC // int32
    m_bInBombZone = 0X001100 // bool
    m_bInBuyZone = 0X001101 // bool
    m_bInNoDefuseArea = 0X001102 // bool
    m_bKilledByTaser = 0X001103 // bool
    m_iMoveState = 0X001104 // int32
    m_nPreviousModelIndex = 0X001108 // CStrongHandle< InfoForResourceTypeCModel >
    m_grenadeParameterStashTime = 0X001110 // GameTime_t
    m_bGrenadeParametersStashed = 0X001114 // bool
    m_angStashedShootAngles = 0X001118 // QAngle
    m_vecStashedGrenadeThrowPosition = 0X001124 // Vector
    m_vecStashedVelocity = 0X001130 // Vector
    m_angShootAngleHistory = 0X00113C // QAngle[2]
    m_vecThrowPositionHistory = 0X001154 // Vector[2]
    m_vecVelocityHistory = 0X00116C // Vector[2]
    m_nCharacterDefIndex = 0X001184 // uint16
    m_bDiedAirborne = 0X001186 // bool
    m_iBombSiteIndex = 0X001188 // CEntityIndex
    m_nWhichBombZone = 0X00118C // int32
    m_bInBombZoneTrigger = 0X001190 // bool
    m_bWasInBombZoneTrigger = 0X001191 // bool
    m_bWasInHostageRescueZone = 0X001192 // bool
    m_bWasInBuyZone = 0X001193 // bool
    m_bInHostageRescueZone = 0X001194 // bool
    m_flStamina = 0X001198 // float32
    m_iDirection = 0X00119C // int32
    m_iShotsFired = 0X0011A0 // int32
    m_ArmorValue = 0X0011A4 // int32
    m_flFlinchStack = 0X0011A8 // float32
    m_flVelocityModifier = 0X0011AC // float32
    m_flGroundAccelLinearFracLastTime = 0X0011B0 // float32
    m_iHostagesKilled = 0X0011B4 // int32
    m_vecTotalBulletForce = 0X0011B8 // Vector
    m_flFlashDuration = 0X0011C4 // float32
    m_flFlashMaxAlpha = 0X0011C8 // float32
    m_flProgressBarStartTime = 0X0011CC // float32
    m_iProgressBarDuration = 0X0011D0 // int32
    m_bWaitForNoAttack = 0X0011D4 // bool
    m_bIsRespawningForDMBonus = 0X0011D5 // bool
    m_flLowerBodyYawTarget = 0X0011D8 // float32
    m_bStrafing = 0X0011DC // bool
    m_lastStandingPos = 0X0011E0 // Vector
    m_ignoreLadderJumpTime = 0X0011EC // float32
    m_ladderSurpressionTimer = 0X0011F0 // CountdownTimer
    m_lastLadderNormal = 0X001208 // Vector
    m_lastLadderPos = 0X001214 // Vector
    m_thirdPersonHeading = 0X001220 // QAngle
    m_flSlopeDropOffset = 0X00122C // float32
    m_flSlopeDropHeight = 0X001230 // float32
    m_vHeadConstraintOffset = 0X001234 // Vector
    m_iLastWeaponFireUsercmd = 0X001248 // int32
    m_angEyeAngles = 0X00124C // QAngle
    m_bVCollisionInitted = 0X001258 // bool
    m_storedSpawnPosition = 0X00125C // Vector
    m_storedSpawnAngle = 0X001268 // QAngle
    m_bIsSpawning = 0X001274 // bool
    m_bHideTargetID = 0X001275 // bool
    m_nNumDangerZoneDamageHits = 0X001278 // int32
    m_bHud_MiniScoreHidden = 0X00127C // bool
    m_bHud_RadarHidden = 0X00127D // bool
    m_nLastKillerIndex = 0X001280 // CEntityIndex
    m_nLastConcurrentKilled = 0X001284 // int32
    m_nDeathCamMusic = 0X001288 // int32
    m_iAddonBits = 0X00128C // int32
    m_iPrimaryAddon = 0X001290 // int32
    m_iSecondaryAddon = 0X001294 // int32
    m_nTeamDamageGivenForMatch = 0X001298 // int32
    m_bTDGaveProtectionWarning = 0X00129C // bool
    m_bTDGaveProtectionWarningThisRound = 0X00129D // bool
    m_flLastTHWarningTime = 0X0012A0 // float32
    m_currentDeafnessFilter = 0X0012A4 // CUtlStringToken
    m_enemyPlayersKilledThisRound = 0X0012A8 // CUtlVector< CHandle< CCSPlayerPawnBase > >
    m_NumEnemiesKilledThisSpawn = 0X0012C0 // int32
    m_maxNumEnemiesKillStreak = 0X0012C4 // int32
    m_NumEnemiesKilledThisRound = 0X0012C8 // int32
    m_NumEnemiesAtRoundStart = 0X0012CC // int32
    m_iRoundsWon = 0X0012D0 // int32
    m_bHasUsedDMBonusRespawn = 0X0012D4 // bool
    m_lastRoundResult = 0X0012D8 // int32
    m_wasNotKilledNaturally = 0X0012DC // bool
    m_vecPlayerPatchEconIndices = 0X0012E0 // uint32[5]
    m_iDeathFlags = 0X0012F4 // int32
    m_hPet = 0X0012F8 // CHandle< CChicken >
    m_flLastKnownAccumulatedWeaponEncumbrance = 0X0012FC // float32
    m_flLastTimeComputedAccumulatedWeaponEncumbrance = 0X001300 // float32
    m_unCurrentEquipmentValue = 0X0014D0 // uint16
    m_unRoundStartEquipmentValue = 0X0014D2 // uint16
    m_unFreezetimeEndEquipmentValue = 0X0014D4 // uint16
    m_szLastPlaceName = 0X0014D6 // char[18]
    m_nSuicides = 0X0014E8 // int32
    m_nSurvivalTeamNumber = 0X0014EC // int32
    m_aimPunchAngle = 0X0014F0 // QAngle
    m_aimPunchAngleVel = 0X0014FC // QAngle
    m_aimPunchTickBase = 0X001508 // int32
    m_aimPunchTickFraction = 0X00150C // float32
    m_aimPunchCache = 0X001510 // CUtlVector< QAngle >
    m_bHasDeathInfo = 0X001528 // bool
    m_flDeathInfoTime = 0X00152C // float32
    m_vecDeathInfoOrigin = 0X001530 // Vector
    m_bKilledByHeadshot = 0X00153C // bool
    m_LastHitBox = 0X001540 // int32
    m_LastHealth = 0X001544 // int32
    m_flLastCollisionCeiling = 0X001548 // float32
    m_flLastCollisionCeilingChangeTime = 0X00154C // float32
    m_strVOPrefix = 0X001550 // CUtlString
    m_flLandseconds = 0X001558 // float32
    m_pBot = 0X001560 // CCSBot*
    m_bBotAllowActive = 0X001568 // bool
    m_bCommittingSuicideOnTeamChange = 0X001569 // bool

 CCSObserverPawn: [server.dll]
    No schemes available

 CCSPlayerPawn: [server.dll]
    m_pParachuteServices = 0X001570 // CCSPlayer_ParachuteServices*
    m_pBulletServices = 0X001578 // CCSPlayer_BulletServices*
    m_pHostageServices = 0X001580 // CCSPlayer_HostageServices*
    m_pBuyServices = 0X001588 // CCSPlayer_BuyServices*
    m_pPingServices = 0X001590 // CCSPlayer_PingServices*
    m_pRadioServices = 0X001598 // CCSPlayer_RadioServices*
    m_pDamageReactServices = 0X0015A0 // CCSPlayer_DamageReactServices*
    m_iRetakesOffering = 0X001670 // int32
    m_iRetakesOfferingCard = 0X001674 // int32
    m_bRetakesHasDefuseKit = 0X001678 // bool
    m_bRetakesMVPLastRound = 0X001679 // bool
    m_iRetakesMVPBoostItem = 0X00167C // int32
    m_RetakesMVPBoostExtraUtility = 0X001680 // loadout_positions_t
    m_bIsBuyMenuOpen = 0X001684 // bool
    m_xLastHeadBoneTransform = 0X0017E0 // CTransform
    m_bLastHeadBoneTransformIsValid = 0X001800 // bool
    m_iPlayerLocked = 0X001804 // int32
    m_flNextSprayDecalTime = 0X00180C // float32
    m_nRagdollDamageBone = 0X001814 // int32
    m_vRagdollDamageForce = 0X001818 // Vector
    m_vRagdollDamagePosition = 0X001824 // Vector
    m_szRagdollDamageWeaponName = 0X001830 // char[64]
    m_bRagdollDamageHeadshot = 0X001870 // bool
    m_EconGloves = 0X001878 // CEconItemView
    m_qDeathEyeAngles = 0X001AF0 // QAngle

 CDZDoor: [server.dll]
    m_bIsSecurityDoor = 0X000DE0 // bool
    m_hSpawnPoint = 0X000DE4 // CHandle< CPointDZWeaponSpawn >
    m_bPaidToUnlock = 0X000DE8 // bool
    m_nPlayDoorOpenSound = 0X000DEC // int32
    m_nAttachmentIndex1 = 0X000E20 // AttachmentHandle_t
    m_nAttachmentIndex2 = 0X000E21 // AttachmentHandle_t

 CHostageExpresserShim: [server.dll]
    m_pExpresser = 0X000968 // CAI_Expresser*

 CHostage: [server.dll]
    m_OnHostageBeginGrab = 0X000980 // CEntityIOOutput
    m_OnFirstPickedUp = 0X0009A8 // CEntityIOOutput
    m_OnDroppedNotRescued = 0X0009D0 // CEntityIOOutput
    m_OnRescued = 0X0009F8 // CEntityIOOutput
    m_entitySpottedState = 0X000A20 // EntitySpottedState_t
    m_nSpotRules = 0X000A38 // int32
    m_uiHostageSpawnExclusionGroupMask = 0X000A3C // uint32
    m_nHostageSpawnRandomFactor = 0X000A40 // uint32
    m_bRemove = 0X000A44 // bool
    m_vel = 0X000A48 // Vector
    m_isRescued = 0X000A54 // bool
    m_jumpedThisFrame = 0X000A55 // bool
    m_nHostageState = 0X000A58 // int32
    m_leader = 0X000A5C // CHandle< CBaseEntity >
    m_lastLeader = 0X000A60 // CHandle< CCSPlayerPawnBase >
    m_reuseTimer = 0X000A68 // CountdownTimer
    m_hasBeenUsed = 0X000A80 // bool
    m_accel = 0X000A84 // Vector
    m_isRunning = 0X000A90 // bool
    m_isCrouching = 0X000A91 // bool
    m_jumpTimer = 0X000A98 // CountdownTimer
    m_isWaitingForLeader = 0X000AB0 // bool
    m_repathTimer = 0X002AC0 // CountdownTimer
    m_inhibitDoorTimer = 0X002AD8 // CountdownTimer
    m_inhibitObstacleAvoidanceTimer = 0X002B68 // CountdownTimer
    m_wiggleTimer = 0X002B88 // CountdownTimer
    m_isAdjusted = 0X002BA4 // bool
    m_bHandsHaveBeenCut = 0X002BA5 // bool
    m_pHostageGrabber = 0X002BA8 // CHandle< CCSPlayerPawn >
    m_fLastGrabTime = 0X002BAC // GameTime_t
    m_flGrabbingLength = 0X002BB0 // float32
    m_vecPositionWhenStartedDroppingToGround = 0X002BB4 // Vector
    m_vecGrabbedPos = 0X002BC0 // Vector
    m_flRescueStartTime = 0X002BCC // GameTime_t
    m_flGrabSuccessTime = 0X002BD0 // GameTime_t
    m_flDropStartTime = 0X002BD4 // GameTime_t
    m_nApproachRewardPayouts = 0X002BD8 // int32
    m_nPickupEventCount = 0X002BDC // int32
    m_vecSpawnGroundPos = 0X002BE0 // Vector

 CHostageAlias_info_hostage_spawn: [server.dll]
    No schemes available

 CItemDefuserAlias_item_defuser: [server.dll]
    No schemes available

 CAK47: [server.dll]
    No schemes available

 CWeaponAug: [server.dll]
    No schemes available

 CWeaponAWP: [server.dll]
    No schemes available

 CWeaponBizon: [server.dll]
    No schemes available

 CWeaponFamas: [server.dll]
    No schemes available

 CWeaponFiveSeven: [server.dll]
    No schemes available

 CWeaponG3SG1: [server.dll]
    No schemes available

 CWeaponGalilAR: [server.dll]
    No schemes available

 CWeaponGlock: [server.dll]
    No schemes available

 CWeaponHKP2000: [server.dll]
    No schemes available

 CWeaponM4A1: [server.dll]
    No schemes available

 CWeaponMAC10: [server.dll]
    No schemes available

 CWeaponMag7: [server.dll]
    No schemes available

 CWeaponMP7: [server.dll]
    No schemes available

 CWeaponMP9: [server.dll]
    No schemes available

 CWeaponNegev: [server.dll]
    No schemes available

 CWeaponP250: [server.dll]
    No schemes available

 CWeaponP90: [server.dll]
    No schemes available

 CWeaponSCAR20: [server.dll]
    No schemes available

 CWeaponSG556: [server.dll]
    No schemes available

 CWeaponSSG08: [server.dll]
    No schemes available

 CWeaponTec9: [server.dll]
    No schemes available

 CWeaponUMP45: [server.dll]
    No schemes available

 CWeaponM249: [server.dll]
    No schemes available

 CMolotovGrenade: [server.dll]
    No schemes available

 CIncendiaryGrenade: [server.dll]
    No schemes available

 CDecoyGrenade: [server.dll]
    No schemes available

 CFlashbang: [server.dll]
    No schemes available

 CHEGrenade: [server.dll]
    No schemes available

 CSmokeGrenade: [server.dll]
    No schemes available


client.dll:
 CEntityIdentity: [client.dll]
    m_nameStringableIndex = 0X000014 // int32
    m_name = 0X000018 // CUtlSymbolLarge
    m_designerName = 0X000020 // CUtlSymbolLarge
    m_flags = 0X000030 // uint32
    m_worldGroupId = 0X000038 // WorldGroupId_t
    m_fDataObjectTypes = 0X00003C // uint32
    m_PathIndex = 0X000040 // ChangeAccessorFieldPathIndex_t
    m_pPrev = 0X000058 // CEntityIdentity*
    m_pNext = 0X000060 // CEntityIdentity*
    m_pPrevByClass = 0X000068 // CEntityIdentity*
    m_pNextByClass = 0X000070 // CEntityIdentity*

 CEntityInstance: [client.dll]
    m_iszPrivateVScripts = 0X000008 // CUtlSymbolLarge
    m_pEntity = 0X000010 // CEntityIdentity*
    m_CScriptComponent = 0X000028 // CScriptComponent*

 CScriptComponent: [client.dll]
    m_scriptClassName = 0X000030 // CUtlSymbolLarge

 CBodyComponent: [client.dll]
    m_pSceneNode = 0X000008 // CGameSceneNode*
    __m_pChainEntity = 0X000020 // CNetworkVarChainer

 CBodyComponentPoint: [client.dll]
    m_sceneNode = 0X000050 // CGameSceneNode
    __m_pChainEntity = 0X0001A0 // CNetworkVarChainer

 CBodyComponentSkeletonInstance: [client.dll]
    m_skeletonInstance = 0X000050 // CSkeletonInstance
    __m_pChainEntity = 0X000440 // CNetworkVarChainer

 CHitboxComponent: [client.dll]
    m_bvDisabledHitGroups = 0X000024 // uint32[1]

 CLightComponent: [client.dll]
    __m_pChainEntity = 0X000048 // CNetworkVarChainer
    m_Color = 0X000085 // Color
    m_SecondaryColor = 0X000089 // Color
    m_flBrightness = 0X000090 // float32
    m_flBrightnessScale = 0X000094 // float32
    m_flBrightnessMult = 0X000098 // float32
    m_flRange = 0X00009C // float32
    m_flFalloff = 0X0000A0 // float32
    m_flAttenuation0 = 0X0000A4 // float32
    m_flAttenuation1 = 0X0000A8 // float32
    m_flAttenuation2 = 0X0000AC // float32
    m_flTheta = 0X0000B0 // float32
    m_flPhi = 0X0000B4 // float32
    m_hLightCookie = 0X0000B8 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_nCascades = 0X0000C0 // int32
    m_nCastShadows = 0X0000C4 // int32
    m_nShadowWidth = 0X0000C8 // int32
    m_nShadowHeight = 0X0000CC // int32
    m_bRenderDiffuse = 0X0000D0 // bool
    m_nRenderSpecular = 0X0000D4 // int32
    m_bRenderTransmissive = 0X0000D8 // bool
    m_flOrthoLightWidth = 0X0000DC // float32
    m_flOrthoLightHeight = 0X0000E0 // float32
    m_nStyle = 0X0000E4 // int32
    m_Pattern = 0X0000E8 // CUtlString
    m_nCascadeRenderStaticObjects = 0X0000F0 // int32
    m_flShadowCascadeCrossFade = 0X0000F4 // float32
    m_flShadowCascadeDistanceFade = 0X0000F8 // float32
    m_flShadowCascadeDistance0 = 0X0000FC // float32
    m_flShadowCascadeDistance1 = 0X000100 // float32
    m_flShadowCascadeDistance2 = 0X000104 // float32
    m_flShadowCascadeDistance3 = 0X000108 // float32
    m_nShadowCascadeResolution0 = 0X00010C // int32
    m_nShadowCascadeResolution1 = 0X000110 // int32
    m_nShadowCascadeResolution2 = 0X000114 // int32
    m_nShadowCascadeResolution3 = 0X000118 // int32
    m_bUsesBakedShadowing = 0X00011C // bool
    m_nShadowPriority = 0X000120 // int32
    m_nBakedShadowIndex = 0X000124 // int32
    m_bRenderToCubemaps = 0X000128 // bool
    m_LightGroups = 0X000130 // CUtlSymbolLarge
    m_nDirectLight = 0X000138 // int32
    m_nIndirectLight = 0X00013C // int32
    m_flFadeMinDist = 0X000140 // float32
    m_flFadeMaxDist = 0X000144 // float32
    m_flShadowFadeMinDist = 0X000148 // float32
    m_flShadowFadeMaxDist = 0X00014C // float32
    m_bEnabled = 0X000150 // bool
    m_bFlicker = 0X000151 // bool
    m_bPrecomputedFieldsValid = 0X000152 // bool
    m_vPrecomputedBoundsMins = 0X000154 // Vector
    m_vPrecomputedBoundsMaxs = 0X000160 // Vector
    m_vPrecomputedOBBOrigin = 0X00016C // Vector
    m_vPrecomputedOBBAngles = 0X000178 // QAngle
    m_vPrecomputedOBBExtent = 0X000184 // Vector
    m_flPrecomputedMaxRange = 0X000190 // float32
    m_nFogLightingMode = 0X000194 // int32
    m_flFogContributionStength = 0X000198 // float32
    m_flNearClipPlane = 0X00019C // float32
    m_SkyColor = 0X0001A0 // Color
    m_flSkyIntensity = 0X0001A4 // float32
    m_SkyAmbientBounce = 0X0001A8 // Color
    m_bUseSecondaryColor = 0X0001AC // bool
    m_bMixedShadows = 0X0001AD // bool
    m_flLightStyleStartTime = 0X0001B0 // GameTime_t
    m_flCapsuleLength = 0X0001B4 // float32
    m_flMinRoughness = 0X0001B8 // float32

 CRenderComponent: [client.dll]
    __m_pChainEntity = 0X000010 // CNetworkVarChainer
    m_bIsRenderingWithViewModels = 0X000050 // bool
    m_nSplitscreenFlags = 0X000054 // uint32
    m_bEnableRendering = 0X000060 // bool
    m_bInterpolationReadyToDraw = 0X0000B0 // bool

 CBuoyancyHelper: [client.dll]
    m_flFluidDensity = 0X000018 // float32
    m_flDisplacementFromObjects = 0X00001C // float32

 C_CommandContext: [client.dll]
    needsprocessing = 0X000000 // bool
    command_number = 0X000078 // int32

 CPlayer_AutoaimServices: [client.dll]
    No schemes available

 audioparams_t: [client.dll]
    localSound = 0X000008 // Vector[8]
    soundscapeIndex = 0X000068 // int32
    localBits = 0X00006C // uint8
    soundscapeEntityListIndex = 0X000070 // int32
    soundEventHash = 0X000074 // uint32

 CPlayer_CameraServices: [client.dll]
    m_iFOV = 0X000040 // uint32
    m_iFOVStart = 0X000044 // uint32
    m_flFOVTime = 0X000048 // GameTime_t
    m_flFOVRate = 0X00004C // float32
    m_vecPunchAngle = 0X000050 // QAngle
    m_vecPunchAngleVel = 0X000068 // QAngle
    m_nPunchAngleJoltTickClientSide = 0X000080 // GameTick_t
    m_nPunchAngleJoltTick = 0X000084 // GameTick_t
    m_hZoomOwner = 0X000088 // CHandle< C_BaseEntity >
    m_PlayerFog = 0X000090 // C_fogplayerparams_t
    m_hColorCorrectionCtrl = 0X0000D0 // CHandle< C_ColorCorrection >
    m_hViewEntity = 0X0000D4 // CHandle< C_BaseEntity >
    m_hTonemapController = 0X0000D8 // CHandle< C_TonemapController2 >
    m_audio = 0X0000E0 // audioparams_t
    m_PostProcessingVolumes = 0X000158 // C_NetworkUtlVectorBase< CHandle< C_PostProcessingVolume > >
    m_flOldPlayerZ = 0X000170 // float32
    m_flOldPlayerViewOffsetZ = 0X000174 // float32
    m_CurrentFog = 0X000178 // fogparams_t
    m_hOldFogController = 0X0001E0 // CHandle< C_FogController >
    m_bOverrideFogColor = 0X0001E4 // bool[5]
    m_OverrideFogColor = 0X0001E9 // Color[5]
    m_bOverrideFogStartEnd = 0X0001FD // bool[5]
    m_fOverrideFogStart = 0X000204 // float32[5]
    m_fOverrideFogEnd = 0X000218 // float32[5]
    m_hActivePostProcessingVolume = 0X00022C // CHandle< C_PostProcessingVolume >
    m_angDemoViewAngles = 0X000230 // QAngle

 CPlayer_FlashlightServices: [client.dll]
    No schemes available

 CPlayer_ItemServices: [client.dll]
    No schemes available

 CPlayer_MovementServices: [client.dll]
    m_nImpulse = 0X000040 // int32
    m_nButtons = 0X000048 // CInButtonState
    m_nQueuedButtonDownMask = 0X000068 // uint64
    m_nQueuedButtonChangeMask = 0X000070 // uint64
    m_nButtonDoublePressed = 0X000078 // uint64
    m_pButtonPressedCmdNumber = 0X000080 // uint32[64]
    m_nLastCommandNumberProcessed = 0X000180 // uint32
    m_nToggleButtonDownMask = 0X000188 // uint64
    m_flMaxspeed = 0X000190 // float32
    m_flForceSubtickMoveWhen = 0X000194 // float32
    m_flForwardMove = 0X000198 // float32
    m_flLeftMove = 0X00019C // float32
    m_flUpMove = 0X0001A0 // float32
    m_vecOldViewAngles = 0X0001A4 // QAngle

 CPlayer_MovementServices_Humanoid: [client.dll]
    m_flStepSoundTime = 0X0001B8 // float32
    m_flFallVelocity = 0X0001BC // float32
    m_bInCrouch = 0X0001C0 // bool
    m_nCrouchState = 0X0001C4 // uint32
    m_flCrouchTransitionStartTime = 0X0001C8 // GameTime_t
    m_bDucked = 0X0001CC // bool
    m_bDucking = 0X0001CD // bool
    m_bInDuckJump = 0X0001CE // bool
    m_groundNormal = 0X0001D0 // Vector
    m_flSurfaceFriction = 0X0001DC // float32
    m_surfaceProps = 0X0001E0 // CUtlStringToken
    m_nStepside = 0X0001F0 // int32

 CPlayer_ObserverServices: [client.dll]
    m_iObserverMode = 0X000040 // uint8
    m_hObserverTarget = 0X000044 // CHandle< C_BaseEntity >
    m_iObserverLastMode = 0X000048 // ObserverMode_t
    m_bForcedObserverMode = 0X00004C // bool
    m_flObserverChaseDistance = 0X000050 // float32

 CPlayer_UseServices: [client.dll]
    No schemes available

 CPlayer_WaterServices: [client.dll]
    No schemes available

 CPlayer_WeaponServices: [client.dll]
    m_bAllowSwitchToNoWeapon = 0X000040 // bool
    m_hMyWeapons = 0X000048 // C_NetworkUtlVectorBase< CHandle< C_BasePlayerWeapon > >
    m_hActiveWeapon = 0X000060 // CHandle< C_BasePlayerWeapon >
    m_hLastWeapon = 0X000064 // CHandle< C_BasePlayerWeapon >
    m_iAmmo = 0X000068 // uint16[32]

 CBodyComponentBaseAnimGraph: [client.dll]
    m_animationController = 0X000470 // CBaseAnimGraphController
    __m_pChainEntity = 0X001708 // CNetworkVarChainer

 EntityRenderAttribute_t: [client.dll]
    m_ID = 0X000030 // CUtlStringToken
    m_Values = 0X000034 // Vector4D

 ActiveModelConfig_t: [client.dll]
    m_Handle = 0X000028 // ModelConfigHandle_t
    m_Name = 0X000030 // CUtlSymbolLarge
    m_AssociatedEntities = 0X000038 // C_NetworkUtlVectorBase< CHandle< C_BaseModelEntity > >
    m_AssociatedEntityNames = 0X000050 // C_NetworkUtlVectorBase< CUtlSymbolLarge >

 CBodyComponentBaseModelEntity: [client.dll]
    __m_pChainEntity = 0X000470 // CNetworkVarChainer

 CGameSceneNodeHandle: [client.dll]
    m_hOwner = 0X000008 // CEntityHandle
    m_name = 0X00000C // CUtlStringToken

 CGameSceneNode: [client.dll]
    m_nodeToWorld = 0X000010 // CTransform
    m_pOwner = 0X000030 // CEntityInstance*
    m_pParent = 0X000038 // CGameSceneNode*
    m_pChild = 0X000040 // CGameSceneNode*
    m_pNextSibling = 0X000048 // CGameSceneNode*
    m_hParent = 0X000070 // CGameSceneNodeHandle
    m_vecOrigin = 0X000080 // CNetworkOriginCellCoordQuantizedVector
    m_angRotation = 0X0000B8 // QAngle
    m_flScale = 0X0000C4 // float32
    m_vecAbsOrigin = 0X0000C8 // Vector
    m_angAbsRotation = 0X0000D4 // QAngle
    m_flAbsScale = 0X0000E0 // float32
    m_nParentAttachmentOrBone = 0X0000E4 // int16
    m_bDebugAbsOriginChanges = 0X0000E6 // bool
    m_bDormant = 0X0000E7 // bool
    m_bForceParentToBeNetworked = 0X0000E8 // bool
    m_bDirtyHierarchy = 0X000000 // bitfield:1
    m_bDirtyBoneMergeInfo = 0X000000 // bitfield:1
    m_bNetworkedPositionChanged = 0X000000 // bitfield:1
    m_bNetworkedAnglesChanged = 0X000000 // bitfield:1
    m_bNetworkedScaleChanged = 0X000000 // bitfield:1
    m_bWillBeCallingPostDataUpdate = 0X000000 // bitfield:1
    m_bNotifyBoneTransformsChanged = 0X000000 // bitfield:1
    m_bBoneMergeFlex = 0X000000 // bitfield:1
    m_nLatchAbsOrigin = 0X000000 // bitfield:2
    m_bDirtyBoneMergeBoneToRoot = 0X000000 // bitfield:1
    m_nHierarchicalDepth = 0X0000EB // uint8
    m_nHierarchyType = 0X0000EC // uint8
    m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0X0000ED // uint8
    m_name = 0X0000F0 // CUtlStringToken
    m_hierarchyAttachName = 0X000130 // CUtlStringToken
    m_flZOffset = 0X000134 // float32
    m_vRenderOrigin = 0X000138 // Vector

 CNetworkedSequenceOperation: [client.dll]
    m_hSequence = 0X000008 // HSequence
    m_flPrevCycle = 0X00000C // float32
    m_flCycle = 0X000010 // float32
    m_flWeight = 0X000014 // CNetworkedQuantizedFloat
    m_bSequenceChangeNetworked = 0X00001C // bool
    m_bDiscontinuity = 0X00001D // bool
    m_flPrevCycleFromDiscontinuity = 0X000020 // float32
    m_flPrevCycleForAnimEventDetection = 0X000024 // float32

 CModelState: [client.dll]
    m_hModel = 0X0000A0 // CStrongHandle< InfoForResourceTypeCModel >
    m_ModelName = 0X0000A8 // CUtlSymbolLarge
    m_bClientClothCreationSuppressed = 0X0000E8 // bool
    m_MeshGroupMask = 0X000180 // uint64
    m_nIdealMotionType = 0X000222 // int8
    m_nForceLOD = 0X000223 // int8
    m_nClothUpdateFlags = 0X000224 // int8

 CSkeletonInstance: [client.dll]
    m_modelState = 0X000160 // CModelState
    m_bIsAnimationEnabled = 0X000390 // bool
    m_bUseParentRenderBounds = 0X000391 // bool
    m_bDisableSolidCollisionsForHierarchy = 0X000392 // bool
    m_bDirtyMotionType = 0X000000 // bitfield:1
    m_bIsGeneratingLatchedParentSpaceState = 0X000000 // bitfield:1
    m_materialGroup = 0X000394 // CUtlStringToken
    m_nHitboxSet = 0X000398 // uint8

 IntervalTimer: [client.dll]
    m_timestamp = 0X000008 // GameTime_t
    m_nWorldGroupId = 0X00000C // WorldGroupId_t

 CountdownTimer: [client.dll]
    m_duration = 0X000008 // float32
    m_timestamp = 0X00000C // GameTime_t
    m_timescale = 0X000010 // float32
    m_nWorldGroupId = 0X000014 // WorldGroupId_t

 EngineCountdownTimer: [client.dll]
    m_duration = 0X000008 // float32
    m_timestamp = 0X00000C // float32
    m_timescale = 0X000010 // float32

 CTimeline: [client.dll]
    m_flValues = 0X000010 // float32[64]
    m_nValueCounts = 0X000110 // int32[64]
    m_nBucketCount = 0X000210 // int32
    m_flInterval = 0X000214 // float32
    m_flFinalValue = 0X000218 // float32
    m_nCompressionType = 0X00021C // TimelineCompression_t
    m_bStopped = 0X000220 // bool

 CAnimGraphNetworkedVariables: [client.dll]
    m_PredNetBoolVariables = 0X000008 // C_NetworkUtlVectorBase< uint32 >
    m_PredNetByteVariables = 0X000020 // C_NetworkUtlVectorBase< uint8 >
    m_PredNetUInt16Variables = 0X000038 // C_NetworkUtlVectorBase< uint16 >
    m_PredNetIntVariables = 0X000050 // C_NetworkUtlVectorBase< int32 >
    m_PredNetUInt32Variables = 0X000068 // C_NetworkUtlVectorBase< uint32 >
    m_PredNetFloatVariables = 0X000080 // C_NetworkUtlVectorBase< float32 >
    m_PredNetVectorVariables = 0X000098 // C_NetworkUtlVectorBase< Vector >
    m_PredNetQuaternionVariables = 0X0000B0 // C_NetworkUtlVectorBase< Quaternion >
    m_OwnerOnlyPredNetBoolVariables = 0X0000C8 // C_NetworkUtlVectorBase< uint32 >
    m_OwnerOnlyPredNetByteVariables = 0X0000E0 // C_NetworkUtlVectorBase< uint8 >
    m_OwnerOnlyPredNetUInt16Variables = 0X0000F8 // C_NetworkUtlVectorBase< uint16 >
    m_OwnerOnlyPredNetIntVariables = 0X000110 // C_NetworkUtlVectorBase< int32 >
    m_OwnerOnlyPredNetUInt32Variables = 0X000128 // C_NetworkUtlVectorBase< uint32 >
    m_OwnerOnlyPredNetFloatVariables = 0X000140 // C_NetworkUtlVectorBase< float32 >
    m_OwnerOnlyPredNetVectorVariables = 0X000158 // C_NetworkUtlVectorBase< Vector >
    m_OwnerOnlyPredNetQuaternionVariables = 0X000170 // C_NetworkUtlVectorBase< Quaternion >
    m_nBoolVariablesCount = 0X000188 // int32
    m_nOwnerOnlyBoolVariablesCount = 0X00018C // int32
    m_nRandomSeedOffset = 0X000190 // int32
    m_flLastTeleportTime = 0X001120 // float32

 C_BaseEntity: [client.dll]
    m_CBodyComponent = 0X000030 // CBodyComponent*
    m_NetworkTransmitComponent = 0X000038 // CNetworkTransmitComponent
    m_nLastThinkTick = 0X0002F8 // GameTick_t
    m_pGameSceneNode = 0X000300 // CGameSceneNode*
    m_pRenderComponent = 0X000308 // CRenderComponent*
    m_pCollision = 0X000310 // CCollisionProperty*
    m_iMaxHealth = 0X000318 // int32
    m_iHealth = 0X00031C // int32
    m_lifeState = 0X000320 // uint8
    m_bTakesDamage = 0X000321 // bool
    m_nTakeDamageFlags = 0X000324 // TakeDamageFlags_t
    m_ubInterpolationFrame = 0X000328 // uint8
    m_hSceneObjectController = 0X00032C // CHandle< C_BaseEntity >
    m_nNoInterpolationTick = 0X000330 // int32
    m_nVisibilityNoInterpolationTick = 0X000334 // int32
    m_flProxyRandomValue = 0X000338 // float32
    m_iEFlags = 0X00033C // int32
    m_nWaterType = 0X000340 // uint8
    m_bInterpolateEvenWithNoModel = 0X000341 // bool
    m_bPredictionEligible = 0X000342 // bool
    m_bApplyLayerMatchIDToModel = 0X000343 // bool
    m_tokLayerMatchID = 0X000344 // CUtlStringToken
    m_nSubclassID = 0X000348 // CUtlStringToken
    m_nSimulationTick = 0X000358 // int32
    m_iCurrentThinkContext = 0X00035C // int32
    m_aThinkFunctions = 0X000360 // CUtlVector< thinkfunc_t >
    m_flAnimTime = 0X000378 // float32
    m_flSimulationTime = 0X00037C // float32
    m_nSceneObjectOverrideFlags = 0X000380 // uint8
    m_bHasSuccessfullyInterpolated = 0X000381 // bool
    m_bHasAddedVarsToInterpolation = 0X000382 // bool
    m_bRenderEvenWhenNotSuccessfullyInterpolated = 0X000383 // bool
    m_nInterpolationLatchDirtyFlags = 0X000384 // int32[2]
    m_ListEntry = 0X00038C // uint16[11]
    m_flCreateTime = 0X0003A4 // GameTime_t
    m_flSpeed = 0X0003A8 // float32
    m_EntClientFlags = 0X0003AC // uint16
    m_bClientSideRagdoll = 0X0003AE // bool
    m_iTeamNum = 0X0003AF // uint8
    m_spawnflags = 0X0003B0 // uint32
    m_nNextThinkTick = 0X0003B4 // GameTick_t
    m_fFlags = 0X0003B8 // uint32
    m_vecAbsVelocity = 0X0003BC // Vector
    m_vecVelocity = 0X0003C8 // CNetworkVelocityVector
    m_vecBaseVelocity = 0X0003F8 // Vector
    m_hEffectEntity = 0X000404 // CHandle< C_BaseEntity >
    m_hOwnerEntity = 0X000408 // CHandle< C_BaseEntity >
    m_MoveCollide = 0X00040C // MoveCollide_t
    m_MoveType = 0X00040D // MoveType_t
    m_flWaterLevel = 0X000410 // float32
    m_fEffects = 0X000414 // uint32
    m_hGroundEntity = 0X000418 // CHandle< C_BaseEntity >
    m_flFriction = 0X00041C // float32
    m_flElasticity = 0X000420 // float32
    m_flGravityScale = 0X000424 // float32
    m_flTimeScale = 0X000428 // float32
    m_bSimulatedEveryTick = 0X00042C // bool
    m_bAnimatedEveryTick = 0X00042D // bool
    m_nMinCPULevel = 0X00042E // uint8
    m_nMaxCPULevel = 0X00042F // uint8
    m_nMinGPULevel = 0X000430 // uint8
    m_nMaxGPULevel = 0X000431 // uint8
    m_flNavIgnoreUntilTime = 0X000434 // GameTime_t
    m_hThink = 0X000438 // uint16
    m_fBBoxVisFlags = 0X000448 // uint8
    m_bPredictable = 0X000449 // bool
    m_bRenderWithViewModels = 0X00044A // bool
    m_nSplitUserPlayerPredictionSlot = 0X00044C // CSplitScreenSlot
    m_nFirstPredictableCommand = 0X000450 // int32
    m_nLastPredictableCommand = 0X000454 // int32
    m_hOldMoveParent = 0X000458 // CHandle< C_BaseEntity >
    m_Particles = 0X000460 // CParticleProperty
    m_vecPredictedScriptFloats = 0X000488 // CUtlVector< float32 >
    m_vecPredictedScriptFloatIDs = 0X0004A0 // CUtlVector< int32 >
    m_nNextScriptVarRecordID = 0X0004D0 // int32
    m_vecAngVelocity = 0X0004E0 // QAngle
    m_DataChangeEventRef = 0X0004EC // int32
    m_dependencies = 0X0004F0 // CUtlVector< CEntityHandle >
    m_nCreationTick = 0X000508 // int32
    m_bAnimTimeChanged = 0X000521 // bool
    m_bSimulationTimeChanged = 0X000522 // bool
    m_sUniqueHammerID = 0X000530 // CUtlString

 CLogicalEntity: [client.dll]
    No schemes available

 C_BaseFlex::Emphasized_Phoneme: [client.dll]
    m_sClassName = 0X000000 // CUtlString
    m_flAmount = 0X000018 // float32
    m_bRequired = 0X00001C // bool
    m_bBasechecked = 0X00001D // bool
    m_bValid = 0X00001E // bool

 C_ColorCorrection: [client.dll]
    m_vecOrigin = 0X000538 // Vector
    m_MinFalloff = 0X000544 // float32
    m_MaxFalloff = 0X000548 // float32
    m_flFadeInDuration = 0X00054C // float32
    m_flFadeOutDuration = 0X000550 // float32
    m_flMaxWeight = 0X000554 // float32
    m_flCurWeight = 0X000558 // float32
    m_netlookupFilename = 0X00055C // char[512]
    m_bEnabled = 0X00075C // bool
    m_bMaster = 0X00075D // bool
    m_bClientSide = 0X00075E // bool
    m_bExclusive = 0X00075F // bool
    m_bEnabledOnClient = 0X000760 // bool[1]
    m_flCurWeightOnClient = 0X000764 // float32[1]
    m_bFadingIn = 0X000768 // bool[1]
    m_flFadeStartWeight = 0X00076C // float32[1]
    m_flFadeStartTime = 0X000770 // float32[1]
    m_flFadeDuration = 0X000774 // float32[1]

 C_EnvWindClientside: [client.dll]
    m_EnvWindShared = 0X000538 // C_EnvWindShared

 C_EntityFlame: [client.dll]
    m_hEntAttached = 0X000538 // CHandle< C_BaseEntity >
    m_hOldAttached = 0X000560 // CHandle< C_BaseEntity >
    m_bCheapEffect = 0X000564 // bool

 CProjectedTextureBase: [client.dll]
    m_hTargetEntity = 0X00000C // CHandle< C_BaseEntity >
    m_bState = 0X000010 // bool
    m_bAlwaysUpdate = 0X000011 // bool
    m_flLightFOV = 0X000014 // float32
    m_bEnableShadows = 0X000018 // bool
    m_bSimpleProjection = 0X000019 // bool
    m_bLightOnlyTarget = 0X00001A // bool
    m_bLightWorld = 0X00001B // bool
    m_bCameraSpace = 0X00001C // bool
    m_flBrightnessScale = 0X000020 // float32
    m_LightColor = 0X000024 // Color
    m_flIntensity = 0X000028 // float32
    m_flLinearAttenuation = 0X00002C // float32
    m_flQuadraticAttenuation = 0X000030 // float32
    m_bVolumetric = 0X000034 // bool
    m_flVolumetricIntensity = 0X000038 // float32
    m_flNoiseStrength = 0X00003C // float32
    m_flFlashlightTime = 0X000040 // float32
    m_nNumPlanes = 0X000044 // uint32
    m_flPlaneOffset = 0X000048 // float32
    m_flColorTransitionTime = 0X00004C // float32
    m_flAmbient = 0X000050 // float32
    m_SpotlightTextureName = 0X000054 // char[512]
    m_nSpotlightTextureFrame = 0X000254 // int32
    m_nShadowQuality = 0X000258 // uint32
    m_flNearZ = 0X00025C // float32
    m_flFarZ = 0X000260 // float32
    m_flProjectionSize = 0X000264 // float32
    m_flRotation = 0X000268 // float32
    m_bFlipHorizontal = 0X00026C // bool

 C_BaseFire: [client.dll]
    m_flScale = 0X000538 // float32
    m_flStartScale = 0X00053C // float32
    m_flScaleTime = 0X000540 // float32
    m_nFlags = 0X000544 // uint32

 C_FireSmoke: [client.dll]
    m_nFlameModelIndex = 0X000548 // int32
    m_nFlameFromAboveModelIndex = 0X00054C // int32
    m_flScaleRegister = 0X000550 // float32
    m_flScaleStart = 0X000554 // float32
    m_flScaleEnd = 0X000558 // float32
    m_flScaleTimeStart = 0X00055C // GameTime_t
    m_flScaleTimeEnd = 0X000560 // GameTime_t
    m_flChildFlameSpread = 0X000564 // float32
    m_flClipPerc = 0X000578 // float32
    m_bClipTested = 0X00057C // bool
    m_bFadingOut = 0X00057D // bool
    m_tParticleSpawn = 0X000580 // TimedEvent
    m_pFireOverlay = 0X000588 // CFireOverlay*

 C_RopeKeyframe::CPhysicsDelegate: [client.dll]
    m_pKeyframe = 0X000008 // C_RopeKeyframe*

 C_SceneEntity::QueuedEvents_t: [client.dll]
    starttime = 0X000000 // float32

 C_TintController: [client.dll]
    No schemes available

 C_TriggerCamera: [client.dll]
    No schemes available

 CFlashlightEffect: [client.dll]
    m_bIsOn = 0X000010 // bool
    m_bMuzzleFlashEnabled = 0X000020 // bool
    m_flMuzzleFlashBrightness = 0X000024 // float32
    m_quatMuzzleFlashOrientation = 0X000030 // Quaternion
    m_vecMuzzleFlashOrigin = 0X000040 // Vector
    m_flFov = 0X00004C // float32
    m_flFarZ = 0X000050 // float32
    m_flLinearAtten = 0X000054 // float32
    m_bCastsShadows = 0X000058 // bool
    m_flCurrentPullBackDist = 0X00005C // float32
    m_FlashlightTexture = 0X000060 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_MuzzleFlashTexture = 0X000068 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_textureName = 0X000070 // char[64]

 CInterpolatedValue: [client.dll]
    m_flStartTime = 0X000000 // float32
    m_flEndTime = 0X000004 // float32
    m_flStartValue = 0X000008 // float32
    m_flEndValue = 0X00000C // float32
    m_nInterpType = 0X000010 // int32

 CGlowSprite: [client.dll]
    m_vColor = 0X000000 // Vector
    m_flHorzSize = 0X00000C // float32
    m_flVertSize = 0X000010 // float32
    m_hMaterial = 0X000018 // CStrongHandle< InfoForResourceTypeIMaterial2 >

 CGlowOverlay: [client.dll]
    m_vPos = 0X000008 // Vector
    m_bDirectional = 0X000014 // bool
    m_vDirection = 0X000018 // Vector
    m_bInSky = 0X000024 // bool
    m_skyObstructionScale = 0X000028 // float32
    m_Sprites = 0X000030 // CGlowSprite[4]
    m_nSprites = 0X0000B0 // int32
    m_flProxyRadius = 0X0000B4 // float32
    m_flHDRColorScale = 0X0000B8 // float32
    m_flGlowObstructionScale = 0X0000BC // float32
    m_bCacheGlowObstruction = 0X0000C0 // bool
    m_bCacheSkyObstruction = 0X0000C1 // bool
    m_bActivated = 0X0000C2 // int16
    m_ListIndex = 0X0000C4 // uint16
    m_queryHandle = 0X0000C8 // int32

 IClientAlphaProperty: [client.dll]
    No schemes available

 CSkyboxReference: [client.dll]
    m_worldGroupId = 0X000538 // WorldGroupId_t
    m_hSkyCamera = 0X00053C // CHandle< C_SkyCamera >

 C_SkyCamera: [client.dll]
    m_skyboxData = 0X000538 // sky3dparams_t
    m_skyboxSlotToken = 0X0005C8 // CUtlStringToken
    m_bUseAngles = 0X0005CC // bool
    m_pNext = 0X0005D0 // C_SkyCamera*

 TimedEvent: [client.dll]
    m_TimeBetweenEvents = 0X000000 // float32
    m_fNextEvent = 0X000004 // float32

 VPhysicsCollisionAttribute_t: [client.dll]
    m_nInteractsAs = 0X000008 // uint64
    m_nInteractsWith = 0X000010 // uint64
    m_nInteractsExclude = 0X000018 // uint64
    m_nEntityId = 0X000020 // uint32
    m_nOwnerId = 0X000024 // uint32
    m_nHierarchyId = 0X000028 // uint16
    m_nCollisionGroup = 0X00002A // uint8
    m_nCollisionFunctionMask = 0X00002B // uint8

 CCollisionProperty: [client.dll]
    m_collisionAttribute = 0X000010 // VPhysicsCollisionAttribute_t
    m_vecMins = 0X000040 // Vector
    m_vecMaxs = 0X00004C // Vector
    m_usSolidFlags = 0X00005A // uint8
    m_nSolidType = 0X00005B // SolidType_t
    m_triggerBloat = 0X00005C // uint8
    m_nSurroundType = 0X00005D // SurroundingBoundsType_t
    m_CollisionGroup = 0X00005E // uint8
    m_nEnablePhysics = 0X00005F // uint8
    m_flBoundingRadius = 0X000060 // float32
    m_vecSpecifiedSurroundingMins = 0X000064 // Vector
    m_vecSpecifiedSurroundingMaxs = 0X000070 // Vector
    m_vecSurroundingMaxs = 0X00007C // Vector
    m_vecSurroundingMins = 0X000088 // Vector
    m_vCapsuleCenter1 = 0X000094 // Vector
    m_vCapsuleCenter2 = 0X0000A0 // Vector
    m_flCapsuleRadius = 0X0000AC // float32

 CDecalInfo: [client.dll]
    m_flAnimationScale = 0X000000 // float32
    m_flAnimationLifeSpan = 0X000004 // float32
    m_flPlaceTime = 0X000008 // float32
    m_flFadeStartTime = 0X00000C // float32
    m_flFadeDuration = 0X000010 // float32
    m_nVBSlot = 0X000014 // int32
    m_nBoneIndex = 0X000018 // int32
    m_pNext = 0X000028 // CDecalInfo*
    m_pPrev = 0X000030 // CDecalInfo*
    m_nDecalMaterialIndex = 0X000090 // int32

 CEffectData: [client.dll]
    m_vOrigin = 0X000008 // Vector
    m_vStart = 0X000014 // Vector
    m_vNormal = 0X000020 // Vector
    m_vAngles = 0X00002C // QAngle
    m_hEntity = 0X000038 // CEntityHandle
    m_hOtherEntity = 0X00003C // CEntityHandle
    m_flScale = 0X000040 // float32
    m_flMagnitude = 0X000044 // float32
    m_flRadius = 0X000048 // float32
    m_nSurfaceProp = 0X00004C // CUtlStringToken
    m_nEffectIndex = 0X000050 // CWeakHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_nDamageType = 0X000058 // uint32
    m_nPenetrate = 0X00005C // uint8
    m_nMaterial = 0X00005E // uint16
    m_nHitBox = 0X000060 // uint16
    m_nColor = 0X000062 // uint8
    m_fFlags = 0X000063 // uint8
    m_nAttachmentIndex = 0X000064 // AttachmentHandle_t
    m_nAttachmentName = 0X000068 // CUtlStringToken
    m_iEffectName = 0X00006C // uint16
    m_nExplosionType = 0X00006E // uint8

 C_EnvDetailController: [client.dll]
    m_flFadeStartDist = 0X000538 // float32
    m_flFadeEndDist = 0X00053C // float32

 C_EnvWindShared: [client.dll]
    m_flStartTime = 0X000008 // GameTime_t
    m_iWindSeed = 0X00000C // uint32
    m_iMinWind = 0X000010 // uint16
    m_iMaxWind = 0X000012 // uint16
    m_windRadius = 0X000014 // int32
    m_iMinGust = 0X000018 // uint16
    m_iMaxGust = 0X00001A // uint16
    m_flMinGustDelay = 0X00001C // float32
    m_flMaxGustDelay = 0X000020 // float32
    m_flGustDuration = 0X000024 // float32
    m_iGustDirChange = 0X000028 // uint16
    m_location = 0X00002C // Vector
    m_iszGustSound = 0X000038 // int32
    m_iWindDir = 0X00003C // int32
    m_flWindSpeed = 0X000040 // float32
    m_currentWindVector = 0X000044 // Vector
    m_CurrentSwayVector = 0X000050 // Vector
    m_PrevSwayVector = 0X00005C // Vector
    m_iInitialWindDir = 0X000068 // uint16
    m_flInitialWindSpeed = 0X00006C // float32
    m_flVariationTime = 0X000070 // GameTime_t
    m_flSwayTime = 0X000074 // GameTime_t
    m_flSimTime = 0X000078 // GameTime_t
    m_flSwitchTime = 0X00007C // GameTime_t
    m_flAveWindSpeed = 0X000080 // float32
    m_bGusting = 0X000084 // bool
    m_flWindAngleVariation = 0X000088 // float32
    m_flWindSpeedVariation = 0X00008C // float32
    m_iEntIndex = 0X000090 // CEntityIndex

 C_EnvWindShared::WindAveEvent_t: [client.dll]
    m_flStartWindSpeed = 0X000000 // float32
    m_flAveWindSpeed = 0X000004 // float32

 C_EnvWindShared::WindVariationEvent_t: [client.dll]
    m_flWindAngleVariation = 0X000000 // float32
    m_flWindSpeedVariation = 0X000004 // float32

 C_InfoLadderDismount: [client.dll]
    No schemes available

 shard_model_desc_t: [client.dll]
    m_nModelID = 0X000008 // int32
    m_hMaterial = 0X000010 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_solid = 0X000018 // ShardSolid_t
    m_ShatterPanelMode = 0X000019 // ShatterPanelMode
    m_vecPanelSize = 0X00001C // Vector2D
    m_vecStressPositionA = 0X000024 // Vector2D
    m_vecStressPositionB = 0X00002C // Vector2D
    m_vecPanelVertices = 0X000038 // C_NetworkUtlVectorBase< Vector2D >
    m_flGlassHalfThickness = 0X000050 // float32
    m_bHasParent = 0X000054 // bool
    m_bParentFrozen = 0X000055 // bool
    m_SurfacePropStringToken = 0X000058 // CUtlStringToken
    m_LightGroup = 0X00005C // CUtlStringToken

 C_GameRulesProxy: [client.dll]
    No schemes available

 C_GameRules: [client.dll]
    No schemes available

 CGlowProperty: [client.dll]
    m_fGlowColor = 0X000008 // Vector
    m_iGlowType = 0X000030 // int32
    m_iGlowTeam = 0X000034 // int32
    m_nGlowRange = 0X000038 // int32
    m_nGlowRangeMin = 0X00003C // int32
    m_glowColorOverride = 0X000040 // Color
    m_bFlashing = 0X000044 // bool
    m_flGlowTime = 0X000048 // float32
    m_flGlowStartTime = 0X00004C // float32
    m_bEligibleForScreenHighlight = 0X000050 // bool
    m_bGlowing = 0X000051 // bool

 C_MultiplayRules: [client.dll]
    No schemes available

 fogparams_t: [client.dll]
    dirPrimary = 0X000008 // Vector
    colorPrimary = 0X000014 // Color
    colorSecondary = 0X000018 // Color
    colorPrimaryLerpTo = 0X00001C // Color
    colorSecondaryLerpTo = 0X000020 // Color
    start = 0X000024 // float32
    end = 0X000028 // float32
    farz = 0X00002C // float32
    maxdensity = 0X000030 // float32
    exponent = 0X000034 // float32
    HDRColorScale = 0X000038 // float32
    skyboxFogFactor = 0X00003C // float32
    skyboxFogFactorLerpTo = 0X000040 // float32
    startLerpTo = 0X000044 // float32
    endLerpTo = 0X000048 // float32
    maxdensityLerpTo = 0X00004C // float32
    lerptime = 0X000050 // GameTime_t
    duration = 0X000054 // float32
    blendtobackground = 0X000058 // float32
    scattering = 0X00005C // float32
    locallightscale = 0X000060 // float32
    enable = 0X000064 // bool
    blend = 0X000065 // bool
    m_bNoReflectionFog = 0X000066 // bool
    m_bPadding = 0X000067 // bool

 C_fogplayerparams_t: [client.dll]
    m_hCtrl = 0X000008 // CHandle< C_FogController >
    m_flTransitionTime = 0X00000C // float32
    m_OldColor = 0X000010 // Color
    m_flOldStart = 0X000014 // float32
    m_flOldEnd = 0X000018 // float32
    m_flOldMaxDensity = 0X00001C // float32
    m_flOldHDRColorScale = 0X000020 // float32
    m_flOldFarZ = 0X000024 // float32
    m_NewColor = 0X000028 // Color
    m_flNewStart = 0X00002C // float32
    m_flNewEnd = 0X000030 // float32
    m_flNewMaxDensity = 0X000034 // float32
    m_flNewHDRColorScale = 0X000038 // float32
    m_flNewFarZ = 0X00003C // float32

 sky3dparams_t: [client.dll]
    scale = 0X000008 // int16
    origin = 0X00000C // Vector
    bClip3DSkyBoxNearToWorldFar = 0X000018 // bool
    flClip3DSkyBoxNearToWorldFarOffset = 0X00001C // float32
    fog = 0X000020 // fogparams_t
    m_nWorldGroupID = 0X000088 // WorldGroupId_t

 PhysicsRagdollPose_t: [client.dll]
    __m_pChainEntity = 0X000008 // CNetworkVarChainer
    m_Transforms = 0X000030 // C_NetworkUtlVectorBase< CTransform >
    m_bDirty = 0X000048 // bool

 C_SingleplayRules: [client.dll]
    No schemes available

 C_SoundOpvarSetPointBase: [client.dll]
    m_iszStackName = 0X000538 // CUtlSymbolLarge
    m_iszOperatorName = 0X000540 // CUtlSymbolLarge
    m_iszOpvarName = 0X000548 // CUtlSymbolLarge
    m_iOpvarIndex = 0X000550 // int32
    m_bUseAutoCompare = 0X000554 // bool

 C_SoundOpvarSetPointEntity: [client.dll]
    No schemes available

 C_SoundOpvarSetAABBEntity: [client.dll]
    No schemes available

 C_SoundOpvarSetOBBEntity: [client.dll]
    No schemes available

 C_SoundOpvarSetPathCornerEntity: [client.dll]
    No schemes available

 C_SoundOpvarSetOBBWindEntity: [client.dll]
    No schemes available

 C_TeamplayRules: [client.dll]
    No schemes available

 C_TeamRoundTimer: [client.dll]
    m_bTimerPaused = 0X000538 // bool
    m_flTimeRemaining = 0X00053C // float32
    m_flTimerEndTime = 0X000540 // GameTime_t
    m_bIsDisabled = 0X000544 // bool
    m_bShowInHUD = 0X000545 // bool
    m_nTimerLength = 0X000548 // int32
    m_nTimerInitialLength = 0X00054C // int32
    m_nTimerMaxLength = 0X000550 // int32
    m_bAutoCountdown = 0X000554 // bool
    m_nSetupTimeLength = 0X000558 // int32
    m_nState = 0X00055C // int32
    m_bStartPaused = 0X000560 // bool
    m_bInCaptureWatchState = 0X000561 // bool
    m_flTotalTime = 0X000564 // float32
    m_bStopWatchTimer = 0X000568 // bool
    m_bFireFinished = 0X000569 // bool
    m_bFire5MinRemain = 0X00056A // bool
    m_bFire4MinRemain = 0X00056B // bool
    m_bFire3MinRemain = 0X00056C // bool
    m_bFire2MinRemain = 0X00056D // bool
    m_bFire1MinRemain = 0X00056E // bool
    m_bFire30SecRemain = 0X00056F // bool
    m_bFire10SecRemain = 0X000570 // bool
    m_bFire5SecRemain = 0X000571 // bool
    m_bFire4SecRemain = 0X000572 // bool
    m_bFire3SecRemain = 0X000573 // bool
    m_bFire2SecRemain = 0X000574 // bool
    m_bFire1SecRemain = 0X000575 // bool
    m_nOldTimerLength = 0X000578 // int32
    m_nOldTimerState = 0X00057C // int32

 CAttributeList: [client.dll]
    m_Attributes = 0X000008 // C_UtlVectorEmbeddedNetworkVar< CEconItemAttribute >
    m_pManager = 0X000058 // CAttributeManager*

 CEconItemAttribute: [client.dll]
    m_iAttributeDefinitionIndex = 0X000030 // uint16
    m_flValue = 0X000034 // float32
    m_flInitialValue = 0X000038 // float32
    m_nRefundableCurrency = 0X00003C // int32
    m_bSetBonus = 0X000040 // bool

 CAttributeManager: [client.dll]
    m_Providers = 0X000008 // CUtlVector< CHandle< C_BaseEntity > >
    m_iReapplyProvisionParity = 0X000020 // int32
    m_hOuter = 0X000024 // CHandle< C_BaseEntity >
    m_bPreventLoopback = 0X000028 // bool
    m_ProviderType = 0X00002C // attributeprovidertypes_t
    m_CachedResults = 0X000030 // CUtlVector< CAttributeManager::cached_attribute_float_t >

 CAttributeManager::cached_attribute_float_t: [client.dll]
    flIn = 0X000000 // float32
    iAttribHook = 0X000008 // CUtlSymbolLarge
    flOut = 0X000010 // float32

 C_AttributeContainer: [client.dll]
    m_Item = 0X000050 // C_EconItemView
    m_iExternalItemProviderRegisteredToken = 0X000498 // int32
    m_ullRegisteredAsItemID = 0X0004A0 // uint64

 C_EconEntity::AttachedModelData_t: [client.dll]
    m_iModelDisplayFlags = 0X000000 // int32

 EntitySpottedState_t: [client.dll]
    m_bSpotted = 0X000008 // bool
    m_bSpottedByMask = 0X00000C // uint32[2]

 C_CSGameRulesProxy: [client.dll]
    m_pGameRules = 0X000538 // C_CSGameRules*

 C_CSGameRules: [client.dll]
    __m_pChainEntity = 0X000008 // CNetworkVarChainer
    m_bFreezePeriod = 0X000030 // bool
    m_bWarmupPeriod = 0X000031 // bool
    m_fWarmupPeriodEnd = 0X000034 // GameTime_t
    m_fWarmupPeriodStart = 0X000038 // GameTime_t
    m_bTerroristTimeOutActive = 0X00003C // bool
    m_bCTTimeOutActive = 0X00003D // bool
    m_flTerroristTimeOutRemaining = 0X000040 // float32
    m_flCTTimeOutRemaining = 0X000044 // float32
    m_nTerroristTimeOuts = 0X000048 // int32
    m_nCTTimeOuts = 0X00004C // int32
    m_bTechnicalTimeOut = 0X000050 // bool
    m_bMatchWaitingForResume = 0X000051 // bool
    m_iRoundTime = 0X000054 // int32
    m_fMatchStartTime = 0X000058 // float32
    m_fRoundStartTime = 0X00005C // GameTime_t
    m_flRestartRoundTime = 0X000060 // GameTime_t
    m_bGameRestart = 0X000064 // bool
    m_flGameStartTime = 0X000068 // float32
    m_timeUntilNextPhaseStarts = 0X00006C // float32
    m_gamePhase = 0X000070 // int32
    m_totalRoundsPlayed = 0X000074 // int32
    m_nRoundsPlayedThisPhase = 0X000078 // int32
    m_nOvertimePlaying = 0X00007C // int32
    m_iHostagesRemaining = 0X000080 // int32
    m_bAnyHostageReached = 0X000084 // bool
    m_bMapHasBombTarget = 0X000085 // bool
    m_bMapHasRescueZone = 0X000086 // bool
    m_bMapHasBuyZone = 0X000087 // bool
    m_bIsQueuedMatchmaking = 0X000088 // bool
    m_nQueuedMatchmakingMode = 0X00008C // int32
    m_bIsValveDS = 0X000090 // bool
    m_bLogoMap = 0X000091 // bool
    m_bPlayAllStepSoundsOnServer = 0X000092 // bool
    m_iNumGunGameProgressiveWeaponsCT = 0X000094 // int32
    m_iNumGunGameProgressiveWeaponsT = 0X000098 // int32
    m_iSpectatorSlotCount = 0X00009C // int32
    m_GGProgressiveWeaponOrderCT = 0X0000A0 // int32[60]
    m_GGProgressiveWeaponOrderT = 0X000190 // int32[60]
    m_GGProgressiveWeaponKillUpgradeOrderCT = 0X000280 // int32[60]
    m_GGProgressiveWeaponKillUpgradeOrderT = 0X000370 // int32[60]
    m_MatchDevice = 0X000460 // int32
    m_bHasMatchStarted = 0X000464 // bool
    m_flDMBonusStartTime = 0X000468 // float32
    m_flDMBonusTimeLength = 0X00046C // float32
    m_unDMBonusWeaponLoadoutSlot = 0X000470 // uint16
    m_bDMBonusActive = 0X000472 // bool
    m_nNextMapInMapgroup = 0X000474 // int32
    m_szTournamentEventName = 0X000478 // char[512]
    m_szTournamentEventStage = 0X000678 // char[512]
    m_szMatchStatTxt = 0X000878 // char[512]
    m_szTournamentPredictionsTxt = 0X000A78 // char[512]
    m_nTournamentPredictionsPct = 0X000C78 // int32
    m_flCMMItemDropRevealStartTime = 0X000C7C // GameTime_t
    m_flCMMItemDropRevealEndTime = 0X000C80 // GameTime_t
    m_bIsDroppingItems = 0X000C84 // bool
    m_bIsQuestEligible = 0X000C85 // bool
    m_nGuardianModeWaveNumber = 0X000C88 // int32
    m_nGuardianModeSpecialKillsRemaining = 0X000C8C // int32
    m_nGuardianModeSpecialWeaponNeeded = 0X000C90 // int32
    m_nGuardianGrenadesToGiveBots = 0X000C94 // int32
    m_nNumHeaviesToSpawn = 0X000C98 // int32
    m_numGlobalGiftsGiven = 0X000C9C // uint32
    m_numGlobalGifters = 0X000CA0 // uint32
    m_numGlobalGiftsPeriodSeconds = 0X000CA4 // uint32
    m_arrFeaturedGiftersAccounts = 0X000CA8 // uint32[4]
    m_arrFeaturedGiftersGifts = 0X000CB8 // uint32[4]
    m_arrProhibitedItemIndices = 0X000CC8 // uint16[100]
    m_arrTournamentActiveCasterAccounts = 0X000D90 // uint32[4]
    m_numBestOfMaps = 0X000DA0 // int32
    m_nHalloweenMaskListSeed = 0X000DA4 // int32
    m_bBombDropped = 0X000DA8 // bool
    m_bBombPlanted = 0X000DA9 // bool
    m_iRoundWinStatus = 0X000DAC // int32
    m_eRoundWinReason = 0X000DB0 // int32
    m_bTCantBuy = 0X000DB4 // bool
    m_bCTCantBuy = 0X000DB5 // bool
    m_flGuardianBuyUntilTime = 0X000DB8 // GameTime_t
    m_iMatchStats_RoundResults = 0X000DBC // int32[30]
    m_iMatchStats_PlayersAlive_CT = 0X000E34 // int32[30]
    m_iMatchStats_PlayersAlive_T = 0X000EAC // int32[30]
    m_TeamRespawnWaveTimes = 0X000F24 // float32[32]
    m_flNextRespawnWave = 0X000FA4 // GameTime_t[32]
    m_nServerQuestID = 0X001024 // int32
    m_bDontIncrementCoopWave = 0X001028 // bool
    m_bSpawnedTerrorHuntHeavy = 0X001029 // bool
    m_nEndMatchMapGroupVoteTypes = 0X00102C // int32[10]
    m_nEndMatchMapGroupVoteOptions = 0X001054 // int32[10]
    m_nEndMatchMapVoteWinner = 0X00107C // int32
    m_iNumConsecutiveCTLoses = 0X001080 // int32
    m_iNumConsecutiveTerroristLoses = 0X001084 // int32
    m_bMarkClientStopRecordAtRoundEnd = 0X0010A0 // bool
    m_bHasTriggeredRoundStartMusic = 0X0010F8 // bool
    m_bHasTriggeredCoopSpawnReset = 0X0010F9 // bool
    m_bSwitchingTeamsAtRoundReset = 0X0010FA // bool
    m_iMaxGunGameProgressiveWeaponIndex = 0X0010FC // int32
    m_SurvivalRules = 0X001118 // C_SurvivalGameRules
    m_RetakeRules = 0X0017D8 // C_RetakeGameRules
    m_nMatchEndCount = 0X0018F0 // uint8
    m_bTeamIntroPeriod = 0X0018F1 // bool

 C_RetakeGameRules: [client.dll]
    m_nMatchSeed = 0X0000F8 // int32
    m_bBlockersPresent = 0X0000FC // bool
    m_bRoundInProgress = 0X0000FD // bool
    m_iFirstSecondHalfRound = 0X000100 // int32
    m_iBombSite = 0X000104 // int32

 CSPerRoundStats_t: [client.dll]
    m_iKills = 0X000030 // int32
    m_iDeaths = 0X000034 // int32
    m_iAssists = 0X000038 // int32
    m_iDamage = 0X00003C // int32
    m_iEquipmentValue = 0X000040 // int32
    m_iMoneySaved = 0X000044 // int32
    m_iKillReward = 0X000048 // int32
    m_iLiveTime = 0X00004C // int32
    m_iHeadShotKills = 0X000050 // int32
    m_iObjective = 0X000054 // int32
    m_iCashEarned = 0X000058 // int32
    m_iUtilityDamage = 0X00005C // int32
    m_iEnemiesFlashed = 0X000060 // int32

 CSMatchStats_t: [client.dll]
    m_iEnemy5Ks = 0X000068 // int32
    m_iEnemy4Ks = 0X00006C // int32
    m_iEnemy3Ks = 0X000070 // int32

 C_CSGO_TeamPreviewCharacterPosition: [client.dll]
    m_nOrdinal = 0X000538 // int32
    m_sWeaponName = 0X000540 // CUtlString
    m_xuid = 0X000548 // uint64
    m_weaponItem = 0X000550 // C_EconItemView

 C_CSGO_TeamSelectCharacterPosition: [client.dll]
    No schemes available

 C_CSGO_TeamSelectTerroristPosition: [client.dll]
    No schemes available

 C_CSGO_TeamSelectCounterTerroristPosition: [client.dll]
    No schemes available

 C_CSGO_TeamIntroCharacterPosition: [client.dll]
    No schemes available

 C_CSGO_TeamIntroTerroristPosition: [client.dll]
    No schemes available

 C_CSGO_TeamIntroCounterTerroristPosition: [client.dll]
    No schemes available

 WeaponPurchaseCount_t: [client.dll]
    m_nItemDefIndex = 0X000030 // uint16
    m_nCount = 0X000032 // uint16

 WeaponPurchaseTracker_t: [client.dll]
    m_weaponPurchases = 0X000008 // C_UtlVectorEmbeddedNetworkVar< WeaponPurchaseCount_t >

 CCSPlayer_ActionTrackingServices: [client.dll]
    m_bIsRescuing = 0X000040 // bool
    m_weaponPurchasesThisMatch = 0X000048 // WeaponPurchaseTracker_t
    m_weaponPurchasesThisRound = 0X0000A0 // WeaponPurchaseTracker_t

 C_PlayerPing: [client.dll]
    m_hPlayer = 0X000568 // CHandle< C_BaseEntity >
    m_hPingedEntity = 0X00056C // CHandle< C_BaseEntity >
    m_iType = 0X000570 // int32
    m_bUrgent = 0X000574 // bool
    m_szPlaceName = 0X000575 // char[18]

 CCSPlayer_PingServices: [client.dll]
    m_hPlayerPing = 0X000040 // CHandle< C_BaseEntity >

 C_CSPlayerResource: [client.dll]
    m_bHostageAlive = 0X000538 // bool[12]
    m_isHostageFollowingSomeone = 0X000544 // bool[12]
    m_iHostageEntityIDs = 0X000550 // CEntityIndex[12]
    m_bombsiteCenterA = 0X000580 // Vector
    m_bombsiteCenterB = 0X00058C // Vector
    m_hostageRescueX = 0X000598 // int32[4]
    m_hostageRescueY = 0X0005A8 // int32[4]
    m_hostageRescueZ = 0X0005B8 // int32[4]
    m_bEndMatchNextMapAllVoted = 0X0005C8 // bool
    m_foundGoalPositions = 0X0005C9 // bool

 CCSPlayer_BulletServices: [client.dll]
    m_totalHitsOnServer = 0X000040 // int32

 CCSPlayer_CameraServices: [client.dll]
    m_flLastShotFOV = 0X000248 // float32
    m_flDeathCamTilt = 0X00024C // float32

 CCSPlayer_HostageServices: [client.dll]
    m_hCarriedHostage = 0X000040 // CHandle< C_BaseEntity >
    m_hCarriedHostageProp = 0X000044 // CHandle< C_BaseEntity >

 CCSPlayer_ItemServices: [client.dll]
    m_bHasDefuser = 0X000040 // bool
    m_bHasHelmet = 0X000041 // bool
    m_bHasHeavyArmor = 0X000042 // bool

 CCSPlayer_MovementServices: [client.dll]
    m_flMaxFallVelocity = 0X0001F8 // float32
    m_vecLadderNormal = 0X0001FC // Vector
    m_nLadderSurfacePropIndex = 0X000208 // int32
    m_bAllowAutoMovement = 0X00020C // bool
    m_flDuckAmount = 0X000210 // float32
    m_flDuckSpeed = 0X000214 // float32
    m_bDuckOverride = 0X000218 // bool
    m_flDuckOffset = 0X00021C // float32
    m_nDuckTimeMsecs = 0X000220 // uint32
    m_nDuckJumpTimeMsecs = 0X000224 // uint32
    m_nJumpTimeMsecs = 0X000228 // uint32
    m_flLastDuckTime = 0X00022C // float32
    m_vecLastPositionAtFullCrouchSpeed = 0X000238 // Vector2D
    m_duckUntilOnGround = 0X000240 // bool
    m_bHasWalkMovedSinceLastJump = 0X000241 // bool
    m_bInStuckTest = 0X000242 // bool
    m_CachedGetPointContents = 0X000248 // uint64[64][3]
    m_CachedGetPointContentsPoint = 0X000848 // Vector[64][3]
    m_flStuckCheckTime = 0X001150 // float32[64][2]
    m_nTraceCount = 0X001350 // int32
    m_StuckLast = 0X001354 // int32
    m_bSpeedCropped = 0X001358 // bool
    m_nOldWaterLevel = 0X00135C // int32
    m_flWaterEntryTime = 0X001360 // float32
    m_vecForward = 0X001364 // Vector
    m_vecLeft = 0X001370 // Vector
    m_vecUp = 0X00137C // Vector
    m_vecPreviouslyPredictedOrigin = 0X001388 // Vector
    m_bOldJumpPressed = 0X001394 // bool
    m_flJumpUntil = 0X001398 // float32
    m_flJumpVel = 0X00139C // float32
    m_fStashGrenadeParameterWhen = 0X0013A0 // GameTime_t
    m_bUpdatePredictedOriginAfterDataUpdate = 0X0013A4 // bool

 CCSPlayer_ObserverServices: [client.dll]
    m_hLastObserverTarget = 0X000058 // CEntityHandle
    m_vecObserverInterpolateOffset = 0X00005C // Vector
    m_vecObserverInterpStartPos = 0X000068 // Vector
    m_flObsInterp_PathLength = 0X000074 // float32
    m_qObsInterp_OrientationStart = 0X000080 // Quaternion
    m_qObsInterp_OrientationTravelDir = 0X000090 // Quaternion
    m_obsInterpState = 0X0000A0 // ObserverInterpState_t
    m_bObserverInterpolationNeedsDeferredSetup = 0X0000A4 // bool
    m_nLastKillerDamageTaken = 0X0000A8 // int32
    m_nLastKillerHitsTaken = 0X0000AC // int32
    m_nLastKillerDamageGiven = 0X0000B0 // int32
    m_nLastKillerHitsGiven = 0X0000B4 // int32
    m_nLastKillerActualDamageGiven = 0X0000B8 // int32
    m_nLastKillerActualDamageTaken = 0X0000BC // int32
    m_bCanShowDeathPanelNow = 0X0000C0 // bool
    m_bWasShowingDeathPanel = 0X0000C1 // bool

 CCSPlayer_UseServices: [client.dll]
    No schemes available

 CCSPlayer_ViewModelServices: [client.dll]
    m_hViewModel = 0X000040 // CHandle< C_BaseViewModel >[3]

 CCSPlayer_WaterServices: [client.dll]
    m_flWaterJumpTime = 0X000040 // float32
    m_vecWaterJumpVel = 0X000044 // Vector
    m_flSwimSoundTime = 0X000050 // float32

 CCSPlayer_WeaponServices: [client.dll]
    m_flNextAttack = 0X0000A8 // GameTime_t
    m_bIsLookingAtWeapon = 0X0000AC // bool
    m_bIsHoldingLookAtWeapon = 0X0000AD // bool

 CCSPlayerController_ActionTrackingServices: [client.dll]
    m_perRoundStats = 0X000040 // C_UtlVectorEmbeddedNetworkVar< CSPerRoundStats_t >
    m_matchStats = 0X000090 // CSMatchStats_t
    m_iNumRoundKills = 0X000108 // int32
    m_iNumRoundKillsHeadshots = 0X00010C // int32

 CDamageRecord: [client.dll]
    m_PlayerDamager = 0X000028 // CHandle< C_CSPlayerPawnBase >
    m_PlayerRecipient = 0X00002C // CHandle< C_CSPlayerPawnBase >
    m_hPlayerControllerDamager = 0X000030 // CHandle< CCSPlayerController >
    m_hPlayerControllerRecipient = 0X000034 // CHandle< CCSPlayerController >
    m_szPlayerDamagerName = 0X000038 // CUtlString
    m_szPlayerRecipientName = 0X000040 // CUtlString
    m_DamagerXuid = 0X000048 // uint64
    m_RecipientXuid = 0X000050 // uint64
    m_iDamage = 0X000058 // int32
    m_iActualHealthRemoved = 0X00005C // int32
    m_iNumHits = 0X000060 // int32
    m_iLastBulletUpdate = 0X000064 // int32
    m_bIsOtherEnemy = 0X000068 // bool
    m_killType = 0X000069 // EKillTypes_t

 CCSPlayerController_DamageServices: [client.dll]
    m_nSendUpdate = 0X000040 // int32
    m_nCachedSendUpdate = 0X000044 // int32
    m_DamageList = 0X000048 // C_UtlVectorEmbeddedNetworkVar< CDamageRecord >

 CCSPlayerController_InGameMoneyServices: [client.dll]
    m_iAccount = 0X000040 // int32
    m_iStartAccount = 0X000044 // int32
    m_iTotalCashSpent = 0X000048 // int32
    m_iCashSpentThisRound = 0X00004C // int32
    m_nPreviousAccount = 0X000050 // int32

 CCSPlayerController_InventoryServices: [client.dll]
    m_unMusicID = 0X000040 // uint16
    m_rank = 0X000044 // MedalRank_t[6]
    m_nPersonaDataPublicLevel = 0X00005C // int32
    m_nPersonaDataPublicCommendsLeader = 0X000060 // int32
    m_nPersonaDataPublicCommendsTeacher = 0X000064 // int32
    m_nPersonaDataPublicCommendsFriendly = 0X000068 // int32
    m_vecTerroristLoadoutCache = 0X000070 // C_UtlVectorEmbeddedNetworkVar< C_EconItemView >
    m_vecCounterTerroristLoadoutCache = 0X0000C0 // C_UtlVectorEmbeddedNetworkVar< C_EconItemView >

 C_SurvivalGameRules: [client.dll]
    m_vecPlayAreaMins = 0X000008 // Vector
    m_vecPlayAreaMaxs = 0X000014 // Vector
    m_iPlayerSpawnHexIndices = 0X000020 // int32[64]
    m_SpawnTileState = 0X000120 // ESurvivalSpawnTileState[224]
    m_flSpawnSelectionTimeStartCurrentStage = 0X000200 // float32
    m_flSpawnSelectionTimeEndCurrentStage = 0X000204 // float32
    m_flSpawnSelectionTimeEndLastStage = 0X000208 // float32
    m_spawnStage = 0X00020C // SpawnStage_t
    m_flTabletHexOriginX = 0X000210 // float32
    m_flTabletHexOriginY = 0X000214 // float32
    m_flTabletHexSize = 0X000218 // float32
    m_roundData_playerXuids = 0X000220 // uint64[64]
    m_roundData_playerPositions = 0X000420 // int32[64]
    m_roundData_playerTeams = 0X000520 // int32[64]
    m_SurvivalGameRuleDecisionTypes = 0X000620 // ESurvivalGameRuleDecision_t[16]
    m_SurvivalGameRuleDecisionValues = 0X000660 // int32[16]
    m_flSurvivalStartTime = 0X0006A0 // float32
    m_flLastThinkTime = 0X0006A4 // float32

 C_DangerZone: [client.dll]
    m_vecDangerZoneOriginStartedAt = 0X000538 // Vector
    m_flBombLaunchTime = 0X000544 // GameTime_t
    m_flExtraRadius = 0X000548 // float32
    m_flExtraRadiusStartTime = 0X00054C // GameTime_t
    m_flExtraRadiusTotalLerpTime = 0X000550 // float32
    m_nDropOrder = 0X000554 // int32
    m_iWave = 0X000558 // int32

 C_DangerZoneController: [client.dll]
    m_bDangerZoneControllerEnabled = 0X000538 // bool
    m_bMissionControlledExplosions = 0X000539 // bool
    m_vecEndGameCircleStart = 0X00053C // Vector
    m_vecEndGameCircleEnd = 0X000548 // Vector
    m_flStartTime = 0X000554 // GameTime_t
    m_flFinalExpansionTime = 0X000558 // float32
    m_DangerZones = 0X00055C // CHandle< C_DangerZone >[42]
    m_flWaveEndTimes = 0X000604 // GameTime_t[5]
    m_hTheFinalZone = 0X000618 // CHandle< C_DangerZone >

 C_GrassBurn: [client.dll]
    m_flGrassBurnClearTime = 0X000538 // float32
    m_bClientPendingClear = 0X00053C // float32
    m_flGrassBurnClearTimeLocal = 0X000540 // float32
    m_vecGrassBurnPositions = 0X000548 // CUtlVector< Vector >

 C_IronSightController: [client.dll]
    m_bIronSightAvailable = 0X000010 // bool
    m_flIronSightAmount = 0X000014 // float32
    m_flIronSightAmountGained = 0X000018 // float32
    m_flIronSightAmountBiased = 0X00001C // float32
    m_flIronSightAmount_Interpolated = 0X000020 // float32
    m_flIronSightAmountGained_Interpolated = 0X000024 // float32
    m_flIronSightAmountBiased_Interpolated = 0X000028 // float32
    m_flInterpolationLastUpdated = 0X00002C // float32
    m_angDeltaAverage = 0X000030 // QAngle[8]
    m_angViewLast = 0X000090 // QAngle
    m_vecDotCoords = 0X00009C // Vector2D
    m_flDotBlur = 0X0000A4 // float32
    m_flSpeedRatio = 0X0000A8 // float32

 CompositeMaterialMatchFilter_t: [client.dll]
    m_nCompositeMaterialMatchFilterType = 0X000000 // CompositeMaterialMatchFilterType_t
    m_strMatchFilter = 0X000008 // CUtlString
    m_strMatchValue = 0X000010 // CUtlString
    m_bPassWhenTrue = 0X000018 // bool

 CompositeMaterialInputLooseVariable_t: [client.dll]
    m_strName = 0X000000 // CUtlString
    m_bExposeExternally = 0X000008 // bool
    m_strExposedFriendlyName = 0X000010 // CUtlString
    m_strExposedFriendlyGroupName = 0X000018 // CUtlString
    m_nVariableType = 0X000020 // CompositeMaterialInputLooseVariableType_t
    m_bValueBoolean = 0X000024 // bool
    m_nValueIntX = 0X000028 // int32
    m_nValueIntY = 0X00002C // int32
    m_nValueIntZ = 0X000030 // int32
    m_nValueIntW = 0X000034 // int32
    m_bHasFloatBounds = 0X000038 // bool
    m_flValueFloatX = 0X00003C // float32
    m_flValueFloatX_Min = 0X000040 // float32
    m_flValueFloatX_Max = 0X000044 // float32
    m_flValueFloatY = 0X000048 // float32
    m_flValueFloatY_Min = 0X00004C // float32
    m_flValueFloatY_Max = 0X000050 // float32
    m_flValueFloatZ = 0X000054 // float32
    m_flValueFloatZ_Min = 0X000058 // float32
    m_flValueFloatZ_Max = 0X00005C // float32
    m_flValueFloatW = 0X000060 // float32
    m_flValueFloatW_Min = 0X000064 // float32
    m_flValueFloatW_Max = 0X000068 // float32
    m_cValueColor4 = 0X00006C // Color
    m_nValueSystemVar = 0X000070 // CompositeMaterialVarSystemVar_t
    m_strResourceMaterial = 0X000078 // CResourceName
    m_strTextureContentAssetPath = 0X000158 // CUtlString
    m_strTextureRuntimeResourcePath = 0X000160 // CResourceName
    m_strTextureCompilationVtexTemplate = 0X000240 // CUtlString
    m_nTextureType = 0X000248 // CompositeMaterialInputTextureType_t
    m_strString = 0X000250 // CUtlString

 CompMatMutatorCondition_t: [client.dll]
    m_nMutatorCondition = 0X000000 // CompMatPropertyMutatorConditionType_t
    m_strMutatorConditionContainerName = 0X000008 // CUtlString
    m_strMutatorConditionContainerVarName = 0X000010 // CUtlString
    m_strMutatorConditionContainerVarValue = 0X000018 // CUtlString
    m_bPassWhenTrue = 0X000020 // bool

 CompMatPropertyMutator_t: [client.dll]
    m_bEnabled = 0X000000 // bool
    m_nMutatorCommandType = 0X000004 // CompMatPropertyMutatorType_t
    m_strInitWith_Container = 0X000008 // CUtlString
    m_strCopyProperty_InputContainerSrc = 0X000010 // CUtlString
    m_strCopyProperty_InputContainerProperty = 0X000018 // CUtlString
    m_strCopyProperty_TargetProperty = 0X000020 // CUtlString
    m_strRandomRollInputVars_SeedInputVar = 0X000028 // CUtlString
    m_vecRandomRollInputVars_InputVarsToRoll = 0X000030 // CUtlVector< CUtlString >
    m_strCopyMatchingKeys_InputContainerSrc = 0X000048 // CUtlString
    m_strCopyKeysWithSuffix_InputContainerSrc = 0X000050 // CUtlString
    m_strCopyKeysWithSuffix_FindSuffix = 0X000058 // CUtlString
    m_strCopyKeysWithSuffix_ReplaceSuffix = 0X000060 // CUtlString
    m_nSetValue_Value = 0X000068 // CompositeMaterialInputLooseVariable_t
    m_strGenerateTexture_TargetParam = 0X0002C0 // CUtlString
    m_strGenerateTexture_InitialContainer = 0X0002C8 // CUtlString
    m_nResolution = 0X0002D0 // int32
    m_bSplatDebugInfo = 0X0002D4 // bool
    m_bCaptureInRenderDoc = 0X0002D5 // bool
    m_vecTexGenInstructions = 0X0002D8 // CUtlVector< CompMatPropertyMutator_t >
    m_vecConditionalMutators = 0X0002F0 // CUtlVector< CompMatPropertyMutator_t >
    m_strPopInputQueue_Container = 0X000308 // CUtlString
    m_strDrawText_InputContainerSrc = 0X000310 // CUtlString
    m_strDrawText_InputContainerProperty = 0X000318 // CUtlString
    m_vecDrawText_Position = 0X000320 // Vector2D
    m_vecConditions = 0X000328 // CUtlVector< CompMatMutatorCondition_t >

 CompositeMaterialInputContainer_t: [client.dll]
    m_bEnabled = 0X000000 // bool
    m_nCompositeMaterialInputContainerSourceType = 0X000004 // CompositeMaterialInputContainerSourceType_t
    m_strSpecificContainerMaterial = 0X000008 // CResourceName
    m_strAttrName = 0X0000E8 // CUtlString
    m_strAlias = 0X0000F0 // CUtlString
    m_vecLooseVariables = 0X0000F8 // CUtlVector< CompositeMaterialInputLooseVariable_t >
    m_strAttrNameForVar = 0X000110 // CUtlString
    m_bExposeExternally = 0X000118 // bool

 CompositeMaterialAssemblyProcedure_t: [client.dll]
    m_vecCompMatIncludes = 0X000000 // CUtlVector< CResourceName >
    m_vecMatchFilters = 0X000018 // CUtlVector< CompositeMaterialMatchFilter_t >
    m_vecCompositeInputContainers = 0X000030 // CUtlVector< CompositeMaterialInputContainer_t >
    m_vecPropertyMutators = 0X000048 // CUtlVector< CompMatPropertyMutator_t >

 GeneratedTextureHandle_t: [client.dll]
    m_strBitmapName = 0X000008 // CUtlString

 CompositeMaterial_t: [client.dll]
    m_TargetKVs = 0X000008 // KeyValues3
    m_PreGenerationKVs = 0X000018 // KeyValues3
    m_FinalKVs = 0X000028 // KeyValues3
    m_vecGeneratedTextures = 0X000040 // CUtlVector< GeneratedTextureHandle_t >

 CompositeMaterialEditorPoint_t: [client.dll]
    m_ModelName = 0X000000 // CResourceName
    m_nSequenceIndex = 0X0000E0 // int32
    m_flCycle = 0X0000E4 // float32
    m_KVModelStateChoices = 0X0000E8 // KeyValues3
    m_bEnableChildModel = 0X0000F8 // bool
    m_ChildModelName = 0X000100 // CResourceName
    m_vecCompositeMaterialAssemblyProcedures = 0X0001E0 // CUtlVector< CompositeMaterialAssemblyProcedure_t >
    m_vecCompositeMaterials = 0X0001F8 // CUtlVector< CompositeMaterial_t >

 CCompositeMaterialEditorDoc: [client.dll]
    m_nVersion = 0X000008 // int32
    m_Points = 0X000010 // CUtlVector< CompositeMaterialEditorPoint_t >
    m_KVthumbnail = 0X000028 // KeyValues3

 CGlobalLightBase: [client.dll]
    m_bSpotLight = 0X000010 // bool
    m_SpotLightOrigin = 0X000014 // Vector
    m_SpotLightAngles = 0X000020 // QAngle
    m_ShadowDirection = 0X00002C // Vector
    m_AmbientDirection = 0X000038 // Vector
    m_SpecularDirection = 0X000044 // Vector
    m_InspectorSpecularDirection = 0X000050 // Vector
    m_flSpecularPower = 0X00005C // float32
    m_flSpecularIndependence = 0X000060 // float32
    m_SpecularColor = 0X000064 // Color
    m_bStartDisabled = 0X000068 // bool
    m_bEnabled = 0X000069 // bool
    m_LightColor = 0X00006A // Color
    m_AmbientColor1 = 0X00006E // Color
    m_AmbientColor2 = 0X000072 // Color
    m_AmbientColor3 = 0X000076 // Color
    m_flSunDistance = 0X00007C // float32
    m_flFOV = 0X000080 // float32
    m_flNearZ = 0X000084 // float32
    m_flFarZ = 0X000088 // float32
    m_bEnableShadows = 0X00008C // bool
    m_bOldEnableShadows = 0X00008D // bool
    m_bBackgroundClearNotRequired = 0X00008E // bool
    m_flCloudScale = 0X000090 // float32
    m_flCloud1Speed = 0X000094 // float32
    m_flCloud1Direction = 0X000098 // float32
    m_flCloud2Speed = 0X00009C // float32
    m_flCloud2Direction = 0X0000A0 // float32
    m_flAmbientScale1 = 0X0000A4 // float32
    m_flAmbientScale2 = 0X0000A8 // float32
    m_flGroundScale = 0X0000AC // float32
    m_flLightScale = 0X0000B0 // float32
    m_flFoWDarkness = 0X0000B4 // float32
    m_bEnableSeparateSkyboxFog = 0X0000B8 // bool
    m_vFowColor = 0X0000BC // Vector
    m_ViewOrigin = 0X0000C8 // Vector
    m_ViewAngles = 0X0000D4 // QAngle
    m_flViewFoV = 0X0000E0 // float32
    m_WorldPoints = 0X0000E4 // Vector[8]
    m_vFogOffsetLayer0 = 0X0004A8 // Vector2D
    m_vFogOffsetLayer1 = 0X0004B0 // Vector2D
    m_hEnvWind = 0X0004B8 // CHandle< C_BaseEntity >
    m_hEnvSky = 0X0004BC // CHandle< C_BaseEntity >

 C_GlobalLight: [client.dll]
    m_WindClothForceHandle = 0X000A00 // uint16

 C_CSGO_MapPreviewCameraPathNode: [client.dll]
    m_szParentPathUniqueID = 0X000538 // CUtlSymbolLarge
    m_nPathIndex = 0X000540 // int32
    m_vInTangentLocal = 0X000544 // Vector
    m_vOutTangentLocal = 0X000550 // Vector
    m_flFOV = 0X00055C // float32
    m_flSpeed = 0X000560 // float32
    m_flEaseIn = 0X000564 // float32
    m_flEaseOut = 0X000568 // float32
    m_vInTangentWorld = 0X00056C // Vector
    m_vOutTangentWorld = 0X000578 // Vector

 C_CSGO_MapPreviewCameraPath: [client.dll]
    m_flZFar = 0X000538 // float32
    m_flZNear = 0X00053C // float32
    m_bLoop = 0X000540 // bool
    m_bVerticalFOV = 0X000541 // bool
    m_bConstantSpeed = 0X000542 // bool
    m_flDuration = 0X000544 // float32
    m_flPathLength = 0X000588 // float32
    m_flPathDuration = 0X00058C // float32

 CCSPlayer_GlowServices: [client.dll]
    No schemes available

 C_VoteController: [client.dll]
    m_iActiveIssueIndex = 0X000548 // int32
    m_iOnlyTeamToVote = 0X00054C // int32
    m_nVoteOptionCount = 0X000550 // int32[5]
    m_nPotentialVotes = 0X000564 // int32
    m_bVotesDirty = 0X000568 // bool
    m_bTypeDirty = 0X000569 // bool
    m_bIsYesNoVote = 0X00056A // bool

 C_MapVetoPickController: [client.dll]
    m_nDraftType = 0X000548 // int32
    m_nTeamWinningCoinToss = 0X00054C // int32
    m_nTeamWithFirstChoice = 0X000550 // int32[64]
    m_nVoteMapIdsList = 0X000650 // int32[7]
    m_nAccountIDs = 0X00066C // int32[64]
    m_nMapId0 = 0X00076C // int32[64]
    m_nMapId1 = 0X00086C // int32[64]
    m_nMapId2 = 0X00096C // int32[64]
    m_nMapId3 = 0X000A6C // int32[64]
    m_nMapId4 = 0X000B6C // int32[64]
    m_nMapId5 = 0X000C6C // int32[64]
    m_nStartingSide0 = 0X000D6C // int32[64]
    m_nCurrentPhase = 0X000E6C // int32
    m_nPhaseStartTick = 0X000E70 // int32
    m_nPhaseDurationTicks = 0X000E74 // int32
    m_nPostDataUpdateTick = 0X000E78 // int32
    m_bDisabledHud = 0X000E7C // bool

 CPlayerSprayDecalRenderHelper: [client.dll]
    No schemes available

 C_CSGO_TeamPreviewCamera: [client.dll]
    m_bDofEnabled = 0X000598 // bool
    m_flDofNearBlurry = 0X00059C // float32
    m_flDofNearCrisp = 0X0005A0 // float32
    m_flDofFarCrisp = 0X0005A4 // float32
    m_flDofFarBlurry = 0X0005A8 // float32
    m_flDofTiltToGround = 0X0005AC // float32

 C_CSGO_TeamSelectCamera: [client.dll]
    No schemes available

 C_CSGO_TerroristTeamIntroCamera: [client.dll]
    No schemes available

 C_CSGO_CounterTerroristTeamIntroCamera: [client.dll]
    No schemes available

 C_CSGO_EndOfMatchCamera: [client.dll]
    No schemes available

 C_CSGO_EndOfMatchCharacterPosition: [client.dll]
    No schemes available

 C_CSGO_EndOfMatchLineupEndpoint: [client.dll]
    No schemes available

 C_CSGO_EndOfMatchLineupStart: [client.dll]
    No schemes available

 C_CSGO_EndOfMatchLineupEnd: [client.dll]
    No schemes available

 C_InfoMapRegion: [client.dll]
    m_flRadius = 0X000538 // float32
    m_szLocToken = 0X00053C // char[128]
    m_pNext = 0X0005C0 // C_InfoMapRegion*

 C_PointEntity: [client.dll]
    No schemes available

 C_EnvCombinedLightProbeVolume: [client.dll]
    m_Color = 0X001608 // Color
    m_flBrightness = 0X00160C // float32
    m_hCubemapTexture = 0X001610 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_bCustomCubemapTexture = 0X001618 // bool
    m_hLightProbeTexture = 0X001620 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightIndicesTexture = 0X001628 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightScalarsTexture = 0X001630 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightShadowsTexture = 0X001638 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_vBoxMins = 0X001640 // Vector
    m_vBoxMaxs = 0X00164C // Vector
    m_LightGroups = 0X001658 // CUtlSymbolLarge
    m_bMoveable = 0X001660 // bool
    m_nHandshake = 0X001664 // int32
    m_nEnvCubeMapArrayIndex = 0X001668 // int32
    m_nPriority = 0X00166C // int32
    m_bStartDisabled = 0X001670 // bool
    m_flEdgeFadeDist = 0X001674 // float32
    m_vEdgeFadeDists = 0X001678 // Vector
    m_nLightProbeSizeX = 0X001684 // int32
    m_nLightProbeSizeY = 0X001688 // int32
    m_nLightProbeSizeZ = 0X00168C // int32
    m_nLightProbeAtlasX = 0X001690 // int32
    m_nLightProbeAtlasY = 0X001694 // int32
    m_nLightProbeAtlasZ = 0X001698 // int32
    m_bEnabled = 0X0016B1 // bool

 C_EnvCubemap: [client.dll]
    m_hCubemapTexture = 0X000628 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_bCustomCubemapTexture = 0X000630 // bool
    m_flInfluenceRadius = 0X000634 // float32
    m_vBoxProjectMins = 0X000638 // Vector
    m_vBoxProjectMaxs = 0X000644 // Vector
    m_LightGroups = 0X000650 // CUtlSymbolLarge
    m_bMoveable = 0X000658 // bool
    m_nHandshake = 0X00065C // int32
    m_nEnvCubeMapArrayIndex = 0X000660 // int32
    m_nPriority = 0X000664 // int32
    m_flEdgeFadeDist = 0X000668 // float32
    m_vEdgeFadeDists = 0X00066C // Vector
    m_flDiffuseScale = 0X000678 // float32
    m_bStartDisabled = 0X00067C // bool
    m_bDefaultEnvMap = 0X00067D // bool
    m_bDefaultSpecEnvMap = 0X00067E // bool
    m_bIndoorCubeMap = 0X00067F // bool
    m_bCopyDiffuseFromDefaultCubemap = 0X000680 // bool
    m_bEnabled = 0X000690 // bool

 C_EnvCubemapBox: [client.dll]
    No schemes available

 C_EnvCubemapFog: [client.dll]
    m_flEndDistance = 0X000538 // float32
    m_flStartDistance = 0X00053C // float32
    m_flFogFalloffExponent = 0X000540 // float32
    m_bHeightFogEnabled = 0X000544 // bool
    m_flFogHeightWidth = 0X000548 // float32
    m_flFogHeightEnd = 0X00054C // float32
    m_flFogHeightStart = 0X000550 // float32
    m_flFogHeightExponent = 0X000554 // float32
    m_flLODBias = 0X000558 // float32
    m_bActive = 0X00055C // bool
    m_bStartDisabled = 0X00055D // bool
    m_flFogMaxOpacity = 0X000560 // float32
    m_nCubemapSourceType = 0X000564 // int32
    m_hSkyMaterial = 0X000568 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_iszSkyEntity = 0X000570 // CUtlSymbolLarge
    m_hFogCubemapTexture = 0X000578 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_bHasHeightFogEnd = 0X000580 // bool
    m_bFirstTime = 0X000581 // bool

 C_GradientFog: [client.dll]
    m_hGradientFogTexture = 0X000538 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_flFogStartDistance = 0X000540 // float32
    m_flFogEndDistance = 0X000544 // float32
    m_bHeightFogEnabled = 0X000548 // bool
    m_flFogStartHeight = 0X00054C // float32
    m_flFogEndHeight = 0X000550 // float32
    m_flFarZ = 0X000554 // float32
    m_flFogMaxOpacity = 0X000558 // float32
    m_flFogFalloffExponent = 0X00055C // float32
    m_flFogVerticalExponent = 0X000560 // float32
    m_fogColor = 0X000564 // Color
    m_flFogStrength = 0X000568 // float32
    m_flFadeTime = 0X00056C // float32
    m_bStartDisabled = 0X000570 // bool
    m_bIsEnabled = 0X000571 // bool
    m_bGradientFogNeedsTextures = 0X000572 // bool

 C_EnvLightProbeVolume: [client.dll]
    m_hLightProbeTexture = 0X001518 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightIndicesTexture = 0X001520 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightScalarsTexture = 0X001528 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hLightProbeDirectLightShadowsTexture = 0X001530 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_vBoxMins = 0X001538 // Vector
    m_vBoxMaxs = 0X001544 // Vector
    m_LightGroups = 0X001550 // CUtlSymbolLarge
    m_bMoveable = 0X001558 // bool
    m_nHandshake = 0X00155C // int32
    m_nPriority = 0X001560 // int32
    m_bStartDisabled = 0X001564 // bool
    m_nLightProbeSizeX = 0X001568 // int32
    m_nLightProbeSizeY = 0X00156C // int32
    m_nLightProbeSizeZ = 0X001570 // int32
    m_nLightProbeAtlasX = 0X001574 // int32
    m_nLightProbeAtlasY = 0X001578 // int32
    m_nLightProbeAtlasZ = 0X00157C // int32
    m_bEnabled = 0X001589 // bool

 C_TonemapController2: [client.dll]
    m_flAutoExposureMin = 0X000538 // float32
    m_flAutoExposureMax = 0X00053C // float32
    m_flTonemapPercentTarget = 0X000540 // float32
    m_flTonemapPercentBrightPixels = 0X000544 // float32
    m_flTonemapMinAvgLum = 0X000548 // float32
    m_flExposureAdaptationSpeedUp = 0X00054C // float32
    m_flExposureAdaptationSpeedDown = 0X000550 // float32
    m_flTonemapEVSmoothingRange = 0X000554 // float32

 C_EnvVolumetricFogController: [client.dll]
    m_flScattering = 0X000538 // float32
    m_flAnisotropy = 0X00053C // float32
    m_flFadeSpeed = 0X000540 // float32
    m_flDrawDistance = 0X000544 // float32
    m_flFadeInStart = 0X000548 // float32
    m_flFadeInEnd = 0X00054C // float32
    m_flIndirectStrength = 0X000550 // float32
    m_nIndirectTextureDimX = 0X000554 // int32
    m_nIndirectTextureDimY = 0X000558 // int32
    m_nIndirectTextureDimZ = 0X00055C // int32
    m_vBoxMins = 0X000560 // Vector
    m_vBoxMaxs = 0X00056C // Vector
    m_bActive = 0X000578 // bool
    m_flStartAnisoTime = 0X00057C // GameTime_t
    m_flStartScatterTime = 0X000580 // GameTime_t
    m_flStartDrawDistanceTime = 0X000584 // GameTime_t
    m_flStartAnisotropy = 0X000588 // float32
    m_flStartScattering = 0X00058C // float32
    m_flStartDrawDistance = 0X000590 // float32
    m_flDefaultAnisotropy = 0X000594 // float32
    m_flDefaultScattering = 0X000598 // float32
    m_flDefaultDrawDistance = 0X00059C // float32
    m_bStartDisabled = 0X0005A0 // bool
    m_bEnableIndirect = 0X0005A1 // bool
    m_bIsMaster = 0X0005A2 // bool
    m_hFogIndirectTexture = 0X0005A8 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_nForceRefreshCount = 0X0005B0 // int32
    m_bFirstTime = 0X0005B4 // bool

 C_EnvVolumetricFogVolume: [client.dll]
    m_bActive = 0X000538 // bool
    m_vBoxMins = 0X00053C // Vector
    m_vBoxMaxs = 0X000548 // Vector
    m_bStartDisabled = 0X000554 // bool
    m_flStrength = 0X000558 // float32
    m_nFalloffShape = 0X00055C // int32
    m_flFalloffExponent = 0X000560 // float32

 C_FogController: [client.dll]
    m_fog = 0X000538 // fogparams_t
    m_bUseAngles = 0X0005A0 // bool
    m_iChangedVariables = 0X0005A4 // int32

 CInfoTarget: [client.dll]
    No schemes available

 CInfoParticleTarget: [client.dll]
    No schemes available

 C_InfoVisibilityBox: [client.dll]
    m_nMode = 0X00053C // int32
    m_vBoxSize = 0X000540 // Vector
    m_bEnabled = 0X00054C // bool

 CInfoWorldLayer: [client.dll]
    m_pOutputOnEntitiesSpawned = 0X000538 // CEntityIOOutput
    m_worldName = 0X000560 // CUtlSymbolLarge
    m_layerName = 0X000568 // CUtlSymbolLarge
    m_bWorldLayerVisible = 0X000570 // bool
    m_bEntitiesSpawned = 0X000571 // bool
    m_bCreateAsChildSpawnGroup = 0X000572 // bool
    m_hLayerSpawnGroup = 0X000574 // uint32
    m_bWorldLayerActuallyVisible = 0X000578 // bool

 C_PointCamera: [client.dll]
    m_FOV = 0X000538 // float32
    m_Resolution = 0X00053C // float32
    m_bFogEnable = 0X000540 // bool
    m_FogColor = 0X000541 // Color
    m_flFogStart = 0X000548 // float32
    m_flFogEnd = 0X00054C // float32
    m_flFogMaxDensity = 0X000550 // float32
    m_bActive = 0X000554 // bool
    m_bUseScreenAspectRatio = 0X000555 // bool
    m_flAspectRatio = 0X000558 // float32
    m_bNoSky = 0X00055C // bool
    m_fBrightness = 0X000560 // float32
    m_flZFar = 0X000564 // float32
    m_flZNear = 0X000568 // float32
    m_bDofEnabled = 0X00056C // bool
    m_flDofNearBlurry = 0X000570 // float32
    m_flDofNearCrisp = 0X000574 // float32
    m_flDofFarCrisp = 0X000578 // float32
    m_flDofFarBlurry = 0X00057C // float32
    m_flDofTiltToGround = 0X000580 // float32
    m_TargetFOV = 0X000584 // float32
    m_DegreesPerSecond = 0X000588 // float32
    m_bIsOn = 0X00058C // bool
    m_pNext = 0X000590 // C_PointCamera*

 C_PointCameraVFOV: [client.dll]
    m_flVerticalFOV = 0X000598 // float32

 CPointTemplate: [client.dll]
    m_iszWorldName = 0X000538 // CUtlSymbolLarge
    m_iszSource2EntityLumpName = 0X000540 // CUtlSymbolLarge
    m_iszEntityFilterName = 0X000548 // CUtlSymbolLarge
    m_flTimeoutInterval = 0X000550 // float32
    m_bAsynchronouslySpawnEntities = 0X000554 // bool
    m_pOutputOnSpawned = 0X000558 // CEntityIOOutput
    m_clientOnlyEntityBehavior = 0X000580 // PointTemplateClientOnlyEntityBehavior_t
    m_ownerSpawnGroupType = 0X000584 // PointTemplateOwnerSpawnGroupType_t
    m_createdSpawnGroupHandles = 0X000588 // CUtlVector< uint32 >
    m_SpawnedEntityHandles = 0X0005A0 // CUtlVector< CEntityHandle >
    m_ScriptSpawnCallback = 0X0005B8 // HSCRIPT
    m_ScriptCallbackScope = 0X0005C0 // HSCRIPT

 C_SoundAreaEntityBase: [client.dll]
    m_bDisabled = 0X000538 // bool
    m_bWasEnabled = 0X000540 // bool
    m_iszSoundAreaType = 0X000548 // CUtlSymbolLarge
    m_vPos = 0X000550 // Vector

 C_SoundAreaEntitySphere: [client.dll]
    m_flRadius = 0X000560 // float32

 C_SoundAreaEntityOrientedBox: [client.dll]
    m_vMin = 0X000560 // Vector
    m_vMax = 0X00056C // Vector

 C_Team: [client.dll]
    m_aPlayerControllers = 0X000538 // C_NetworkUtlVectorBase< CHandle< CBasePlayerController > >
    m_aPlayers = 0X000550 // C_NetworkUtlVectorBase< CHandle< C_BasePlayerPawn > >
    m_iScore = 0X000568 // int32
    m_szTeamname = 0X00056C // char[129]

 CBasePlayerController: [client.dll]
    m_nFinalPredictedTick = 0X000540 // int32
    m_CommandContext = 0X000548 // C_CommandContext
    m_nInButtonsWhichAreToggles = 0X0005C8 // uint64
    m_nTickBase = 0X0005D0 // uint32
    m_hPawn = 0X0005D4 // CHandle< C_BasePlayerPawn >
    m_hPredictedPawn = 0X0005D8 // CHandle< C_BasePlayerPawn >
    m_nSplitScreenSlot = 0X0005DC // CSplitScreenSlot
    m_hSplitOwner = 0X0005E0 // CHandle< CBasePlayerController >
    m_hSplitScreenPlayers = 0X0005E8 // CUtlVector< CHandle< CBasePlayerController > >
    m_bIsHLTV = 0X000600 // bool
    m_iConnected = 0X000604 // PlayerConnectedState
    m_iszPlayerName = 0X000608 // char[128]
    m_steamID = 0X000690 // uint64
    m_bIsLocalPlayerController = 0X000698 // bool
    m_iDesiredFOV = 0X00069C // uint32

 CBasePlayerVData: [client.dll]
    m_sModelName = 0X000028 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_flHeadDamageMultiplier = 0X000108 // CSkillFloat
    m_flChestDamageMultiplier = 0X000118 // CSkillFloat
    m_flStomachDamageMultiplier = 0X000128 // CSkillFloat
    m_flArmDamageMultiplier = 0X000138 // CSkillFloat
    m_flLegDamageMultiplier = 0X000148 // CSkillFloat
    m_flHoldBreathTime = 0X000158 // float32
    m_flDrowningDamageInterval = 0X00015C // float32
    m_nDrowningDamageInitial = 0X000160 // int32
    m_nDrowningDamageMax = 0X000164 // int32
    m_nWaterSpeed = 0X000168 // int32
    m_flUseRange = 0X00016C // float32
    m_flUseAngleTolerance = 0X000170 // float32
    m_flCrouchTime = 0X000174 // float32

 CBasePlayerWeaponVData: [client.dll]
    m_szWorldModel = 0X000028 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_bBuiltRightHanded = 0X000108 // bool
    m_bAllowFlipping = 0X000109 // bool
    m_bIsFullAuto = 0X00010A // bool
    m_nNumBullets = 0X00010C // int32
    m_sMuzzleAttachment = 0X000110 // CUtlString
    m_szMuzzleFlashParticle = 0X000118 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szTracerParticle = 0X0001F8 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_iFlags = 0X0002D8 // ItemFlagTypes_t
    m_nPrimaryAmmoType = 0X0002D9 // AmmoIndex_t
    m_nSecondaryAmmoType = 0X0002DA // AmmoIndex_t
    m_iMaxClip1 = 0X0002DC // int32
    m_iMaxClip2 = 0X0002E0 // int32
    m_iDefaultClip1 = 0X0002E4 // int32
    m_iDefaultClip2 = 0X0002E8 // int32
    m_iWeight = 0X0002EC // int32
    m_bAutoSwitchTo = 0X0002F0 // bool
    m_bAutoSwitchFrom = 0X0002F1 // bool
    m_iRumbleEffect = 0X0002F4 // RumbleEffect_t
    m_aShootSounds = 0X0002F8 // CUtlMap< WeaponSound_t, CSoundEventName >
    m_iSlot = 0X000318 // int32
    m_iPosition = 0X00031C // int32

 CBaseAnimGraphController: [client.dll]
    m_baseLayer = 0X000018 // CNetworkedSequenceOperation
    m_animGraphNetworkedVars = 0X000040 // CAnimGraphNetworkedVariables
    m_bSequenceFinished = 0X001180 // bool
    m_flLastEventCycle = 0X001184 // float32
    m_flLastEventAnimTime = 0X001188 // float32
    m_flPlaybackRate = 0X00118C // CNetworkedQuantizedFloat
    m_flPrevAnimTime = 0X001194 // float32
    m_bClientSideAnimation = 0X001198 // bool
    m_bNetworkedAnimationInputsChanged = 0X001199 // bool
    m_nPrevNewSequenceParity = 0X00119A // uint8
    m_nPrevResetEventsParity = 0X00119B // uint8
    m_nNewSequenceParity = 0X00119C // int32
    m_nResetEventsParity = 0X0011A0 // int32
    m_nAnimLoopMode = 0X0011A4 // AnimLoopMode_t
    m_hAnimationUpdate = 0X00123C // AnimationUpdateListHandle_t
    m_hLastAnimEventSequence = 0X001240 // HSequence

 C_BaseModelEntity: [client.dll]
    m_CRenderComponent = 0X000588 // CRenderComponent*
    m_CHitboxComponent = 0X000590 // CHitboxComponent
    m_bInitModelEffects = 0X0005D8 // bool
    m_bIsStaticProp = 0X0005D9 // bool
    m_nLastAddDecal = 0X0005DC // int32
    m_nDecalsAdded = 0X0005E0 // int32
    m_iOldHealth = 0X0005E4 // int32
    m_nRenderMode = 0X0005E8 // RenderMode_t
    m_nRenderFX = 0X0005E9 // RenderFx_t
    m_bAllowFadeInView = 0X0005EA // bool
    m_clrRender = 0X0005EB // Color
    m_vecRenderAttributes = 0X0005F0 // C_UtlVectorEmbeddedNetworkVar< EntityRenderAttribute_t >
    m_LightGroup = 0X000658 // CUtlStringToken
    m_bRenderToCubemaps = 0X00065C // bool
    m_Collision = 0X000660 // CCollisionProperty
    m_Glow = 0X000710 // CGlowProperty
    m_flGlowBackfaceMult = 0X000768 // float32
    m_fadeMinDist = 0X00076C // float32
    m_fadeMaxDist = 0X000770 // float32
    m_flFadeScale = 0X000774 // float32
    m_flShadowStrength = 0X000778 // float32
    m_nObjectCulling = 0X00077C // uint8
    m_nAddDecal = 0X000780 // int32
    m_vDecalPosition = 0X000784 // Vector
    m_vDecalForwardAxis = 0X000790 // Vector
    m_flDecalHealBloodRate = 0X00079C // float32
    m_flDecalHealHeightRate = 0X0007A0 // float32
    m_ConfigEntitiesToPropagateMaterialDecalsTo = 0X0007A8 // C_NetworkUtlVectorBase< CHandle< C_BaseModelEntity > >
    m_vecViewOffset = 0X0007C0 // CNetworkViewOffsetVector
    m_pClientAlphaProperty = 0X0007F0 // CClientAlphaProperty*
    m_ClientOverrideTint = 0X0007F8 // Color
    m_bUseClientOverrideTint = 0X0007FC // bool

 CServerOnlyModelEntity: [client.dll]
    No schemes available

 C_ModelPointEntity: [client.dll]
    No schemes available

 CLogicRelay: [client.dll]
    m_OnTrigger = 0X000538 // CEntityIOOutput
    m_OnSpawn = 0X000560 // CEntityIOOutput
    m_bDisabled = 0X000588 // bool
    m_bWaitForRefire = 0X000589 // bool
    m_bTriggerOnce = 0X00058A // bool
    m_bFastRetrigger = 0X00058B // bool
    m_bPassthoughCaller = 0X00058C // bool

 C_ParticleSystem: [client.dll]
    m_szSnapshotFileName = 0X000838 // char[512]
    m_bActive = 0X000A38 // bool
    m_bFrozen = 0X000A39 // bool
    m_flFreezeTransitionDuration = 0X000A3C // float32
    m_nStopType = 0X000A40 // int32
    m_bAnimateDuringGameplayPause = 0X000A44 // bool
    m_iEffectIndex = 0X000A48 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_flStartTime = 0X000A50 // GameTime_t
    m_flPreSimTime = 0X000A54 // float32
    m_vServerControlPoints = 0X000A58 // Vector[4]
    m_iServerControlPointAssignments = 0X000A88 // uint8[4]
    m_hControlPointEnts = 0X000A8C // CHandle< C_BaseEntity >[64]
    m_bNoSave = 0X000B8C // bool
    m_bNoFreeze = 0X000B8D // bool
    m_bStartActive = 0X000B8E // bool
    m_iszEffectName = 0X000B90 // CUtlSymbolLarge
    m_iszControlPointNames = 0X000B98 // CUtlSymbolLarge[64]
    m_nDataCP = 0X000D98 // int32
    m_vecDataCPValue = 0X000D9C // Vector
    m_nTintCP = 0X000DA8 // int32
    m_clrTint = 0X000DAC // Color
    m_bOldActive = 0X000DD0 // bool
    m_bOldFrozen = 0X000DD1 // bool

 C_PathParticleRope: [client.dll]
    m_bStartActive = 0X000538 // bool
    m_flMaxSimulationTime = 0X00053C // float32
    m_iszEffectName = 0X000540 // CUtlSymbolLarge
    m_PathNodes_Name = 0X000548 // CUtlVector< CUtlSymbolLarge >
    m_flParticleSpacing = 0X000560 // float32
    m_flSlack = 0X000564 // float32
    m_flRadius = 0X000568 // float32
    m_ColorTint = 0X00056C // Color
    m_nEffectState = 0X000570 // int32
    m_iEffectIndex = 0X000578 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_PathNodes_Position = 0X000580 // C_NetworkUtlVectorBase< Vector >
    m_PathNodes_TangentIn = 0X000598 // C_NetworkUtlVectorBase< Vector >
    m_PathNodes_TangentOut = 0X0005B0 // C_NetworkUtlVectorBase< Vector >
    m_PathNodes_Color = 0X0005C8 // C_NetworkUtlVectorBase< Vector >
    m_PathNodes_PinEnabled = 0X0005E0 // C_NetworkUtlVectorBase< bool >
    m_PathNodes_RadiusScale = 0X0005F8 // C_NetworkUtlVectorBase< float32 >

 C_PathParticleRopeAlias_path_particle_rope_clientside: [client.dll]
    No schemes available

 C_DynamicLight: [client.dll]
    m_Flags = 0X000838 // uint8
    m_LightStyle = 0X000839 // uint8
    m_Radius = 0X00083C // float32
    m_Exponent = 0X000840 // int32
    m_InnerAngle = 0X000844 // float32
    m_OuterAngle = 0X000848 // float32
    m_SpotRadius = 0X00084C // float32

 C_EnvScreenOverlay: [client.dll]
    m_iszOverlayNames = 0X000538 // CUtlSymbolLarge[10]
    m_flOverlayTimes = 0X000588 // float32[10]
    m_flStartTime = 0X0005B0 // GameTime_t
    m_iDesiredOverlay = 0X0005B4 // int32
    m_bIsActive = 0X0005B8 // bool
    m_bWasActive = 0X0005B9 // bool
    m_iCachedDesiredOverlay = 0X0005BC // int32
    m_iCurrentOverlay = 0X0005C0 // int32
    m_flCurrentOverlayTime = 0X0005C4 // GameTime_t

 C_FuncTrackTrain: [client.dll]
    m_nLongAxis = 0X000838 // int32
    m_flRadius = 0X00083C // float32
    m_flLineLength = 0X000840 // float32

 C_LightGlowOverlay: [client.dll]
    m_vecOrigin = 0X0000D0 // Vector
    m_vecDirection = 0X0000DC // Vector
    m_nMinDist = 0X0000E8 // int32
    m_nMaxDist = 0X0000EC // int32
    m_nOuterMaxDist = 0X0000F0 // int32
    m_bOneSided = 0X0000F4 // bool
    m_bModulateByDot = 0X0000F5 // bool

 C_LightGlow: [client.dll]
    m_nHorizontalSize = 0X000838 // uint32
    m_nVerticalSize = 0X00083C // uint32
    m_nMinDist = 0X000840 // uint32
    m_nMaxDist = 0X000844 // uint32
    m_nOuterMaxDist = 0X000848 // uint32
    m_flGlowProxySize = 0X00084C // float32
    m_flHDRColorScale = 0X000850 // float32
    m_Glow = 0X000858 // C_LightGlowOverlay

 C_RagdollManager: [client.dll]
    m_iCurrentMaxRagdollCount = 0X000538 // int8

 C_SpotlightEnd: [client.dll]
    m_flLightScale = 0X000838 // float32
    m_Radius = 0X00083C // float32

 C_PointHMDAnchor: [client.dll]
    m_bDisabled = 0X000538 // bool
    m_flEnableTime = 0X00053C // GameTime_t
    m_nPlayerIndex = 0X000540 // int32
    m_nLastSimulateFrame = 0X000544 // int32

 C_PointHMDAnchorOverride: [client.dll]
    No schemes available

 C_PointValueRemapper: [client.dll]
    m_bDisabled = 0X000538 // bool
    m_bDisabledOld = 0X000539 // bool
    m_bUpdateOnClient = 0X00053A // bool
    m_nInputType = 0X00053C // ValueRemapperInputType_t
    m_hRemapLineStart = 0X000540 // CHandle< C_BaseEntity >
    m_hRemapLineEnd = 0X000544 // CHandle< C_BaseEntity >
    m_flMaximumChangePerSecond = 0X000548 // float32
    m_flDisengageDistance = 0X00054C // float32
    m_flEngageDistance = 0X000550 // float32
    m_bRequiresUseKey = 0X000554 // bool
    m_nOutputType = 0X000558 // ValueRemapperOutputType_t
    m_hOutputEntities = 0X000560 // C_NetworkUtlVectorBase< CHandle< C_BaseEntity > >
    m_nHapticsType = 0X000578 // ValueRemapperHapticsType_t
    m_nMomentumType = 0X00057C // ValueRemapperMomentumType_t
    m_flMomentumModifier = 0X000580 // float32
    m_flSnapValue = 0X000584 // float32
    m_flCurrentMomentum = 0X000588 // float32
    m_nRatchetType = 0X00058C // ValueRemapperRatchetType_t
    m_flRatchetOffset = 0X000590 // float32
    m_flInputOffset = 0X000594 // float32
    m_bEngaged = 0X000598 // bool
    m_bFirstUpdate = 0X000599 // bool
    m_flPreviousValue = 0X00059C // float32
    m_flPreviousUpdateTickTime = 0X0005A0 // GameTime_t
    m_vecPreviousTestPoint = 0X0005A4 // Vector

 C_PointWorldText: [client.dll]
    m_bForceRecreateNextUpdate = 0X000840 // bool
    m_messageText = 0X000850 // char[512]
    m_FontName = 0X000A50 // char[64]
    m_bEnabled = 0X000A90 // bool
    m_bFullbright = 0X000A91 // bool
    m_flWorldUnitsPerPx = 0X000A94 // float32
    m_flFontSize = 0X000A98 // float32
    m_flDepthOffset = 0X000A9C // float32
    m_Color = 0X000AA0 // Color
    m_nJustifyHorizontal = 0X000AA4 // PointWorldTextJustifyHorizontal_t
    m_nJustifyVertical = 0X000AA8 // PointWorldTextJustifyVertical_t
    m_nReorientMode = 0X000AAC // PointWorldTextReorientMode_t

 C_HandleTest: [client.dll]
    m_Handle = 0X000538 // CHandle< C_BaseEntity >
    m_bSendHandle = 0X00053C // bool

 C_EnvWind: [client.dll]
    m_EnvWindShared = 0X000538 // C_EnvWindShared

 C_BaseToggle: [client.dll]
    No schemes available

 C_BaseButton: [client.dll]
    m_glowEntity = 0X000838 // CHandle< C_BaseModelEntity >
    m_usable = 0X00083C // bool
    m_szDisplayText = 0X000840 // CUtlSymbolLarge

 C_PrecipitationBlocker: [client.dll]
    No schemes available

 C_EntityDissolve: [client.dll]
    m_flStartTime = 0X000840 // GameTime_t
    m_flFadeInStart = 0X000844 // float32
    m_flFadeInLength = 0X000848 // float32
    m_flFadeOutModelStart = 0X00084C // float32
    m_flFadeOutModelLength = 0X000850 // float32
    m_flFadeOutStart = 0X000854 // float32
    m_flFadeOutLength = 0X000858 // float32
    m_flNextSparkTime = 0X00085C // GameTime_t
    m_nDissolveType = 0X000860 // EntityDisolveType_t
    m_vDissolverOrigin = 0X000864 // Vector
    m_nMagnitude = 0X000870 // uint32
    m_bCoreExplode = 0X000874 // bool
    m_bLinkedToServerEnt = 0X000875 // bool

 C_EnvProjectedTexture: [client.dll]
    No schemes available

 C_EnvDecal: [client.dll]
    m_hDecalMaterial = 0X000838 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_flWidth = 0X000840 // float32
    m_flHeight = 0X000844 // float32
    m_flDepth = 0X000848 // float32
    m_nRenderOrder = 0X00084C // uint32
    m_bProjectOnWorld = 0X000850 // bool
    m_bProjectOnCharacters = 0X000851 // bool
    m_bProjectOnWater = 0X000852 // bool
    m_flDepthSortBias = 0X000854 // float32

 CFireOverlay: [client.dll]
    m_pOwner = 0X0000D0 // C_FireSmoke*
    m_vBaseColors = 0X0000D8 // Vector[4]
    m_flScale = 0X000108 // float32
    m_nGUID = 0X00010C // int32

 C_FuncBrush: [client.dll]
    No schemes available

 C_FuncElectrifiedVolume: [client.dll]
    m_nAmbientEffect = 0X000838 // ParticleIndex_t
    m_EffectName = 0X000840 // CUtlSymbolLarge
    m_bState = 0X000848 // bool

 C_FuncRotating: [client.dll]
    No schemes available

 C_Breakable: [client.dll]
    No schemes available

 C_PhysBox: [client.dll]
    No schemes available

 C_RopeKeyframe: [client.dll]
    m_LinksTouchingSomething = 0X000840 // CBitVec< 10 >
    m_nLinksTouchingSomething = 0X000844 // int32
    m_bApplyWind = 0X000848 // bool
    m_fPrevLockedPoints = 0X00084C // int32
    m_iForcePointMoveCounter = 0X000850 // int32
    m_bPrevEndPointPos = 0X000854 // bool[2]
    m_vPrevEndPointPos = 0X000858 // Vector[2]
    m_flCurScroll = 0X000870 // float32
    m_flScrollSpeed = 0X000874 // float32
    m_RopeFlags = 0X000878 // uint16
    m_iRopeMaterialModelIndex = 0X000880 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_LightValues = 0X000AF8 // Vector[10]
    m_nSegments = 0X000B70 // uint8
    m_hStartPoint = 0X000B74 // CHandle< C_BaseEntity >
    m_hEndPoint = 0X000B78 // CHandle< C_BaseEntity >
    m_iStartAttachment = 0X000B7C // AttachmentHandle_t
    m_iEndAttachment = 0X000B7D // AttachmentHandle_t
    m_Subdiv = 0X000B7E // uint8
    m_RopeLength = 0X000B80 // int16
    m_Slack = 0X000B82 // int16
    m_TextureScale = 0X000B84 // float32
    m_fLockedPoints = 0X000B88 // uint8
    m_nChangeCount = 0X000B89 // uint8
    m_Width = 0X000B8C // float32
    m_PhysicsDelegate = 0X000B90 // C_RopeKeyframe::CPhysicsDelegate
    m_hMaterial = 0X000BA0 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_TextureHeight = 0X000BA8 // int32
    m_vecImpulse = 0X000BAC // Vector
    m_vecPreviousImpulse = 0X000BB8 // Vector
    m_flCurrentGustTimer = 0X000BC4 // float32
    m_flCurrentGustLifetime = 0X000BC8 // float32
    m_flTimeToNextGust = 0X000BCC // float32
    m_vWindDir = 0X000BD0 // Vector
    m_vColorMod = 0X000BDC // Vector
    m_vCachedEndPointAttachmentPos = 0X000BE8 // Vector[2]
    m_vCachedEndPointAttachmentAngle = 0X000C00 // QAngle[2]
    m_bConstrainBetweenEndpoints = 0X000C18 // bool
    m_bEndPointAttachmentPositionsDirty = 0X000000 // bitfield:1
    m_bEndPointAttachmentAnglesDirty = 0X000000 // bitfield:1
    m_bNewDataThisFrame = 0X000000 // bitfield:1
    m_bPhysicsInitted = 0X000000 // bitfield:1

 C_SceneEntity: [client.dll]
    m_bIsPlayingBack = 0X000540 // bool
    m_bPaused = 0X000541 // bool
    m_bMultiplayer = 0X000542 // bool
    m_bAutogenerated = 0X000543 // bool
    m_flForceClientTime = 0X000544 // float32
    m_nSceneStringIndex = 0X000548 // uint16
    m_bClientOnly = 0X00054A // bool
    m_hOwner = 0X00054C // CHandle< C_BaseFlex >
    m_hActorList = 0X000550 // C_NetworkUtlVectorBase< CHandle< C_BaseFlex > >
    m_bWasPlaying = 0X000568 // bool
    m_QueuedEvents = 0X000578 // CUtlVector< C_SceneEntity::QueuedEvents_t >
    m_flCurrentTime = 0X000590 // float32

 C_SunGlowOverlay: [client.dll]
    m_bModulateByDot = 0X0000D0 // bool

 C_Sun: [client.dll]
    m_fxSSSunFlareEffectIndex = 0X000838 // ParticleIndex_t
    m_fxSunFlareEffectIndex = 0X00083C // ParticleIndex_t
    m_fdistNormalize = 0X000840 // float32
    m_vSunPos = 0X000844 // Vector
    m_vDirection = 0X000850 // Vector
    m_iszEffectName = 0X000860 // CUtlSymbolLarge
    m_iszSSEffectName = 0X000868 // CUtlSymbolLarge
    m_clrOverlay = 0X000870 // Color
    m_bOn = 0X000874 // bool
    m_bmaxColor = 0X000875 // bool
    m_flSize = 0X000878 // float32
    m_flHazeScale = 0X00087C // float32
    m_flRotation = 0X000880 // float32
    m_flHDRColorScale = 0X000884 // float32
    m_flAlphaHaze = 0X000888 // float32
    m_flAlphaScale = 0X00088C // float32
    m_flAlphaHdr = 0X000890 // float32
    m_flFarZScale = 0X000894 // float32

 C_BaseTrigger: [client.dll]
    m_bDisabled = 0X000838 // bool
    m_bClientSidePredicted = 0X000839 // bool

 C_TriggerVolume: [client.dll]
    No schemes available

 C_TriggerLerpObject: [client.dll]
    No schemes available

 C_TriggerBuoyancy: [client.dll]
    m_BuoyancyHelper = 0X000840 // CBuoyancyHelper
    m_flFluidDensity = 0X000888 // float32

 CClientAlphaProperty: [client.dll]
    m_nRenderFX = 0X000010 // uint8
    m_nRenderMode = 0X000011 // uint8
    m_bAlphaOverride = 0X000000 // bitfield:1
    m_bShadowAlphaOverride = 0X000000 // bitfield:1
    m_nReserved = 0X000000 // bitfield:6
    m_nAlpha = 0X000013 // uint8
    m_nDesyncOffset = 0X000014 // uint16
    m_nReserved2 = 0X000016 // uint16
    m_nDistFadeStart = 0X000018 // uint16
    m_nDistFadeEnd = 0X00001A // uint16
    m_flFadeScale = 0X00001C // float32
    m_flRenderFxStartTime = 0X000020 // GameTime_t
    m_flRenderFxDuration = 0X000024 // float32

 C_Beam: [client.dll]
    m_flFrameRate = 0X000838 // float32
    m_flHDRColorScale = 0X00083C // float32
    m_flFireTime = 0X000840 // GameTime_t
    m_flDamage = 0X000844 // float32
    m_nNumBeamEnts = 0X000848 // uint8
    m_queryHandleHalo = 0X00084C // int32
    m_hBaseMaterial = 0X000870 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_nHaloIndex = 0X000878 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_nBeamType = 0X000880 // BeamType_t
    m_nBeamFlags = 0X000884 // uint32
    m_hAttachEntity = 0X000888 // CHandle< C_BaseEntity >[10]
    m_nAttachIndex = 0X0008B0 // AttachmentHandle_t[10]
    m_fWidth = 0X0008BC // float32
    m_fEndWidth = 0X0008C0 // float32
    m_fFadeLength = 0X0008C4 // float32
    m_fHaloScale = 0X0008C8 // float32
    m_fAmplitude = 0X0008CC // float32
    m_fStartFrame = 0X0008D0 // float32
    m_fSpeed = 0X0008D4 // float32
    m_flFrame = 0X0008D8 // float32
    m_nClipStyle = 0X0008DC // BeamClipStyle_t
    m_bTurnedOff = 0X0008E0 // bool
    m_vecEndPos = 0X0008E4 // Vector
    m_hEndEntity = 0X0008F0 // CHandle< C_BaseEntity >

 C_FuncLadder: [client.dll]
    m_vecLadderDir = 0X000838 // Vector
    m_Dismounts = 0X000848 // CUtlVector< CHandle< C_InfoLadderDismount > >
    m_vecLocalTop = 0X000860 // Vector
    m_vecPlayerMountPositionTop = 0X00086C // Vector
    m_vecPlayerMountPositionBottom = 0X000878 // Vector
    m_flAutoRideSpeed = 0X000884 // float32
    m_bDisabled = 0X000888 // bool
    m_bFakeLadder = 0X000889 // bool
    m_bHasSlack = 0X00088A // bool

 CPrecipitationVData: [client.dll]
    m_szParticlePrecipitationEffect = 0X000028 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_flInnerDistance = 0X000108 // float32
    m_nAttachType = 0X00010C // ParticleAttachment_t
    m_bBatchSameVolumeType = 0X000110 // bool
    m_nRTEnvCP = 0X000114 // int32
    m_nRTEnvCPComponent = 0X000118 // int32
    m_szModifier = 0X000120 // CUtlString

 C_Sprite: [client.dll]
    m_hSpriteMaterial = 0X000850 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_hAttachedToEntity = 0X000858 // CHandle< C_BaseEntity >
    m_nAttachment = 0X00085C // AttachmentHandle_t
    m_flSpriteFramerate = 0X000860 // float32
    m_flFrame = 0X000864 // float32
    m_flDieTime = 0X000868 // GameTime_t
    m_nBrightness = 0X000878 // uint32
    m_flBrightnessDuration = 0X00087C // float32
    m_flSpriteScale = 0X000880 // float32
    m_flScaleDuration = 0X000884 // float32
    m_bWorldSpaceScale = 0X000888 // bool
    m_flGlowProxySize = 0X00088C // float32
    m_flHDRColorScale = 0X000890 // float32
    m_flLastTime = 0X000894 // GameTime_t
    m_flMaxFrame = 0X000898 // float32
    m_flStartScale = 0X00089C // float32
    m_flDestScale = 0X0008A0 // float32
    m_flScaleTimeStart = 0X0008A4 // GameTime_t
    m_nStartBrightness = 0X0008A8 // int32
    m_nDestBrightness = 0X0008AC // int32
    m_flBrightnessTimeStart = 0X0008B0 // GameTime_t
    m_hOldSpriteMaterial = 0X0008B8 // CWeakHandle< InfoForResourceTypeIMaterial2 >
    m_nSpriteWidth = 0X000960 // int32
    m_nSpriteHeight = 0X000964 // int32

 C_SpriteOriented: [client.dll]
    No schemes available

 C_BaseClientUIEntity: [client.dll]
    m_bEnabled = 0X000840 // bool
    m_DialogXMLName = 0X000848 // CUtlSymbolLarge
    m_PanelClassName = 0X000850 // CUtlSymbolLarge
    m_PanelID = 0X000858 // CUtlSymbolLarge

 C_PointClientUIDialog: [client.dll]
    m_hActivator = 0X000868 // CHandle< C_BaseEntity >
    m_bStartEnabled = 0X00086C // bool

 C_PointClientUIHUD: [client.dll]
    m_bCheckCSSClasses = 0X000870 // bool
    m_bIgnoreInput = 0X0009F8 // bool
    m_flWidth = 0X0009FC // float32
    m_flHeight = 0X000A00 // float32
    m_flDPI = 0X000A04 // float32
    m_flInteractDistance = 0X000A08 // float32
    m_flDepthOffset = 0X000A0C // float32
    m_unOwnerContext = 0X000A10 // uint32
    m_unHorizontalAlign = 0X000A14 // uint32
    m_unVerticalAlign = 0X000A18 // uint32
    m_unOrientation = 0X000A1C // uint32
    m_bAllowInteractionFromAllSceneWorlds = 0X000A20 // bool
    m_vecCSSClasses = 0X000A28 // C_NetworkUtlVectorBase< CUtlSymbolLarge >

 C_PointClientUIWorldPanel: [client.dll]
    m_bForceRecreateNextUpdate = 0X000870 // bool
    m_bMoveViewToPlayerNextThink = 0X000871 // bool
    m_bCheckCSSClasses = 0X000872 // bool
    m_anchorDeltaTransform = 0X000880 // CTransform
    m_pOffScreenIndicator = 0X000A20 // CPointOffScreenIndicatorUi*
    m_bIgnoreInput = 0X000A48 // bool
    m_bLit = 0X000A49 // bool
    m_bFollowPlayerAcrossTeleport = 0X000A4A // bool
    m_flWidth = 0X000A4C // float32
    m_flHeight = 0X000A50 // float32
    m_flDPI = 0X000A54 // float32
    m_flInteractDistance = 0X000A58 // float32
    m_flDepthOffset = 0X000A5C // float32
    m_unOwnerContext = 0X000A60 // uint32
    m_unHorizontalAlign = 0X000A64 // uint32
    m_unVerticalAlign = 0X000A68 // uint32
    m_unOrientation = 0X000A6C // uint32
    m_bAllowInteractionFromAllSceneWorlds = 0X000A70 // bool
    m_vecCSSClasses = 0X000A78 // C_NetworkUtlVectorBase< CUtlSymbolLarge >
    m_bOpaque = 0X000A90 // bool
    m_bNoDepth = 0X000A91 // bool
    m_bRenderBackface = 0X000A92 // bool
    m_bUseOffScreenIndicator = 0X000A93 // bool
    m_bExcludeFromSaveGames = 0X000A94 // bool
    m_bGrabbable = 0X000A95 // bool
    m_bOnlyRenderToTexture = 0X000A96 // bool
    m_bDisableMipGen = 0X000A97 // bool
    m_nExplicitImageLayout = 0X000A98 // int32

 CPointOffScreenIndicatorUi: [client.dll]
    m_bBeenEnabled = 0X000AA0 // bool
    m_bHide = 0X000AA1 // bool
    m_flSeenTargetTime = 0X000AA4 // float32
    m_pTargetPanel = 0X000AA8 // C_PointClientUIWorldPanel*

 C_PointClientUIWorldTextPanel: [client.dll]
    m_messageText = 0X000AA0 // char[512]

 C_PointHintUi: [client.dll]
    m_pszLessonName = 0X000AD0 // CUtlSymbolLarge
    m_pszCaption = 0X000AD8 // CUtlSymbolLarge
    m_vOffset = 0X000AE0 // Vector
    m_attachType = 0X000AEC // WorldTextAttachmentType_t
    m_hIconTarget = 0X000AF0 // CHandle< C_BaseEntity >
    m_szTargetAttachmentName = 0X000AF8 // CUtlSymbolLarge
    m_pszCustomLayoutFile = 0X000B00 // CUtlSymbolLarge
    m_nTrackedDeviceIndex = 0X000B08 // int32
    m_hHighlightHand = 0X000B0C // CHandle< C_PropVRHand >
    m_pszHighlightControllerComponent = 0X000B10 // CUtlSymbolLarge
    m_pszHighlightControllerAction = 0X000B18 // CUtlSymbolLarge
    m_vecLocalHighlightPoint = 0X000B20 // Vector
    m_pszHighlightOtherEntityName = 0X000B30 // CUtlSymbolLarge
    m_bUseOffScreenIndicator = 0X000B38 // bool

 CInfoOffscreenPanoramaTexture: [client.dll]
    m_bDisabled = 0X000538 // bool
    m_nResolutionX = 0X00053C // int32
    m_nResolutionY = 0X000540 // int32
    m_szLayoutFileName = 0X000548 // CUtlSymbolLarge
    m_RenderAttrName = 0X000550 // CUtlSymbolLarge
    m_TargetEntities = 0X000558 // C_NetworkUtlVectorBase< CHandle< C_BaseModelEntity > >
    m_nTargetChangeCount = 0X000570 // int32
    m_vecCSSClasses = 0X000578 // C_NetworkUtlVectorBase< CUtlSymbolLarge >
    m_bCheckCSSClasses = 0X0006F0 // bool

 C_EconItemView: [client.dll]
    m_bInventoryImageRgbaRequested = 0X000060 // bool
    m_bInventoryImageTriedCache = 0X000061 // bool
    m_nInventoryImageRgbaWidth = 0X000080 // int32
    m_nInventoryImageRgbaHeight = 0X000084 // int32
    m_szCurrentLoadCachedFileName = 0X000088 // char[260]
    m_bRestoreCustomMaterialAfterPrecache = 0X0001B8 // bool
    m_iItemDefinitionIndex = 0X0001BA // uint16
    m_iEntityQuality = 0X0001BC // int32
    m_iEntityLevel = 0X0001C0 // uint32
    m_iItemID = 0X0001C8 // uint64
    m_iItemIDHigh = 0X0001D0 // uint32
    m_iItemIDLow = 0X0001D4 // uint32
    m_iAccountID = 0X0001D8 // uint32
    m_iInventoryPosition = 0X0001DC // uint32
    m_bInitialized = 0X0001E8 // bool
    m_bIsStoreItem = 0X0001E9 // bool
    m_bIsTradeItem = 0X0001EA // bool
    m_iEntityQuantity = 0X0001EC // int32
    m_iRarityOverride = 0X0001F0 // int32
    m_iQualityOverride = 0X0001F4 // int32
    m_unClientFlags = 0X0001F8 // uint8
    m_unOverrideStyle = 0X0001F9 // uint8
    m_AttributeList = 0X000210 // CAttributeList
    m_NetworkedDynamicAttributes = 0X000270 // CAttributeList
    m_szCustomName = 0X0002D0 // char[161]
    m_szCustomNameOverride = 0X000371 // char[161]
    m_bInitializedTags = 0X000440 // bool

 CCSPlayerController: [client.dll]
    m_pInGameMoneyServices = 0X0006B0 // CCSPlayerController_InGameMoneyServices*
    m_pInventoryServices = 0X0006B8 // CCSPlayerController_InventoryServices*
    m_pActionTrackingServices = 0X0006C0 // CCSPlayerController_ActionTrackingServices*
    m_pDamageServices = 0X0006C8 // CCSPlayerController_DamageServices*
    m_iPing = 0X0006D0 // uint32
    m_bHasCommunicationAbuseMute = 0X0006D4 // bool
    m_szCrosshairCodes = 0X0006D8 // CUtlSymbolLarge
    m_iPendingTeamNum = 0X0006E0 // uint8
    m_flForceTeamTime = 0X0006E4 // GameTime_t
    m_iCompTeammateColor = 0X0006E8 // int32
    m_bEverPlayedOnTeam = 0X0006EC // bool
    m_flPreviousForceJoinTeamTime = 0X0006F0 // GameTime_t
    m_szClan = 0X0006F8 // CUtlSymbolLarge
    m_sSanitizedPlayerName = 0X000700 // CUtlString
    m_iCoachingTeam = 0X000708 // int32
    m_nPlayerDominated = 0X000710 // uint64
    m_nPlayerDominatingMe = 0X000718 // uint64
    m_iCompetitiveRanking = 0X000720 // int32
    m_iCompetitiveWins = 0X000724 // int32
    m_iCompetitiveRankType = 0X000728 // int8
    m_nEndMatchNextMapVote = 0X00072C // int32
    m_unActiveQuestId = 0X000730 // uint16
    m_nQuestProgressReason = 0X000734 // QuestProgress::Reason
    m_unPlayerTvControlFlags = 0X000738 // uint32
    m_iDraftIndex = 0X0007A8 // int32
    m_msQueuedModeDisconnectionTimestamp = 0X0007AC // uint32
    m_uiAbandonRecordedReason = 0X0007B0 // uint32
    m_bEverFullyConnected = 0X0007B4 // bool
    m_bAbandonAllowsSurrender = 0X0007B5 // bool
    m_bDisconnection1MinWarningPrinted = 0X0007B6 // bool
    m_bScoreReported = 0X0007B7 // bool
    m_nDisconnectionTick = 0X0007B8 // int32
    m_bControllingBot = 0X0007C8 // bool
    m_bHasControlledBotThisRound = 0X0007C9 // bool
    m_bHasBeenControlledByPlayerThisRound = 0X0007CA // bool
    m_nBotsControlledThisRound = 0X0007CC // int32
    m_bCanControlObservedBot = 0X0007D0 // bool
    m_hPlayerPawn = 0X0007D4 // CHandle< C_CSPlayerPawn >
    m_hObserverPawn = 0X0007D8 // CHandle< C_CSObserverPawn >
    m_bPawnIsAlive = 0X0007DC // bool
    m_iPawnHealth = 0X0007E0 // uint32
    m_iPawnArmor = 0X0007E4 // int32
    m_bPawnHasDefuser = 0X0007E8 // bool
    m_bPawnHasHelmet = 0X0007E9 // bool
    m_nPawnCharacterDefIndex = 0X0007EA // uint16
    m_iPawnLifetimeStart = 0X0007EC // int32
    m_iPawnLifetimeEnd = 0X0007F0 // int32
    m_iPawnGunGameLevel = 0X0007F4 // int32
    m_iPawnBotDifficulty = 0X0007F8 // int32
    m_hOriginalControllerOfCurrentPawn = 0X0007FC // CHandle< CCSPlayerController >
    m_iScore = 0X000800 // int32
    m_vecKills = 0X000808 // C_NetworkUtlVectorBase< EKillTypes_t >
    m_iMVPs = 0X000820 // int32
    m_bIsPlayerNameDirty = 0X000824 // bool

 C_FootstepControl: [client.dll]
    m_source = 0X000840 // CUtlSymbolLarge
    m_destination = 0X000848 // CUtlSymbolLarge

 CWeaponCSBaseVData: [client.dll]
    m_WeaponType = 0X000320 // CSWeaponType
    m_WeaponCategory = 0X000324 // CSWeaponCategory
    m_szViewModel = 0X000328 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szPlayerModel = 0X000408 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szWorldDroppedModel = 0X0004E8 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szAimsightLensMaskModel = 0X0005C8 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szMagazineModel = 0X0006A8 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > >
    m_szHeatEffect = 0X000788 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szEjectBrassEffect = 0X000868 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szMuzzleFlashParticleAlt = 0X000948 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szMuzzleFlashThirdPersonParticle = 0X000A28 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_szMuzzleFlashThirdPersonParticleAlt = 0X000B08 // CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > >
    m_GearSlot = 0X000BE8 // gear_slot_t
    m_GearSlotPosition = 0X000BEC // int32
    m_DefaultLoadoutPosition = 0X000BF0 // loadout_positions_t
    m_sWrongTeamMsg = 0X000BF8 // CUtlString
    m_nPrice = 0X000C00 // int32
    m_nKillAward = 0X000C04 // int32
    m_nPrimaryReserveAmmoMax = 0X000C08 // int32
    m_nSecondaryReserveAmmoMax = 0X000C0C // int32
    m_bMeleeWeapon = 0X000C10 // bool
    m_bHasBurstMode = 0X000C11 // bool
    m_bIsRevolver = 0X000C12 // bool
    m_bCannotShootUnderwater = 0X000C13 // bool
    m_szName = 0X000C18 // CUtlString
    m_szAnimExtension = 0X000C20 // CUtlString
    m_eSilencerType = 0X000C28 // CSWeaponSilencerType
    m_nCrosshairMinDistance = 0X000C2C // int32
    m_nCrosshairDeltaDistance = 0X000C30 // int32
    m_flCycleTime = 0X000C34 // CFiringModeFloat
    m_flMaxSpeed = 0X000C3C // CFiringModeFloat
    m_flSpread = 0X000C44 // CFiringModeFloat
    m_flInaccuracyCrouch = 0X000C4C // CFiringModeFloat
    m_flInaccuracyStand = 0X000C54 // CFiringModeFloat
    m_flInaccuracyJump = 0X000C5C // CFiringModeFloat
    m_flInaccuracyLand = 0X000C64 // CFiringModeFloat
    m_flInaccuracyLadder = 0X000C6C // CFiringModeFloat
    m_flInaccuracyFire = 0X000C74 // CFiringModeFloat
    m_flInaccuracyMove = 0X000C7C // CFiringModeFloat
    m_flRecoilAngle = 0X000C84 // CFiringModeFloat
    m_flRecoilAngleVariance = 0X000C8C // CFiringModeFloat
    m_flRecoilMagnitude = 0X000C94 // CFiringModeFloat
    m_flRecoilMagnitudeVariance = 0X000C9C // CFiringModeFloat
    m_nTracerFrequency = 0X000CA4 // CFiringModeInt
    m_flInaccuracyJumpInitial = 0X000CAC // float32
    m_flInaccuracyJumpApex = 0X000CB0 // float32
    m_flInaccuracyReload = 0X000CB4 // float32
    m_nRecoilSeed = 0X000CB8 // int32
    m_nSpreadSeed = 0X000CBC // int32
    m_flTimeToIdleAfterFire = 0X000CC0 // float32
    m_flIdleInterval = 0X000CC4 // float32
    m_flAttackMovespeedFactor = 0X000CC8 // float32
    m_flHeatPerShot = 0X000CCC // float32
    m_flInaccuracyPitchShift = 0X000CD0 // float32
    m_flInaccuracyAltSoundThreshold = 0X000CD4 // float32
    m_flBotAudibleRange = 0X000CD8 // float32
    m_szUseRadioSubtitle = 0X000CE0 // CUtlString
    m_bUnzoomsAfterShot = 0X000CE8 // bool
    m_bHideViewModelWhenZoomed = 0X000CE9 // bool
    m_nZoomLevels = 0X000CEC // int32
    m_nZoomFOV1 = 0X000CF0 // int32
    m_nZoomFOV2 = 0X000CF4 // int32
    m_flZoomTime0 = 0X000CF8 // float32
    m_flZoomTime1 = 0X000CFC // float32
    m_flZoomTime2 = 0X000D00 // float32
    m_flIronSightPullUpSpeed = 0X000D04 // float32
    m_flIronSightPutDownSpeed = 0X000D08 // float32
    m_flIronSightFOV = 0X000D0C // float32
    m_flIronSightPivotForward = 0X000D10 // float32
    m_flIronSightLooseness = 0X000D14 // float32
    m_angPivotAngle = 0X000D18 // QAngle
    m_vecIronSightEyePos = 0X000D24 // Vector
    m_nDamage = 0X000D30 // int32
    m_flHeadshotMultiplier = 0X000D34 // float32
    m_flArmorRatio = 0X000D38 // float32
    m_flPenetration = 0X000D3C // float32
    m_flRange = 0X000D40 // float32
    m_flRangeModifier = 0X000D44 // float32
    m_flFlinchVelocityModifierLarge = 0X000D48 // float32
    m_flFlinchVelocityModifierSmall = 0X000D4C // float32
    m_flRecoveryTimeCrouch = 0X000D50 // float32
    m_flRecoveryTimeStand = 0X000D54 // float32
    m_flRecoveryTimeCrouchFinal = 0X000D58 // float32
    m_flRecoveryTimeStandFinal = 0X000D5C // float32
    m_nRecoveryTransitionStartBullet = 0X000D60 // int32
    m_nRecoveryTransitionEndBullet = 0X000D64 // int32
    m_flThrowVelocity = 0X000D68 // float32
    m_vSmokeColor = 0X000D6C // Vector
    m_szAnimClass = 0X000D78 // CUtlString

 C_InfoInstructorHintHostageRescueZone: [client.dll]
    No schemes available

 C_PlayerSprayDecal: [client.dll]
    m_nUniqueID = 0X000838 // int32
    m_unAccountID = 0X00083C // uint32
    m_unTraceID = 0X000840 // uint32
    m_rtGcTime = 0X000844 // uint32
    m_vecEndPos = 0X000848 // Vector
    m_vecStart = 0X000854 // Vector
    m_vecLeft = 0X000860 // Vector
    m_vecNormal = 0X00086C // Vector
    m_nPlayer = 0X000878 // int32
    m_nEntity = 0X00087C // int32
    m_nHitbox = 0X000880 // int32
    m_flCreationTime = 0X000884 // float32
    m_nTintID = 0X000888 // int32
    m_nVersion = 0X00088C // uint8
    m_ubSignature = 0X00088D // uint8[128]
    m_SprayRenderHelper = 0X000918 // CPlayerSprayDecalRenderHelper

 C_FuncConveyor: [client.dll]
    m_vecMoveDirEntitySpace = 0X000840 // Vector
    m_flTargetSpeed = 0X00084C // float32
    m_nTransitionStartTick = 0X000850 // GameTick_t
    m_nTransitionDurationTicks = 0X000854 // int32
    m_flTransitionStartSpeed = 0X000858 // float32
    m_hConveyorModels = 0X000860 // C_NetworkUtlVectorBase< CHandle< C_BaseEntity > >
    m_flCurrentConveyorOffset = 0X000878 // float32
    m_flCurrentConveyorSpeed = 0X00087C // float32

 CGrenadeTracer: [client.dll]
    m_flTracerDuration = 0X000858 // float32
    m_nType = 0X00085C // GrenadeType_t

 C_Inferno: [client.dll]
    m_nfxFireDamageEffect = 0X000878 // ParticleIndex_t
    m_fireXDelta = 0X00087C // int32[64]
    m_fireYDelta = 0X00097C // int32[64]
    m_fireZDelta = 0X000A7C // int32[64]
    m_fireParentXDelta = 0X000B7C // int32[64]
    m_fireParentYDelta = 0X000C7C // int32[64]
    m_fireParentZDelta = 0X000D7C // int32[64]
    m_bFireIsBurning = 0X000E7C // bool[64]
    m_BurnNormal = 0X000EBC // Vector[64]
    m_fireCount = 0X0011BC // int32
    m_nInfernoType = 0X0011C0 // int32
    m_nFireLifetime = 0X0011C4 // float32
    m_bInPostEffectTime = 0X0011C8 // bool
    m_lastFireCount = 0X0011CC // int32
    m_nFireEffectTickBegin = 0X0011D0 // int32
    m_drawableCount = 0X007DE0 // int32
    m_blosCheck = 0X007DE4 // bool
    m_nlosperiod = 0X007DE8 // int32
    m_maxFireHalfWidth = 0X007DEC // float32
    m_maxFireHeight = 0X007DF0 // float32
    m_minBounds = 0X007DF4 // Vector
    m_maxBounds = 0X007E00 // Vector
    m_flLastGrassBurnThink = 0X007E0C // float32

 C_FireCrackerBlast: [client.dll]
    No schemes available

 C_BarnLight: [client.dll]
    m_bEnabled = 0X000838 // bool
    m_nColorMode = 0X00083C // int32
    m_Color = 0X000840 // Color
    m_flColorTemperature = 0X000844 // float32
    m_flBrightness = 0X000848 // float32
    m_flBrightnessScale = 0X00084C // float32
    m_nDirectLight = 0X000850 // int32
    m_nBakedShadowIndex = 0X000854 // int32
    m_nLuminaireShape = 0X000858 // int32
    m_flLuminaireSize = 0X00085C // float32
    m_flLuminaireAnisotropy = 0X000860 // float32
    m_LightStyleString = 0X000868 // CUtlString
    m_flLightStyleStartTime = 0X000870 // GameTime_t
    m_QueuedLightStyleStrings = 0X000878 // C_NetworkUtlVectorBase< CUtlString >
    m_LightStyleEvents = 0X000890 // C_NetworkUtlVectorBase< CUtlString >
    m_LightStyleTargets = 0X0008A8 // C_NetworkUtlVectorBase< CHandle< C_BaseModelEntity > >
    m_StyleEvent = 0X0008C0 // CEntityIOOutput[4]
    m_hLightCookie = 0X000960 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_flShape = 0X000968 // float32
    m_flSoftX = 0X00096C // float32
    m_flSoftY = 0X000970 // float32
    m_flSkirt = 0X000974 // float32
    m_flSkirtNear = 0X000978 // float32
    m_vSizeParams = 0X00097C // Vector
    m_flRange = 0X000988 // float32
    m_vShear = 0X00098C // Vector
    m_nBakeSpecularToCubemaps = 0X000998 // int32
    m_vBakeSpecularToCubemapsSize = 0X00099C // Vector
    m_nCastShadows = 0X0009A8 // int32
    m_nShadowMapSize = 0X0009AC // int32
    m_nShadowPriority = 0X0009B0 // int32
    m_bContactShadow = 0X0009B4 // bool
    m_nBounceLight = 0X0009B8 // int32
    m_flBounceScale = 0X0009BC // float32
    m_flMinRoughness = 0X0009C0 // float32
    m_nFog = 0X0009C4 // int32
    m_flFogStrength = 0X0009C8 // float32
    m_nFogShadows = 0X0009CC // int32
    m_flFogScale = 0X0009D0 // float32
    m_flFadeSizeStart = 0X0009D4 // float32
    m_flFadeSizeEnd = 0X0009D8 // float32
    m_flShadowFadeSizeStart = 0X0009DC // float32
    m_flShadowFadeSizeEnd = 0X0009E0 // float32
    m_bPrecomputedFieldsValid = 0X0009E4 // bool
    m_vPrecomputedBoundsMins = 0X0009E8 // Vector
    m_vPrecomputedBoundsMaxs = 0X0009F4 // Vector
    m_vPrecomputedOBBOrigin = 0X000A00 // Vector
    m_vPrecomputedOBBAngles = 0X000A0C // QAngle
    m_vPrecomputedOBBExtent = 0X000A18 // Vector

 C_RectLight: [client.dll]
    m_bShowLight = 0X000A70 // bool

 C_OmniLight: [client.dll]
    m_flInnerAngle = 0X000A70 // float32
    m_flOuterAngle = 0X000A74 // float32
    m_bShowLight = 0X000A78 // bool

 C_CSTeam: [client.dll]
    m_szTeamMatchStat = 0X0005F0 // char[512]
    m_numMapVictories = 0X0007F0 // int32
    m_bSurrendered = 0X0007F4 // bool
    m_scoreFirstHalf = 0X0007F8 // int32
    m_scoreSecondHalf = 0X0007FC // int32
    m_scoreOvertime = 0X000800 // int32
    m_szClanTeamname = 0X000804 // char[129]
    m_iClanID = 0X000888 // uint32
    m_nGGLeaderSlot_CT = 0X00088C // CPlayerSlot
    m_nGGLeaderSlot_T = 0X000890 // CPlayerSlot
    m_szTeamFlagImage = 0X000894 // char[8]
    m_szTeamLogoImage = 0X00089C // char[8]

 C_MapPreviewParticleSystem: [client.dll]
    No schemes available

 CInfoDynamicShadowHint: [client.dll]
    m_bDisabled = 0X000538 // bool
    m_flRange = 0X00053C // float32
    m_nImportance = 0X000540 // int32
    m_nLightChoice = 0X000544 // int32
    m_hLight = 0X000548 // CHandle< C_BaseEntity >

 CInfoDynamicShadowHintBox: [client.dll]
    m_vBoxMins = 0X000550 // Vector
    m_vBoxMaxs = 0X00055C // Vector

 C_EnvSky: [client.dll]
    m_hSkyMaterial = 0X000838 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_bStartDisabled = 0X000840 // bool
    m_vTintColor = 0X000841 // Color
    m_flBrightnessScale = 0X000848 // float32
    m_nFogType = 0X00084C // int32
    m_flFogMinStart = 0X000850 // float32
    m_flFogMinEnd = 0X000854 // float32
    m_flFogMaxStart = 0X000858 // float32
    m_flFogMaxEnd = 0X00085C // float32
    m_bEnabled = 0X000860 // bool

 C_TonemapController2Alias_env_tonemap_controller2: [client.dll]
    No schemes available

 C_LightEntity: [client.dll]
    m_CLightComponent = 0X000838 // CLightComponent*

 C_LightSpotEntity: [client.dll]
    No schemes available

 C_LightOrthoEntity: [client.dll]
    No schemes available

 C_LightDirectionalEntity: [client.dll]
    No schemes available

 C_LightEnvironmentEntity: [client.dll]
    No schemes available

 C_PostProcessingVolume: [client.dll]
    m_hPostSettings = 0X000850 // CStrongHandle< InfoForResourceTypeCPostProcessingResource >
    m_flFadeDuration = 0X000858 // float32
    m_flMinLogExposure = 0X00085C // float32
    m_flMaxLogExposure = 0X000860 // float32
    m_flMinExposure = 0X000864 // float32
    m_flMaxExposure = 0X000868 // float32
    m_flExposureCompensation = 0X00086C // float32
    m_flExposureFadeSpeedUp = 0X000870 // float32
    m_flExposureFadeSpeedDown = 0X000874 // float32
    m_flTonemapEVSmoothingRange = 0X000878 // float32
    m_bMaster = 0X00087C // bool
    m_bExposureControl = 0X00087D // bool
    m_flRate = 0X000880 // float32
    m_flTonemapPercentTarget = 0X000884 // float32
    m_flTonemapPercentBrightPixels = 0X000888 // float32
    m_flTonemapMinAvgLum = 0X00088C // float32

 C_EnvParticleGlow: [client.dll]
    m_flAlphaScale = 0X000DE8 // float32
    m_flRadiusScale = 0X000DEC // float32
    m_flSelfIllumScale = 0X000DF0 // float32
    m_ColorTint = 0X000DF4 // Color
    m_hTextureOverride = 0X000DF8 // CStrongHandle< InfoForResourceTypeCTextureBase >

 C_TextureBasedAnimatable: [client.dll]
    m_bLoop = 0X000838 // bool
    m_flFPS = 0X00083C // float32
    m_hPositionKeys = 0X000840 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_hRotationKeys = 0X000848 // CStrongHandle< InfoForResourceTypeCTextureBase >
    m_vAnimationBoundsMin = 0X000850 // Vector
    m_vAnimationBoundsMax = 0X00085C // Vector
    m_flStartTime = 0X000868 // float32
    m_flStartFrame = 0X00086C // float32

 C_World: [client.dll]
    No schemes available

 CBaseAnimGraph: [client.dll]
    m_pRagdollPose = 0X000848 // PhysicsRagdollPose_t*
    m_bClientRagdoll = 0X000850 // bool
    m_vecForce = 0X000854 // Vector
    m_nForceBone = 0X000860 // int32
    m_bShouldAnimateDuringGameplayPause = 0X000864 // bool
    m_bAnimGraphUpdateEnabled = 0X000865 // bool
    m_bInitiallyPopulateInterpHistory = 0X000866 // bool
    m_flMaxSlopeDistance = 0X000868 // float32
    m_vLastSlopeCheckPos = 0X00086C // Vector
    m_bHasAnimatedMaterialAttributes = 0X000878 // bool
    m_pClientsideRagdoll = 0X000880 // CBaseAnimGraph*
    m_builtRagdoll = 0X000888 // bool
    m_bSuppressAnimEventSounds = 0X000898 // bool

 CBaseProp: [client.dll]
    m_bModelOverrodeBlockLOS = 0X000998 // bool
    m_iShapeType = 0X00099C // int32
    m_bConformToCollisionBounds = 0X0009A0 // bool
    m_mPreferredCatchTransform = 0X0009A4 // matrix3x4_t

 C_BreakableProp: [client.dll]
    m_OnBreak = 0X0009E0 // CEntityIOOutput
    m_OnHealthChanged = 0X000A08 // CEntityOutputTemplate< float32 >
    m_OnTakeDamage = 0X000A30 // CEntityIOOutput
    m_impactEnergyScale = 0X000A58 // float32
    m_iMinHealthDmg = 0X000A5C // int32
    m_flPressureDelay = 0X000A60 // float32
    m_hBreaker = 0X000A64 // CHandle< C_BaseEntity >
    m_PerformanceMode = 0X000A68 // PerformanceMode_t
    m_flDmgModBullet = 0X000A6C // float32
    m_flDmgModClub = 0X000A70 // float32
    m_flDmgModExplosive = 0X000A74 // float32
    m_flDmgModFire = 0X000A78 // float32
    m_iszPhysicsDamageTableName = 0X000A80 // CUtlSymbolLarge
    m_iszBasePropData = 0X000A88 // CUtlSymbolLarge
    m_iInteractions = 0X000A90 // int32
    m_flPreventDamageBeforeTime = 0X000A94 // GameTime_t
    m_bHasBreakPiecesOrCommands = 0X000A98 // bool
    m_explodeDamage = 0X000A9C // float32
    m_explodeRadius = 0X000AA0 // float32
    m_explosionDelay = 0X000AA8 // float32
    m_explosionBuildupSound = 0X000AB0 // CUtlSymbolLarge
    m_explosionCustomEffect = 0X000AB8 // CUtlSymbolLarge
    m_explosionCustomSound = 0X000AC0 // CUtlSymbolLarge
    m_explosionModifier = 0X000AC8 // CUtlSymbolLarge
    m_hPhysicsAttacker = 0X000AD0 // CHandle< C_BasePlayerPawn >
    m_flLastPhysicsInfluenceTime = 0X000AD4 // GameTime_t
    m_flDefaultFadeScale = 0X000AD8 // float32
    m_hLastAttacker = 0X000ADC // CHandle< C_BaseEntity >
    m_hFlareEnt = 0X000AE0 // CHandle< C_BaseEntity >
    m_noGhostCollision = 0X000AE4 // bool

 C_DynamicProp: [client.dll]
    m_bUseHitboxesForRenderBox = 0X000AE8 // bool
    m_bUseAnimGraph = 0X000AE9 // bool
    m_pOutputAnimBegun = 0X000AF0 // CEntityIOOutput
    m_pOutputAnimOver = 0X000B18 // CEntityIOOutput
    m_pOutputAnimLoopCycleOver = 0X000B40 // CEntityIOOutput
    m_OnAnimReachedStart = 0X000B68 // CEntityIOOutput
    m_OnAnimReachedEnd = 0X000B90 // CEntityIOOutput
    m_iszDefaultAnim = 0X000BB8 // CUtlSymbolLarge
    m_nDefaultAnimLoopMode = 0X000BC0 // AnimLoopMode_t
    m_bAnimateOnServer = 0X000BC4 // bool
    m_bRandomizeCycle = 0X000BC5 // bool
    m_bStartDisabled = 0X000BC6 // bool
    m_bScriptedMovement = 0X000BC7 // bool
    m_bFiredStartEndOutput = 0X000BC8 // bool
    m_bForceNpcExclude = 0X000BC9 // bool
    m_bCreateNonSolid = 0X000BCA // bool
    m_bIsOverrideProp = 0X000BCB // bool
    m_iInitialGlowState = 0X000BCC // int32
    m_nGlowRange = 0X000BD0 // int32
    m_nGlowRangeMin = 0X000BD4 // int32
    m_glowColor = 0X000BD8 // Color
    m_nGlowTeam = 0X000BDC // int32
    m_iCachedFrameCount = 0X000BE0 // int32
    m_vecCachedRenderMins = 0X000BE4 // Vector
    m_vecCachedRenderMaxs = 0X000BF0 // Vector

 C_DynamicPropAlias_dynamic_prop: [client.dll]
    No schemes available

 C_DynamicPropAlias_prop_dynamic_override: [client.dll]
    No schemes available

 C_DynamicPropAlias_cable_dynamic: [client.dll]
    No schemes available

 C_ColorCorrectionVolume: [client.dll]
    m_LastEnterWeight = 0X000840 // float32
    m_LastEnterTime = 0X000844 // float32
    m_LastExitWeight = 0X000848 // float32
    m_LastExitTime = 0X00084C // float32
    m_bEnabled = 0X000850 // bool
    m_MaxWeight = 0X000854 // float32
    m_FadeDuration = 0X000858 // float32
    m_Weight = 0X00085C // float32
    m_lookupFilename = 0X000860 // char[512]

 C_FuncMonitor: [client.dll]
    m_targetCamera = 0X000838 // CUtlString
    m_nResolutionEnum = 0X000840 // int32
    m_bRenderShadows = 0X000844 // bool
    m_bUseUniqueColorTarget = 0X000845 // bool
    m_brushModelName = 0X000848 // CUtlString
    m_hTargetCamera = 0X000850 // CHandle< C_BaseEntity >
    m_bEnabled = 0X000854 // bool
    m_bDraw3DSkybox = 0X000855 // bool

 C_FuncMoveLinear: [client.dll]
    No schemes available

 C_PhysMagnet: [client.dll]
    m_aAttachedObjectsFromServer = 0X000998 // CUtlVector< int32 >
    m_aAttachedObjects = 0X0009B0 // CUtlVector< CHandle< C_BaseEntity > >

 C_PointCommentaryNode: [client.dll]
    m_bActive = 0X0009A0 // bool
    m_bWasActive = 0X0009A1 // bool
    m_flEndTime = 0X0009A4 // GameTime_t
    m_flStartTime = 0X0009A8 // GameTime_t
    m_flStartTimeInCommentary = 0X0009AC // float32
    m_iszCommentaryFile = 0X0009B0 // CUtlSymbolLarge
    m_iszTitle = 0X0009B8 // CUtlSymbolLarge
    m_iszSpeakers = 0X0009C0 // CUtlSymbolLarge
    m_iNodeNumber = 0X0009C8 // int32
    m_iNodeNumberMax = 0X0009CC // int32
    m_bListenedTo = 0X0009D0 // bool
    m_hViewPosition = 0X0009E0 // CHandle< C_BaseEntity >
    m_bRestartAfterRestore = 0X0009E4 // bool

 C_WaterBullet: [client.dll]
    No schemes available

 C_BaseDoor: [client.dll]
    m_bIsUsable = 0X000838 // bool

 C_BaseFlex: [client.dll]
    m_flexWeight = 0X0009A0 // C_NetworkUtlVectorBase< float32 >
    m_blinktoggle = 0X0009B8 // bool
    m_vLookTargetPosition = 0X0009C0 // Vector
    m_nLastFlexUpdateFrameCount = 0X000A30 // int32
    m_CachedViewTarget = 0X000A34 // Vector
    m_nNextSceneEventId = 0X000A40 // uint32
    m_iBlink = 0X000A44 // int32
    m_blinktime = 0X000A48 // float32
    m_prevblinktoggle = 0X000A4C // bool
    m_iJawOpen = 0X000A50 // int32
    m_flJawOpenAmount = 0X000A54 // float32
    m_flBlinkAmount = 0X000A58 // float32
    m_iMouthAttachment = 0X000A5C // AttachmentHandle_t
    m_iEyeAttachment = 0X000A5D // AttachmentHandle_t
    m_bResetFlexWeightsOnModelChange = 0X000A5E // bool
    m_nEyeOcclusionRendererBone = 0X000A78 // int32
    m_mEyeOcclusionRendererCameraToBoneTransform = 0X000A7C // matrix3x4_t
    m_vEyeOcclusionRendererHalfExtent = 0X000AAC // Vector
    m_PhonemeClasses = 0X000AC8 // C_BaseFlex::Emphasized_Phoneme[3]

 C_ClientRagdoll: [client.dll]
    m_bFadeOut = 0X000998 // bool
    m_bImportant = 0X000999 // bool
    m_flEffectTime = 0X00099C // GameTime_t
    m_gibDespawnTime = 0X0009A0 // GameTime_t
    m_iCurrentFriction = 0X0009A4 // int32
    m_iMinFriction = 0X0009A8 // int32
    m_iMaxFriction = 0X0009AC // int32
    m_iFrictionAnimState = 0X0009B0 // int32
    m_bReleaseRagdoll = 0X0009B4 // bool
    m_iEyeAttachment = 0X0009B5 // AttachmentHandle_t
    m_bFadingOut = 0X0009B6 // bool
    m_flScaleEnd = 0X0009B8 // float32[10]
    m_flScaleTimeStart = 0X0009E0 // GameTime_t[10]
    m_flScaleTimeEnd = 0X000A08 // GameTime_t[10]

 C_Precipitation: [client.dll]
    m_flDensity = 0X000840 // float32
    m_flParticleInnerDist = 0X000850 // float32
    m_pParticleDef = 0X000858 // char*
    m_tParticlePrecipTraceTimer = 0X000880 // TimedEvent[1]
    m_bActiveParticlePrecipEmitter = 0X000888 // bool[1]
    m_bParticlePrecipInitialized = 0X000889 // bool
    m_bHasSimulatedSinceLastSceneObjectUpdate = 0X00088A // bool
    m_nAvailableSheetSequencesMaxIndex = 0X00088C // int32

 C_FireSprite: [client.dll]
    m_vecMoveDir = 0X000968 // Vector
    m_bFadeFromAbove = 0X000974 // bool

 C_FireFromAboveSprite: [client.dll]
    No schemes available

 C_Fish: [client.dll]
    m_pos = 0X000998 // Vector
    m_vel = 0X0009A4 // Vector
    m_angles = 0X0009B0 // QAngle
    m_localLifeState = 0X0009BC // int32
    m_deathDepth = 0X0009C0 // float32
    m_deathAngle = 0X0009C4 // float32
    m_buoyancy = 0X0009C8 // float32
    m_wiggleTimer = 0X0009D0 // CountdownTimer
    m_wigglePhase = 0X0009E8 // float32
    m_wiggleRate = 0X0009EC // float32
    m_actualPos = 0X0009F0 // Vector
    m_actualAngles = 0X0009FC // QAngle
    m_poolOrigin = 0X000A08 // Vector
    m_waterLevel = 0X000A14 // float32
    m_gotUpdate = 0X000A18 // bool
    m_x = 0X000A1C // float32
    m_y = 0X000A20 // float32
    m_z = 0X000A24 // float32
    m_angle = 0X000A28 // float32
    m_errorHistory = 0X000A2C // float32[20]
    m_errorHistoryIndex = 0X000A7C // int32
    m_errorHistoryCount = 0X000A80 // int32
    m_averageError = 0X000A84 // float32

 C_PhysicsProp: [client.dll]
    m_bAwake = 0X000AE8 // bool

 C_BasePropDoor: [client.dll]
    m_eDoorState = 0X000C10 // DoorState_t
    m_modelChanged = 0X000C14 // bool
    m_bLocked = 0X000C15 // bool
    m_closedPosition = 0X000C18 // Vector
    m_closedAngles = 0X000C24 // QAngle
    m_hMaster = 0X000C30 // CHandle< C_BasePropDoor >
    m_vWhereToSetLightingOrigin = 0X000C34 // Vector

 C_PhysPropClientside: [client.dll]
    m_flTouchDelta = 0X000AE8 // GameTime_t
    m_fDeathTime = 0X000AEC // GameTime_t
    m_impactEnergyScale = 0X000AF0 // float32
    m_inertiaScale = 0X000AF4 // float32
    m_flDmgModBullet = 0X000AF8 // float32
    m_flDmgModClub = 0X000AFC // float32
    m_flDmgModExplosive = 0X000B00 // float32
    m_flDmgModFire = 0X000B04 // float32
    m_iszPhysicsDamageTableName = 0X000B08 // CUtlSymbolLarge
    m_iszBasePropData = 0X000B10 // CUtlSymbolLarge
    m_iInteractions = 0X000B18 // int32
    m_bHasBreakPiecesOrCommands = 0X000B1C // bool

 C_RagdollProp: [client.dll]
    m_ragPos = 0X0009A0 // C_NetworkUtlVectorBase< Vector >
    m_ragAngles = 0X0009B8 // C_NetworkUtlVectorBase< QAngle >
    m_flBlendWeight = 0X0009D0 // float32
    m_hRagdollSource = 0X0009D4 // CHandle< C_BaseEntity >
    m_iEyeAttachment = 0X0009D8 // AttachmentHandle_t
    m_flBlendWeightCurrent = 0X0009DC // float32
    m_parentPhysicsBoneIndices = 0X0009E0 // CUtlVector< int32 >
    m_worldSpaceBoneComputationOrder = 0X0009F8 // CUtlVector< int32 >

 C_LocalTempEntity: [client.dll]
    flags = 0X0009B0 // int32
    die = 0X0009B4 // GameTime_t
    m_flFrameMax = 0X0009B8 // float32
    x = 0X0009BC // float32
    y = 0X0009C0 // float32
    fadeSpeed = 0X0009C4 // float32
    bounceFactor = 0X0009C8 // float32
    hitSound = 0X0009CC // int32
    priority = 0X0009D0 // int32
    tentOffset = 0X0009D4 // Vector
    m_vecTempEntAngVelocity = 0X0009E0 // QAngle
    tempent_renderamt = 0X0009EC // int32
    m_vecNormal = 0X0009F0 // Vector
    m_flSpriteScale = 0X0009FC // float32
    m_nFlickerFrame = 0X000A00 // int32
    m_flFrameRate = 0X000A04 // float32
    m_flFrame = 0X000A08 // float32
    m_pszImpactEffect = 0X000A10 // char*
    m_pszParticleEffect = 0X000A18 // char*
    m_bParticleCollision = 0X000A20 // bool
    m_iLastCollisionFrame = 0X000A24 // int32
    m_vLastCollisionOrigin = 0X000A28 // Vector
    m_vecTempEntVelocity = 0X000A34 // Vector
    m_vecPrevAbsOrigin = 0X000A40 // Vector
    m_vecTempEntAcceleration = 0X000A4C // Vector

 C_ShatterGlassShardPhysics: [client.dll]
    m_ShardDesc = 0X000AF8 // shard_model_desc_t

 C_PointHintUIButtonHighlightModel: [client.dll]
    m_mComponentTransform = 0X000998 // matrix3x4_t

 C_PointHintUIArrowHighlightModel: [client.dll]
    m_mArrowLocalTransform = 0X000998 // matrix3x4_t

 C_PointHintUIHighlightModel: [client.dll]
    m_vecRenderModelComponentTransforms = 0X0009C8 // CUtlVector< matrix3x4a_t >
    m_nTrackedDeviceIndex = 0X0009E0 // int32
    m_matLocalHighlight = 0X0009F8 // matrix3x4_t
    m_bVisible = 0X000A28 // bool

 C_EconEntity: [client.dll]
    m_flFlexDelayTime = 0X000B38 // float32
    m_flFlexDelayedWeight = 0X000B40 // float32*
    m_bAttributesInitialized = 0X000B48 // bool
    m_AttributeManager = 0X000B50 // C_AttributeContainer
    m_OriginalOwnerXuidLow = 0X000FF8 // uint32
    m_OriginalOwnerXuidHigh = 0X000FFC // uint32
    m_nFallbackPaintKit = 0X001000 // int32
    m_nFallbackSeed = 0X001004 // int32
    m_flFallbackWear = 0X001008 // float32
    m_nFallbackStatTrak = 0X00100C // int32
    m_bClientside = 0X001010 // bool
    m_bParticleSystemsCreated = 0X001011 // bool
    m_vecAttachedParticles = 0X001018 // CUtlVector< int32 >
    m_hViewmodelAttachment = 0X001030 // CHandle< CBaseAnimGraph >
    m_iOldTeam = 0X001034 // int32
    m_bAttachmentDirty = 0X001038 // bool
    m_nUnloadedModelIndex = 0X00103C // int32
    m_iNumOwnerValidationRetries = 0X001040 // int32
    m_hOldProvidee = 0X001050 // CHandle< C_BaseEntity >
    m_vecAttachedModels = 0X001058 // CUtlVector< C_EconEntity::AttachedModelData_t >

 C_EconWearable: [client.dll]
    m_nForceSkin = 0X001070 // int32
    m_bAlwaysAllow = 0X001074 // bool

 C_BaseGrenade: [client.dll]
    m_bHasWarnedAI = 0X000B28 // bool
    m_bIsSmokeGrenade = 0X000B29 // bool
    m_bIsLive = 0X000B2A // bool
    m_DmgRadius = 0X000B2C // float32
    m_flDetonateTime = 0X000B30 // GameTime_t
    m_flWarnAITime = 0X000B34 // float32
    m_flDamage = 0X000B38 // float32
    m_iszBounceSound = 0X000B40 // CUtlSymbolLarge
    m_ExplosionSound = 0X000B48 // CUtlString
    m_hThrower = 0X000B54 // CHandle< C_BaseEntity >
    m_flNextAttack = 0X000B70 // GameTime_t
    m_hOriginalThrower = 0X000B74 // CHandle< C_BaseEntity >

 C_BRC4Target: [client.dll]
    m_bBrokenOpen = 0X0009A0 // bool
    m_flRadius = 0X0009A4 // float32

 C_ParadropChopper: [client.dll]
    m_vecLastRopeTargetPos = 0X0009A0 // Vector
    m_flLastRopeTime = 0X0009AC // GameTime_t
    m_nRappelABone = 0X0009B0 // int32
    m_nRappelBBone = 0X0009B4 // int32
    m_hCallingPlayer = 0X0009B8 // CHandle< C_BaseEntity >
    m_bCalledByPlayer = 0X0009BC // bool

 C_SurvivalSpawnChopper: [client.dll]
    No schemes available

 C_Dronegun: [client.dll]
    m_vecAttentionTarget = 0X0009A0 // Vector
    m_vecTargetOffset = 0X0009AC // Vector
    m_bHasTarget = 0X0009B8 // bool
    m_vecAttentionCurrent = 0X0009BC // Vector
    m_nPoseParamPitch = 0X0009C8 // int32
    m_nPoseParamYaw = 0X0009CC // int32
    m_bVarInit = 0X0009D0 // bool
    m_nAttachMuzzle = 0X0009D1 // AttachmentHandle_t
    m_flLastClientThinkTime = 0X0009D4 // GameTime_t
    m_flNextSpark = 0X0009D8 // GameTime_t
    m_nBoneOverrideIndex = 0X0009DC // int32
    m_vecLaserTracePos = 0X0009E0 // Vector

 C_Drone: [client.dll]
    m_vecClientSideTrailPositions = 0X000B00 // CUtlVector< Vector >
    m_hMoveToThisEntity = 0X000B18 // CEntityHandle
    m_hDeliveryCargo = 0X000B1C // CEntityHandle
    m_hRecentCargo = 0X000B20 // CEntityHandle
    m_bPilotTakeoverAllowed = 0X000B24 // bool
    m_hPotentialCargo = 0X000B28 // CEntityHandle
    m_hCurrentPilot = 0X000B2C // CEntityHandle
    m_vecTagPositions = 0X000B30 // Vector[24]
    m_vecTagIncrements = 0X000C50 // int32[24]
    m_flLastTimeCargoWasAttached = 0X000CB0 // GameTime_t
    m_vecLastKnownCargoAttachPositions = 0X000CB4 // Vector[4]
    m_vecThrusterLastPos = 0X000CE4 // Vector
    m_vecThrusterSmoothVel = 0X000CF0 // Vector
    m_vecThrusterSmoothAccel = 0X000CFC // Vector
    m_flJammedEffectAmount = 0X000D08 // float32

 C_CSPropExplodingBarrel: [client.dll]
    No schemes available

 C_CSPropExplodingBarrelTop: [client.dll]
    m_flOverrideAlpha = 0X000AF0 // float32

 C_EnvGasCanister: [client.dll]
    m_bLanded = 0X000998 // bool
    m_bSpawnedSkyboxParticles = 0X000A00 // bool
    m_flKillImpactParticlesTime = 0X000A04 // GameTime_t
    m_vecImpactPosition = 0X000A08 // Vector
    m_vecStartPosition = 0X000A14 // Vector
    m_vecEnterWorldPosition = 0X000A20 // Vector
    m_vecDirection = 0X000A2C // Vector
    m_vecStartAngles = 0X000A38 // QAngle
    m_flFlightTime = 0X000A44 // float32
    m_flFlightSpeed = 0X000A48 // float32
    m_flLaunchTime = 0X000A4C // GameTime_t
    m_flInitialZSpeed = 0X000A50 // float32
    m_flZAcceleration = 0X000A54 // float32
    m_flHorizSpeed = 0X000A58 // float32
    m_bLaunchedFromWithinWorld = 0X000A5C // bool
    m_vecParabolaDirection = 0X000A60 // Vector
    m_flWorldEnterTime = 0X000A6C // float32
    m_vecSkyboxOrigin = 0X000A70 // Vector
    m_flSkyboxScale = 0X000A7C // float32
    m_bInSkybox = 0X000A80 // bool
    m_bDoImpactEffects = 0X000A81 // bool
    m_nMyZoneIndex = 0X000A84 // int32
    m_hSkyboxCopy = 0X000A88 // CHandle< C_BaseEntity >
    m_flLaunchHeight = 0X000A8C // float32

 C_PropCounter: [client.dll]
    m_flDisplayValue = 0X000998 // float32
    m_flDisplayValueLocal = 0X00099C // float32
    m_flTimeOfLastValueChange = 0X0009A0 // float32
    m_flPreviousValue = 0X0009A4 // float32

 C_ViewmodelWeapon: [client.dll]
    m_worldModel = 0X000998 // char*

 C_BaseViewModel: [client.dll]
    m_vecLastFacing = 0X0009A0 // Vector
    m_nViewModelIndex = 0X0009AC // uint32
    m_nAnimationParity = 0X0009B0 // uint32
    m_flAnimationStartTime = 0X0009B4 // float32
    m_hWeapon = 0X0009B8 // CHandle< C_BasePlayerWeapon >
    m_sVMName = 0X0009C0 // CUtlSymbolLarge
    m_sAnimationPrefix = 0X0009C8 // CUtlSymbolLarge
    m_hWeaponModel = 0X0009D0 // CHandle< C_ViewmodelWeapon >
    m_iCameraAttachment = 0X0009D4 // AttachmentHandle_t
    m_vecLastCameraAngles = 0X0009D8 // QAngle
    m_previousElapsedDuration = 0X0009E4 // float32
    m_previousCycle = 0X0009E8 // float32
    m_nOldAnimationParity = 0X0009EC // int32
    m_hOldLayerSequence = 0X0009F0 // HSequence
    m_oldLayer = 0X0009F4 // int32
    m_oldLayerStartTime = 0X0009F8 // float32
    m_hControlPanel = 0X0009FC // CEntityHandle

 C_ViewmodelAttachmentModel: [client.dll]
    No schemes available

 C_PredictedViewModel: [client.dll]
    m_LagAnglesHistory = 0X000A00 // QAngle
    m_vPredictedOffset = 0X000A18 // Vector

 C_WorldModelStattrak: [client.dll]
    No schemes available

 C_WorldModelNametag: [client.dll]
    No schemes available

 C_BaseCSGrenadeProjectile: [client.dll]
    m_vInitialVelocity = 0X000B78 // Vector
    m_nBounces = 0X000B84 // int32
    m_nExplodeEffectIndex = 0X000B88 // CStrongHandle< InfoForResourceTypeIParticleSystemDefinition >
    m_nExplodeEffectTickBegin = 0X000B90 // int32
    m_vecExplodeEffectOrigin = 0X000B94 // Vector
    m_flSpawnTime = 0X000BA0 // GameTime_t
    vecLastTrailLinePos = 0X000BA4 // Vector
    flNextTrailLineTime = 0X000BB0 // GameTime_t
    m_bExplodeEffectBegan = 0X000BB4 // bool
    m_bCanCreateGrenadeTrail = 0X000BB5 // bool
    m_nSnapshotTrajectoryEffectIndex = 0X000BB8 // ParticleIndex_t
    m_hSnapshotTrajectoryParticleSnapshot = 0X000BC0 // CStrongHandle< InfoForResourceTypeIParticleSnapshot >
    m_arrTrajectoryTrailPoints = 0X000BC8 // CUtlVector< Vector >
    m_arrTrajectoryTrailPointCreationTimes = 0X000BE0 // CUtlVector< float32 >
    m_flTrajectoryTrailEffectCreationTime = 0X000BF8 // float32

 C_BreachChargeProjectile: [client.dll]
    m_bShouldExplode = 0X000B78 // bool
    m_weaponThatThrewMe = 0X000B7C // CHandle< C_BaseEntity >
    m_nParentBoneIndex = 0X000B80 // int32
    m_vecParentBonePos = 0X000B84 // Vector

 C_BumpMineProjectile: [client.dll]
    m_bShouldExplode = 0X000B78 // bool
    m_nParentBoneIndex = 0X000B7C // int32
    m_vecParentBonePos = 0X000B80 // Vector
    m_bArmed = 0X000B8C // bool

 C_TripWireFireProjectile: [client.dll]
    m_flAttachTime = 0X000B78 // GameTime_t
    m_vecTripWireEndPositions = 0X000B7C // Vector[10]
    m_bTripWireEndPositionsUsed = 0X000BF4 // bool[10]
    m_nTripWireStartIndex0 = 0X000C00 // int32
    m_nTripWireEndIndex0 = 0X000C04 // int32
    m_nTripWireCenterIndex0 = 0X000C08 // int32

 C_PhysicsPropMultiplayer: [client.dll]
    No schemes available

 C_PhysPropLootCrate: [client.dll]
    m_bRenderInPSPM = 0X000AF8 // bool
    m_bRenderInTablet = 0X000AF9 // bool
    m_iMaxHealth = 0X000AFC // int32
    m_iHealth = 0X000B00 // int32

 C_PhysPropAmmoBox: [client.dll]
    No schemes available

 C_PhysPropWeaponUpgrade: [client.dll]
    No schemes available

 C_PhysPropRadarJammer: [client.dll]
    No schemes available

 C_SensorGrenadeProjectile: [client.dll]
    No schemes available

 C_CSGO_PreviewModel: [client.dll]
    m_animgraph = 0X000B28 // CUtlString
    m_animgraphCharacterModeString = 0X000B30 // CUtlString
    m_defaultAnim = 0X000B38 // CUtlString
    m_nDefaultAnimLoopMode = 0X000B40 // AnimLoopMode_t
    m_flInitialModelScale = 0X000B44 // float32

 C_CSGO_PreviewModelAlias_csgo_item_previewmodel: [client.dll]
    No schemes available

 C_BulletHitModel: [client.dll]
    m_matLocal = 0X000998 // matrix3x4_t
    m_iBoneIndex = 0X0009C8 // int32
    m_hPlayerParent = 0X0009CC // CHandle< C_BaseEntity >
    m_bIsHit = 0X0009D0 // bool
    m_flTimeCreated = 0X0009D4 // float32
    m_vecStartPos = 0X0009D8 // Vector

 C_PickUpModelSlerper: [client.dll]
    m_hPlayerParent = 0X000998 // CHandle< C_BaseEntity >
    m_hItem = 0X00099C // CHandle< C_BaseEntity >
    m_flTimePickedUp = 0X0009A0 // float32
    m_angOriginal = 0X0009A4 // QAngle
    m_vecPosOriginal = 0X0009B0 // Vector
    m_angRandom = 0X0009C0 // QAngle

 C_WorldModelGloves: [client.dll]
    No schemes available

 C_HostageCarriableProp: [client.dll]
    No schemes available

 C_Multimeter: [client.dll]
    m_hTargetC4 = 0X0009A0 // CHandle< C_PlantedC4 >

 C_PlantedC4: [client.dll]
    m_bBombTicking = 0X000998 // bool
    m_nBombSite = 0X00099C // int32
    m_nSourceSoundscapeHash = 0X0009A0 // int32
    m_entitySpottedState = 0X0009A8 // EntitySpottedState_t
    m_flNextGlow = 0X0009C0 // GameTime_t
    m_flNextBeep = 0X0009C4 // GameTime_t
    m_flC4Blow = 0X0009C8 // GameTime_t
    m_flTimerLength = 0X0009CC // float32
    m_bTenSecWarning = 0X0009D0 // float32
    m_bTriggerWarning = 0X0009D4 // float32
    m_bExplodeWarning = 0X0009D8 // float32
    m_bLocalBRMusicPlayed = 0X0009DC // bool
    m_flDefuseLength = 0X0009E0 // float32
    m_flDefuseCountDown = 0X0009E4 // GameTime_t
    m_bBombDefused = 0X0009E8 // bool
    m_hBombDefuser = 0X0009EC // CHandle< C_CSPlayerPawnBase >
    m_hControlPanel = 0X0009F0 // CEntityHandle
    m_hDefuserMultimeter = 0X0009F4 // CHandle< C_Multimeter >
    m_flNextRadarFlashTime = 0X0009F8 // GameTime_t
    m_bRadarFlash = 0X0009FC // bool
    m_hLocalDefusingPlayerHandle = 0X000A00 // CHandle< C_CSPlayerPawnBase >

 C_Item: [client.dll]
    m_bShouldGlow = 0X001070 // bool
    m_pReticleHintTextName = 0X001071 // char[256]

 C_Chicken: [client.dll]
    m_hHolidayHatAddon = 0X000C08 // CHandle< CBaseAnimGraph >
    m_jumpedThisFrame = 0X000C0C // bool
    m_leader = 0X000C10 // CHandle< C_CSPlayerPawnBase >
    m_AttributeManager = 0X000C18 // C_AttributeContainer
    m_OriginalOwnerXuidLow = 0X0010C0 // uint32
    m_OriginalOwnerXuidHigh = 0X0010C4 // uint32
    m_bAttributesInitialized = 0X0010C8 // bool

 C_BasePlayerWeapon: [client.dll]
    m_iState = 0X001070 // WeaponState_t
    m_iOldState = 0X001074 // WeaponState_t
    m_bRemoveable = 0X001078 // bool
    m_nNextPrimaryAttackTick = 0X00107C // GameTick_t
    m_flNextPrimaryAttackTickRatio = 0X001080 // float32
    m_nNextSecondaryAttackTick = 0X001084 // GameTick_t
    m_flNextSecondaryAttackTickRatio = 0X001088 // float32
    m_iClip1 = 0X00108C // int32
    m_iClip2 = 0X001090 // int32
    m_pReserveAmmo = 0X001094 // int32[2]

 C_RagdollPropAttached: [client.dll]
    m_boneIndexAttached = 0X000A10 // uint32
    m_ragdollAttachedObjectIndex = 0X000A14 // uint32
    m_attachmentPointBoneSpace = 0X000A18 // Vector
    m_attachmentPointRagdollSpace = 0X000A24 // Vector
    m_vecOffset = 0X000A30 // Vector
    m_parentTime = 0X000A3C // float32
    m_bHasParent = 0X000A40 // bool

 C_BaseCombatCharacter: [client.dll]
    m_hMyWearables = 0X000B28 // C_NetworkUtlVectorBase< CHandle< C_EconWearable > >
    m_bloodColor = 0X000B40 // int32
    m_leftFootAttachment = 0X000B44 // AttachmentHandle_t
    m_rightFootAttachment = 0X000B45 // AttachmentHandle_t
    m_nWaterWakeMode = 0X000B48 // C_BaseCombatCharacter::WaterWakeMode_t
    m_flWaterWorldZ = 0X000B4C // float32
    m_flWaterNextTraceTime = 0X000B50 // float32
    m_flFieldOfView = 0X000B54 // float32

 C_BasePlayerPawn: [client.dll]
    m_pWeaponServices = 0X000BB8 // CPlayer_WeaponServices*
    m_pItemServices = 0X000BC0 // CPlayer_ItemServices*
    m_pAutoaimServices = 0X000BC8 // CPlayer_AutoaimServices*
    m_pObserverServices = 0X000BD0 // CPlayer_ObserverServices*
    m_pWaterServices = 0X000BD8 // CPlayer_WaterServices*
    m_pUseServices = 0X000BE0 // CPlayer_UseServices*
    m_pFlashlightServices = 0X000BE8 // CPlayer_FlashlightServices*
    m_pCameraServices = 0X000BF0 // CPlayer_CameraServices*
    m_pMovementServices = 0X000BF8 // CPlayer_MovementServices*
    m_fixAngleChangeType = 0X000C08 // FixAngleSet_t
    m_fixAngleChangeAngle = 0X000C0C // QAngle
    m_fixAngleChangeTick = 0X000C18 // int32
    v_angle = 0X000C1C // QAngle
    m_iHideHUD = 0X000C28 // uint32
    m_skybox3d = 0X000C30 // sky3dparams_t
    m_flDeathTime = 0X000CC0 // GameTime_t
    m_vecPredictionError = 0X000CC4 // Vector
    m_flPredictionErrorTime = 0X000CD0 // GameTime_t
    m_flFOVSensitivityAdjust = 0X000CD4 // float32
    m_flMouseSensitivity = 0X000CD8 // float32
    m_vOldOrigin = 0X000CDC // Vector
    m_flOldSimulationTime = 0X000CE8 // float32
    m_nLastExecutedCommandNumber = 0X000CEC // int32
    m_nLastExecutedCommandTick = 0X000CF0 // int32
    m_hController = 0X000CF4 // CHandle< CBasePlayerController >
    m_bIsSwappingToPredictableController = 0X000CF8 // bool

 C_ItemCash: [client.dll]
    No schemes available

 C_CSGOViewModel: [client.dll]
    m_bShouldIgnoreOffsetAndAccuracy = 0X000A28 // bool
    m_vecCamDriverLastPos = 0X000A2C // Vector
    m_angCamDriverLastAng = 0X000A38 // QAngle
    m_flCamDriverAppliedTime = 0X000A44 // float32
    m_flCamDriverWeight = 0X000A48 // float32
    m_nWeaponParity = 0X000A4C // uint32
    m_nOldWeaponParity = 0X000A50 // uint32
    m_nLastKnownAssociatedWeaponEntIndex = 0X000A54 // CEntityIndex
    m_bNeedToQueueHighResComposite = 0X000A58 // bool
    m_vLoweredWeaponOffset = 0X000A9C // QAngle

 C_WeaponCSBase: [client.dll]
    m_flFireSequenceStartTime = 0X0010D8 // float32
    m_nFireSequenceStartTimeChange = 0X0010DC // int32
    m_nFireSequenceStartTimeAck = 0X0010E0 // int32
    m_bPlayerFireEventIsPrimary = 0X0010E4 // bool
    m_seqIdle = 0X0010E8 // HSequence
    m_seqFirePrimary = 0X0010EC // HSequence
    m_seqFireSecondary = 0X0010F0 // HSequence
    m_flCrosshairDistance = 0X001108 // float32
    m_iAmmoLastCheck = 0X00110C // int32
    m_iAlpha = 0X001110 // int32
    m_iScopeTextureID = 0X001114 // int32
    m_iCrosshairTextureID = 0X001118 // int32
    m_flGunAccuracyPosition = 0X00111C // float32
    m_nViewModelIndex = 0X001120 // uint32
    m_bReloadsWithClips = 0X001124 // bool
    m_flTimeWeaponIdle = 0X001128 // GameTime_t
    m_bFireOnEmpty = 0X00112C // bool
    m_OnPlayerPickup = 0X001130 // CEntityIOOutput
    m_weaponMode = 0X001158 // CSWeaponMode
    m_flTurningInaccuracyDelta = 0X00115C // float32
    m_vecTurningInaccuracyEyeDirLast = 0X001160 // Vector
    m_flTurningInaccuracy = 0X00116C // float32
    m_fAccuracyPenalty = 0X001170 // float32
    m_flLastAccuracyUpdateTime = 0X001174 // GameTime_t
    m_fAccuracySmoothedForZoom = 0X001178 // float32
    m_fScopeZoomEndTime = 0X00117C // GameTime_t
    m_iRecoilIndex = 0X001180 // int32
    m_flRecoilIndex = 0X001184 // float32
    m_bBurstMode = 0X001188 // bool
    m_flPostponeFireReadyTime = 0X00118C // GameTime_t
    m_bInReload = 0X001190 // bool
    m_bReloadVisuallyComplete = 0X001191 // bool
    m_flDroppedAtTime = 0X001194 // GameTime_t
    m_bIsHauledBack = 0X001198 // bool
    m_bSilencerOn = 0X001199 // bool
    m_flTimeSilencerSwitchComplete = 0X00119C // GameTime_t
    m_iOriginalTeamNumber = 0X0011A0 // int32
    m_flNextAttackRenderTimeOffset = 0X0011A4 // float32
    m_bVisualsDataSet = 0X001230 // bool
    m_bOldFirstPersonSpectatedState = 0X001231 // bool
    m_hOurPing = 0X001234 // CHandle< C_BaseEntity >
    m_nOurPingIndex = 0X001238 // CEntityIndex
    m_vecOurPingPos = 0X00123C // Vector
    m_bGlowForPing = 0X001248 // bool
    m_bUIWeapon = 0X001249 // bool
    m_hPrevOwner = 0X001258 // CHandle< C_CSPlayerPawnBase >
    m_donated = 0X00127C // bool
    m_fLastShotTime = 0X001280 // GameTime_t
    m_bWasOwnedByCT = 0X001284 // bool
    m_bWasOwnedByTerrorist = 0X001285 // bool
    m_gunHeat = 0X001288 // float32
    m_smokeAttachments = 0X00128C // uint32
    m_lastSmokeTime = 0X001290 // GameTime_t
    m_flLastClientFireBulletTime = 0X001294 // float32
    m_IronSightController = 0X0012F0 // C_IronSightController
    m_iIronSightMode = 0X0013A0 // int32
    m_flLastLOSTraceFailureTime = 0X0013B0 // GameTime_t
    m_iNumEmptyAttacks = 0X0013B4 // int32

 C_WeaponCSBaseGun: [client.dll]
    m_zoomLevel = 0X0013D0 // int32
    m_iBurstShotsRemaining = 0X0013D4 // int32
    m_iSilencerBodygroup = 0X0013D8 // int32
    m_silencedModelIndex = 0X0013E8 // int32
    m_inPrecache = 0X0013EC // bool
    m_bNeedsBoltAction = 0X0013ED // bool

 C_C4: [client.dll]
    m_szScreenText = 0X0013D0 // char[32]
    m_bombdroppedlightParticleIndex = 0X0013F0 // ParticleIndex_t
    m_bStartedArming = 0X0013F4 // bool
    m_fArmedTime = 0X0013F8 // GameTime_t
    m_bBombPlacedAnimation = 0X0013FC // bool
    m_bShowC4LED = 0X0013FD // bool
    m_bIsPlantingViaUse = 0X0013FE // bool
    m_entitySpottedState = 0X001400 // EntitySpottedState_t
    m_nSpotRules = 0X001418 // int32
    m_bPlayedArmingBeeps = 0X00141C // bool[7]
    m_bBombPlanted = 0X001423 // bool
    m_bDroppedFromDeath = 0X001424 // bool

 C_DEagle: [client.dll]
    No schemes available

 C_WeaponElite: [client.dll]
    No schemes available

 C_WeaponNOVA: [client.dll]
    No schemes available

 C_WeaponSawedoff: [client.dll]
    No schemes available

 C_WeaponTaser: [client.dll]
    m_fFireTime = 0X0013F0 // GameTime_t

 C_WeaponXM1014: [client.dll]
    No schemes available

 C_Knife: [client.dll]
    No schemes available

 C_KnifeGG: [client.dll]
    No schemes available

 C_Melee: [client.dll]
    m_flThrowAt = 0X0013D0 // GameTime_t

 C_WeaponZoneRepulsor: [client.dll]
    m_flPitchLocal = 0X0013F0 // float32
    m_flLastTimeNotIdle = 0X0013F4 // GameTime_t

 C_WeaponShield: [client.dll]
    m_flDisplayHealth = 0X0013F0 // float32

 C_MolotovProjectile: [client.dll]
    m_bIsIncGrenade = 0X000C00 // bool

 C_DecoyProjectile: [client.dll]
    m_flTimeParticleEffectSpawn = 0X000C20 // GameTime_t

 C_SmokeGrenadeProjectile: [client.dll]
    m_nSmokeEffectTickBegin = 0X000C08 // int32
    m_bDidSmokeEffect = 0X000C0C // bool
    m_nRandomSeed = 0X000C10 // int32
    m_vSmokeColor = 0X000C14 // Vector
    m_vSmokeDetonationPos = 0X000C20 // Vector
    m_VoxelFrameData = 0X000C30 // CUtlVector< uint8 >
    m_bSmokeVolumeDataReceived = 0X000C48 // bool
    m_bSmokeEffectSpawned = 0X000C49 // bool

 C_BaseCSGrenade: [client.dll]
    m_bRedraw = 0X0013F0 // bool
    m_bIsHeldByPlayer = 0X0013F1 // bool
    m_bPinPulled = 0X0013F2 // bool
    m_eThrowStatus = 0X0013F4 // EGrenadeThrowState
    m_fThrowTime = 0X0013F8 // GameTime_t
    m_flThrowStrength = 0X0013FC // float32
    m_flThrowStrengthApproach = 0X001400 // float32
    m_fDropTime = 0X001404 // GameTime_t

 C_WeaponBaseItem: [client.dll]
    m_SequenceCompleteTimer = 0X0013D0 // CountdownTimer
    m_bRedraw = 0X0013E8 // bool

 C_ItemDogtags: [client.dll]
    m_OwningPlayer = 0X001178 // CHandle< C_CSPlayerPawnBase >
    m_KillingPlayer = 0X00117C // CHandle< C_CSPlayerPawnBase >

 C_Item_Healthshot: [client.dll]
    No schemes available

 C_Fists: [client.dll]
    m_bPlayingUninterruptableAct = 0X0013D0 // bool
    m_nUninterruptableActivity = 0X0013D4 // PlayerAnimEvent_t

 C_Tablet: [client.dll]
    m_flUpgradeExpirationTime = 0X0013D8 // GameTime_t[4]
    m_vecLocalHexFlags = 0X0013E8 // int32[42]
    m_nContractKillGridIndex = 0X001490 // int32
    m_nContractKillGridHighResIndex = 0X001494 // int32
    m_bTabletReceptionIsBlocked = 0X001498 // bool
    m_flScanProgress = 0X00149C // float32
    m_flBootTime = 0X0014A0 // GameTime_t
    m_flShowMapTime = 0X0014A4 // GameTime_t
    m_vecNearestMetalCratePos = 0X0014A8 // Vector
    m_skinState = 0X0014B4 // tablet_skin_state_t
    m_vecNotificationIds = 0X0014B8 // int32[8]
    m_vecNotificationTimestamps = 0X0014D8 // GameTime_t[8]
    m_nLastPurchaseIndex = 0X0014F8 // int32
    m_vecPlayerPositionHistory = 0X0014FC // Vector[24]
    m_vecLocalHexFlagsClientCopy = 0X00161C // int32[42]
    m_vecLastHexPlayerOccupancyChange = 0X0016C4 // GameTime_t[6][42]
    m_radarMaterial = 0X001AE8 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_buildingMaterial = 0X001AF0 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_hZoneOverlayMaterial = 0X001AF8 // CStrongHandle< InfoForResourceTypeIMaterial2 >
    m_flNoiseFadeAlpha = 0X001B00 // float32
    m_WorkingColor = 0X001B04 // Color
    m_vecLastCameraPos = 0X001B08 // Vector
    m_angLastCameraAng = 0X001B14 // QAngle
    m_nDrawElementCount = 0X001B20 // int32
    m_flPrevScanProgress = 0X001B24 // float32
    m_nRenderTargetRes = 0X001B28 // int32
    m_flLastClosePoseParamVal = 0X001B2C // float32

 C_BreachCharge: [client.dll]
    No schemes available

 C_BumpMine: [client.dll]
    No schemes available

 C_TripWireFire: [client.dll]
    No schemes available

 C_PlantedC4Survival: [client.dll]
    No schemes available

 C_SensorGrenade: [client.dll]
    No schemes available

 C_CSPlayerPawnBase: [client.dll]
    m_pActionTrackingServices = 0X000D18 // CCSPlayer_ActionTrackingServices*
    m_pPingServices = 0X000D20 // CCSPlayer_PingServices*
    m_pViewModelServices = 0X000D28 // CCSPlayer_ViewModelServices*
    m_fRenderingClipPlane = 0X000D30 // float32[4]
    m_nLastClipPlaneSetupFrame = 0X000D40 // int32
    m_vecLastClipCameraPos = 0X000D44 // Vector
    m_vecLastClipCameraForward = 0X000D50 // Vector
    m_bClipHitStaticWorld = 0X000D5C // bool
    m_bCachedPlaneIsValid = 0X000D5D // bool
    m_pClippingWeapon = 0X000D60 // C_WeaponCSBase*
    m_bHasFemaleVoice = 0X000D68 // bool
    m_previousPlayerState = 0X000D6C // CSPlayerState
    m_flLastCollisionCeiling = 0X000D70 // float32
    m_flLastCollisionCeilingChangeTime = 0X000D74 // float32
    m_bInLanding = 0X000DD0 // bool
    m_flLandingTime = 0X000DD4 // float32
    m_grenadeParameterStashTime = 0X000DD8 // GameTime_t
    m_bGrenadeParametersStashed = 0X000DDC // bool
    m_angStashedShootAngles = 0X000DE0 // QAngle
    m_vecStashedGrenadeThrowPosition = 0X000DEC // Vector
    m_vecStashedVelocity = 0X000DF8 // Vector
    m_angShootAngleHistory = 0X000E04 // QAngle[2]
    m_vecThrowPositionHistory = 0X000E1C // Vector[2]
    m_vecVelocityHistory = 0X000E34 // Vector[2]
    m_thirdPersonHeading = 0X000E50 // QAngle
    m_flSlopeDropOffset = 0X000E68 // float32
    m_flSlopeDropHeight = 0X000E78 // float32
    m_vHeadConstraintOffset = 0X000E88 // Vector
    m_bClientTransparentImmunityAlphaEffectEnabled = 0X000EA0 // bool
    m_bClientDeferDrawToImmunityAlphaPass = 0X000EA1 // bool
    m_bIsScoped = 0X000EA2 // bool
    m_bIsWalking = 0X000EA3 // bool
    m_bResumeZoom = 0X000EA4 // bool
    m_iPlayerState = 0X000EA8 // CSPlayerState
    m_bIsDefusing = 0X000EAC // bool
    m_bIsGrabbingHostage = 0X000EAD // bool
    m_iBlockingUseActionInProgress = 0X000EB0 // CSPlayerBlockingUseAction_t
    m_bIsRescuing = 0X000EB4 // bool
    m_fImmuneToGunGameDamageTime = 0X000EB8 // GameTime_t
    m_fImmuneToGunGameDamageTimeLast = 0X000EBC // GameTime_t
    m_bGunGameImmunity = 0X000EC0 // bool
    m_bHasMovedSinceSpawn = 0X000EC1 // bool
    m_bMadeFinalGunGameProgressiveKill = 0X000EC2 // bool
    m_iGunGameProgressiveWeaponIndex = 0X000EC4 // int32
    m_iNumGunGameTRKillPoints = 0X000EC8 // int32
    m_iNumGunGameKillsWithCurrentWeapon = 0X000ECC // int32
    m_unTotalRoundDamageDealt = 0X000ED0 // uint32
    m_fMolotovUseTime = 0X000ED4 // float32
    m_fMolotovDamageTime = 0X000ED8 // float32
    m_bInBombZone = 0X000EDC // bool
    m_nWhichBombZone = 0X000EE0 // int32
    m_bInBuyZone = 0X000EE4 // bool
    m_bInNoDefuseArea = 0X000EE5 // bool
    m_iThrowGrenadeCounter = 0X000EE8 // int32
    m_bWaitForNoAttack = 0X000EEC // bool
    m_bIsRespawningForDMBonus = 0X000EED // bool
    m_flGuardianTooFarDistFrac = 0X000EF0 // float32
    m_flDetectedByEnemySensorTime = 0X000EF4 // GameTime_t
    m_flNextGuardianTooFarWarning = 0X000EF8 // float32
    m_bSuppressGuardianTooFarWarningAudio = 0X000EFC // bool
    m_bKilledByTaser = 0X000EFD // bool
    m_iMoveState = 0X000F00 // int32
    m_bCanMoveDuringFreezePeriod = 0X000F04 // bool
    m_isCurrentGunGameLeader = 0X000F05 // bool
    m_isCurrentGunGameTeamLeader = 0X000F06 // bool
    m_flLowerBodyYawTarget = 0X000F08 // float32
    m_bStrafing = 0X000F0C // bool
    m_szLastPlaceName = 0X000F0D // char[18]
    m_flLastExoJumpTime = 0X000F20 // float32
    m_flLastSpawnTimeIndex = 0X000F30 // GameTime_t
    m_flEmitSoundTime = 0X000F34 // GameTime_t
    m_iAddonBits = 0X000F38 // int32
    m_iPrimaryAddon = 0X000F3C // int32
    m_iSecondaryAddon = 0X000F40 // int32
    m_iProgressBarDuration = 0X000F44 // int32
    m_flProgressBarStartTime = 0X000F48 // float32
    m_flStamina = 0X000F4C // float32
    m_iDirection = 0X000F50 // int32
    m_iShotsFired = 0X000F54 // int32
    m_bNightVisionOn = 0X000F58 // bool
    m_bHasNightVision = 0X000F59 // bool
    m_flVelocityModifier = 0X000F5C // float32
    m_flGroundAccelLinearFracLastTime = 0X000F60 // float32
    m_iStartAccount = 0X000F64 // int32
    m_bIsSpawnRappelling = 0X000F68 // bool
    m_vecSpawnRappellingRopeOrigin = 0X000F6C // Vector
    m_flSpawnRappellingFadeOutForClientViewOffset = 0X000F78 // float32
    m_nSurvivalTeam = 0X000F7C // int32
    m_hSurvivalAssassinationTarget = 0X000F80 // CHandle< C_CSPlayerPawnBase >
    m_flHealthShotBoostExpirationTime = 0X000F84 // float32
    m_flLastKnownParachuteScreenEffectAmount = 0X000F88 // float32
    m_vecIntroStartEyePosition = 0X000F8C // Vector
    m_vecIntroStartPlayerForward = 0X000F98 // Vector
    m_flClientDeathTime = 0X000FA4 // float32
    m_flNightVisionAlpha = 0X000FB0 // float32
    m_bScreenTearFrameCaptured = 0X000FB4 // bool
    m_flFlashBangTime = 0X000FB8 // float32
    m_flFlashScreenshotAlpha = 0X000FBC // float32
    m_flFlashOverlayAlpha = 0X000FC0 // float32
    m_bFlashBuildUp = 0X000FC4 // bool
    m_bFlashDspHasBeenCleared = 0X000FC5 // bool
    m_bFlashScreenshotHasBeenGrabbed = 0X000FC6 // bool
    m_flFlashMaxAlpha = 0X000FC8 // float32
    m_flFlashDuration = 0X000FCC // float32
    m_flLastFiredWeaponTime = 0X000FD0 // float32
    m_lastStandingPos = 0X000FD4 // Vector
    m_vecLastMuzzleFlashPos = 0X000FE0 // Vector
    m_angLastMuzzleFlashAngle = 0X000FEC // QAngle
    m_hMuzzleFlashShape = 0X000FF8 // CHandle< C_BaseEntity >
    m_iHealthBarRenderMaskIndex = 0X000FFC // int32
    m_flHealthFadeValue = 0X001000 // float32
    m_flHealthFadeAlpha = 0X001004 // float32
    m_nMyCollisionGroup = 0X001008 // int32
    m_ignoreLadderJumpTime = 0X00100C // float32
    m_ladderSurpressionTimer = 0X001010 // CountdownTimer
    m_lastLadderNormal = 0X001028 // Vector
    m_lastLadderPos = 0X001034 // Vector
    m_flDeathCCWeight = 0X001048 // float32
    m_bOldIsScoped = 0X00104C // bool
    m_flPrevRoundEndTime = 0X001050 // float32
    m_flPrevMatchEndTime = 0X001054 // float32
    m_unCurrentEquipmentValue = 0X001058 // uint16
    m_unRoundStartEquipmentValue = 0X00105A // uint16
    m_unFreezetimeEndEquipmentValue = 0X00105C // uint16
    m_passiveItems = 0X00105E // bool[4]
    m_vecThirdPersonViewPositionOverride = 0X001064 // Vector
    m_nHeavyAssaultSuitCooldownRemaining = 0X001070 // int32
    m_ArmorValue = 0X001074 // int32
    m_angEyeAngles = 0X001078 // QAngle
    m_bInHostageRescueZone = 0X001090 // bool
    m_fNextThinkPushAway = 0X001094 // float32
    m_bShouldAutobuyDMWeapons = 0X001098 // bool
    m_bShouldAutobuyNow = 0X001099 // bool
    m_bHud_MiniScoreHidden = 0X00109A // bool
    m_bHud_RadarHidden = 0X00109B // bool
    m_nLastKillerIndex = 0X00109C // CEntityIndex
    m_nLastConcurrentKilled = 0X0010A0 // int32
    m_nDeathCamMusic = 0X0010A4 // int32
    m_iIDEntIndex = 0X0010A8 // CEntityIndex
    m_delayTargetIDTimer = 0X0010B0 // CountdownTimer
    m_iTargetedWeaponEntIndex = 0X0010C8 // CEntityIndex
    m_iOldIDEntIndex = 0X0010CC // CEntityIndex
    m_holdTargetIDTimer = 0X0010D0 // CountdownTimer
    m_flCurrentMusicStartTime = 0X001134 // float32
    m_flMusicRoundStartTime = 0X001138 // float32
    m_cycleLatch = 0X00113C // int32
    m_serverIntendedCycle = 0X001140 // float32
    m_vecPlayerPatchEconIndices = 0X001144 // uint32[5]
    m_bClientEconPatchesNeedUpdate = 0X001158 // bool
    m_bHideTargetID = 0X001159 // bool
    m_nextTaserShakeTime = 0X00115C // float32
    m_firstTaserShakeTime = 0X001160 // float32
    m_flLastSmokeOverlayAlpha = 0X001164 // float32
    m_vLastSmokeOverlayColor = 0X001168 // Vector
    m_nPlayerSmokedFx = 0X001174 // ParticleIndex_t
    m_flLastKnownAccumulatedWeaponEncumbrance = 0X001178 // float32
    m_flLastTimeComputedAccumulatedWeaponEncumbrance = 0X00117C // float32
    m_flNextMagDropTime = 0X001180 // float32
    m_nLastMagDropAttachmentIndex = 0X001184 // int32
    m_vecBulletHitModels = 0X001188 // CUtlVector< C_BulletHitModel* >
    m_vecPickupModelSlerpers = 0X0011A0 // CUtlVector< C_PickUpModelSlerper* >
    m_vecLastAliveLocalVelocity = 0X0011B8 // Vector
    m_flLastNearbyItemHighlightCheck = 0X0011C4 // float32
    m_bInSurvivalDangerZone = 0X0011C8 // bool
    m_bNearDangerZone = 0X0011C9 // bool
    m_entitySpottedState = 0X001200 // EntitySpottedState_t
    m_flTimeOfLastInjury = 0X001218 // float32
    m_nRelativeDirectionOfLastInjury = 0X00121C // RelativeDamagedDirection_t
    m_nSurvivalTeamNumber = 0X001220 // int32
    m_flNextSprayDecalTime = 0X001224 // float32
    m_bPreviouslyInBuyZone = 0X001228 // bool
    m_unPreviousWeaponHash = 0X00122C // uint32
    m_unWeaponHash = 0X001230 // uint32
    m_bPrevDefuser = 0X001234 // bool
    m_bPrevHelmet = 0X001235 // bool
    m_nPrevArmorVal = 0X001238 // int32
    m_bGuardianShouldSprayCustomXMark = 0X00123C // bool
    m_aimPunchAngle = 0X001240 // QAngle
    m_aimPunchAngleVel = 0X00124C // QAngle
    m_aimPunchTickBase = 0X001258 // int32
    m_aimPunchTickFraction = 0X00125C // float32
    m_aimPunchCache = 0X001260 // CUtlVector< QAngle >
    m_flOldFallVelocity = 0X001280 // float32
    m_bHasDeathInfo = 0X001284 // bool
    m_flDeathInfoTime = 0X001288 // float32
    m_vecDeathInfoOrigin = 0X00128C // Vector
    m_bKilledByHeadshot = 0X001298 // bool
    m_hOriginalController = 0X00129C // CHandle< CCSPlayerController >
    m_flLandseconds = 0X0012B0 // float32

 C_CSObserverPawn: [client.dll]
    m_hDetectParentChange = 0X0012B8 // CEntityHandle

 C_CSPlayerPawn: [client.dll]
    m_pBulletServices = 0X0012B8 // CCSPlayer_BulletServices*
    m_pHostageServices = 0X0012C0 // CCSPlayer_HostageServices*
    m_pGlowServices = 0X0012C8 // CCSPlayer_GlowServices*
    m_bIsBuyMenuOpen = 0X0012D0 // bool
    m_iRetakesOffering = 0X0013A0 // int32
    m_iRetakesOfferingCard = 0X0013A4 // int32
    m_bRetakesHasDefuseKit = 0X0013A8 // bool
    m_bRetakesMVPLastRound = 0X0013A9 // bool
    m_iRetakesMVPBoostItem = 0X0013AC // int32
    m_RetakesMVPBoostExtraUtility = 0X0013B0 // loadout_positions_t
    m_bNeedToReApplyGloves = 0X0013C4 // bool
    m_EconGloves = 0X0013C8 // C_EconItemView
    m_bMustSyncRagdollState = 0X001810 // bool
    m_nRagdollDamageBone = 0X001814 // int32
    m_vRagdollDamageForce = 0X001818 // Vector
    m_vRagdollDamagePosition = 0X001824 // Vector
    m_szRagdollDamageWeaponName = 0X001830 // char[64]
    m_bRagdollDamageHeadshot = 0X001870 // bool
    m_bLastHeadBoneTransformIsValid = 0X001998 // bool
    m_qDeathEyeAngles = 0X0019B4 // QAngle

 C_Hostage: [client.dll]
    m_entitySpottedState = 0X000BB8 // EntitySpottedState_t
    m_leader = 0X000BD0 // CHandle< C_BaseEntity >
    m_vel = 0X000BD4 // Vector
    m_isRescued = 0X000BE0 // bool
    m_jumpedThisFrame = 0X000BE1 // bool
    m_nHostageState = 0X000BE4 // int32
    m_flRescueStartTime = 0X000BE8 // GameTime_t
    m_flGrabSuccessTime = 0X000BEC // GameTime_t
    m_flDropStartTime = 0X000BF0 // GameTime_t
    m_flDeadOrRescuedTime = 0X000BF4 // GameTime_t
    m_blinkTimer = 0X000BF8 // CountdownTimer
    m_lookAt = 0X000C10 // Vector
    m_lookAroundTimer = 0X000C20 // CountdownTimer
    m_isInit = 0X000C38 // bool
    m_eyeAttachment = 0X000C39 // AttachmentHandle_t
    m_chestAttachment = 0X000C3A // AttachmentHandle_t

 C_NetTestBaseCombatCharacter: [client.dll]
    No schemes available

 C_AK47: [client.dll]
    No schemes available

 C_WeaponAug: [client.dll]
    No schemes available

 C_WeaponAWP: [client.dll]
    No schemes available

 C_WeaponBizon: [client.dll]
    No schemes available

 C_WeaponFamas: [client.dll]
    No schemes available

 C_WeaponFiveSeven: [client.dll]
    No schemes available

 C_WeaponG3SG1: [client.dll]
    No schemes available

 C_WeaponGalilAR: [client.dll]
    No schemes available

 C_WeaponGlock: [client.dll]
    No schemes available

 C_WeaponHKP2000: [client.dll]
    No schemes available

 C_WeaponM4A1: [client.dll]
    No schemes available

 C_WeaponMAC10: [client.dll]
    No schemes available

 C_WeaponMag7: [client.dll]
    No schemes available

 C_WeaponMP7: [client.dll]
    No schemes available

 C_WeaponMP9: [client.dll]
    No schemes available

 C_WeaponNegev: [client.dll]
    No schemes available

 C_WeaponP250: [client.dll]
    No schemes available

 C_WeaponP90: [client.dll]
    No schemes available

 C_WeaponSCAR20: [client.dll]
    No schemes available

 C_WeaponSG556: [client.dll]
    No schemes available

 C_WeaponSSG08: [client.dll]
    No schemes available

 C_WeaponTec9: [client.dll]
    No schemes available

 C_WeaponUMP45: [client.dll]
    No schemes available

 C_WeaponM249: [client.dll]
    No schemes available

 C_MolotovGrenade: [client.dll]
    No schemes available

 C_IncendiaryGrenade: [client.dll]
    No schemes available

 C_DecoyGrenade: [client.dll]
    No schemes available

 C_Flashbang: [client.dll]
    No schemes available

 C_HEGrenade: [client.dll]
    No schemes available

 C_SmokeGrenade: [client.dll]
    No schemes available

 C_CSGO_PreviewPlayer: [client.dll]
    m_animgraph = 0X0019C0 // CUtlString
    m_animgraphCharacterModeString = 0X0019C8 // CUtlString
    m_flInitialModelScale = 0X0019D0 // float32

 C_CSGO_PreviewPlayerAlias_csgo_player_previewmodel: [client.dll]
    No schemes available

 C_CSGO_TeamPreviewModel: [client.dll]
    No schemes available


scenefilecache.dll:
  No schemes classes available | scenefilecache.dll
